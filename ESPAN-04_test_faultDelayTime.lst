CCS PCH C Compiler, Version 5.080, 5967               12-¾.Â.-19 13:23

               Filename:   D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_20 - Delay - SP - SMD - PIC18F252\ESPAN-04_test_faultDelayTime.lst

               ROM used:   32434 bytes (99%)
                           Largest free fragment is 330
               RAM used:   489 (32%) at main() level
                           532 (35%) worst case
               Stack used: 4 locations (3 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   7406
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   051E
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   050C
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #include "D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_20 - Delay - SP - SMD - PIC18F252\ESPAN-04.h" 
.................... #include <18F252.h> 
.................... //////////// Standard Header file for the PIC18F252 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F252 
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 00,C1
00CC:  DATA 81,40
00CE:  DATA 01,C0
00D0:  DATA 80,41
00D2:  DATA 01,C0
00D4:  DATA 80,41
00D6:  DATA 00,C1
00D8:  DATA 81,40
00DA:  DATA 01,C0
00DC:  DATA 80,41
00DE:  DATA 00,C1
00E0:  DATA 81,40
00E2:  DATA 00,C1
00E4:  DATA 81,40
00E6:  DATA 01,C0
00E8:  DATA 80,41
00EA:  DATA 01,C0
00EC:  DATA 80,41
00EE:  DATA 00,C1
00F0:  DATA 81,40
00F2:  DATA 00,C1
00F4:  DATA 81,40
00F6:  DATA 01,C0
00F8:  DATA 80,41
00FA:  DATA 00,C1
00FC:  DATA 81,40
00FE:  DATA 01,C0
0100:  DATA 80,41
0102:  DATA 01,C0
0104:  DATA 80,41
0106:  DATA 00,C1
0108:  DATA 81,40
010A:  DATA 01,C0
010C:  DATA 80,41
010E:  DATA 00,C1
0110:  DATA 81,40
0112:  DATA 00,C1
0114:  DATA 81,40
0116:  DATA 01,C0
0118:  DATA 80,41
011A:  DATA 00,C1
011C:  DATA 81,40
011E:  DATA 01,C0
0120:  DATA 80,41
0122:  DATA 01,C0
0124:  DATA 80,41
0126:  DATA 00,C1
0128:  DATA 81,40
012A:  DATA 00,C1
012C:  DATA 81,40
012E:  DATA 01,C0
0130:  DATA 80,41
0132:  DATA 01,C0
0134:  DATA 80,41
0136:  DATA 00,C1
0138:  DATA 81,40
013A:  DATA 01,C0
013C:  DATA 80,41
013E:  DATA 00,C1
0140:  DATA 81,40
0142:  DATA 00,C1
0144:  DATA 81,40
0146:  DATA 01,C0
0148:  DATA 80,41
014A:  DATA 01,C0
014C:  DATA 80,41
014E:  DATA 00,C1
0150:  DATA 81,40
0152:  DATA 00,C1
0154:  DATA 81,40
0156:  DATA 01,C0
0158:  DATA 80,41
015A:  DATA 00,C1
015C:  DATA 81,40
015E:  DATA 01,C0
0160:  DATA 80,41
0162:  DATA 01,C0
0164:  DATA 80,41
0166:  DATA 00,C1
0168:  DATA 81,40
016A:  DATA 00,C1
016C:  DATA 81,40
016E:  DATA 01,C0
0170:  DATA 80,41
0172:  DATA 01,C0
0174:  DATA 80,41
0176:  DATA 00,C1
0178:  DATA 81,40
017A:  DATA 01,C0
017C:  DATA 80,41
017E:  DATA 00,C1
0180:  DATA 81,40
0182:  DATA 00,C1
0184:  DATA 81,40
0186:  DATA 01,C0
0188:  DATA 80,41
018A:  DATA 00,C1
018C:  DATA 81,40
018E:  DATA 01,C0
0190:  DATA 80,41
0192:  DATA 01,C0
0194:  DATA 80,41
0196:  DATA 00,C1
0198:  DATA 81,40
019A:  DATA 01,C0
019C:  DATA 80,41
019E:  DATA 00,C1
01A0:  DATA 81,40
01A2:  DATA 00,C1
01A4:  DATA 81,40
01A6:  DATA 01,C0
01A8:  DATA 80,41
01AA:  DATA 01,C0
01AC:  DATA 80,41
01AE:  DATA 00,C1
01B0:  DATA 81,40
01B2:  DATA 00,C1
01B4:  DATA 81,40
01B6:  DATA 01,C0
01B8:  DATA 80,41
01BA:  DATA 00,C1
01BC:  DATA 81,40
01BE:  DATA 01,C0
01C0:  DATA 80,41
01C2:  DATA 01,C0
01C4:  DATA 80,41
01C6:  DATA 00,C1
01C8:  DATA 81,40
01CA:  CLRF   FF7
01CC:  ADDLW  DA
01CE:  MOVWF  FF6
01D0:  MOVLW  01
01D2:  ADDWFC FF7,F
01D4:  TBLRD*+
01D6:  MOVF   FF5,W
01D8:  RETURN 0
01DA:  DATA 00,C0
01DC:  DATA C1,01
01DE:  DATA C3,03
01E0:  DATA 02,C2
01E2:  DATA C6,06
01E4:  DATA 07,C7
01E6:  DATA 05,C5
01E8:  DATA C4,04
01EA:  DATA CC,0C
01EC:  DATA 0D,CD
01EE:  DATA 0F,CF
01F0:  DATA CE,0E
01F2:  DATA 0A,CA
01F4:  DATA CB,0B
01F6:  DATA C9,09
01F8:  DATA 08,C8
01FA:  DATA D8,18
01FC:  DATA 19,D9
01FE:  DATA 1B,DB
0200:  DATA DA,1A
0202:  DATA 1E,DE
0204:  DATA DF,1F
0206:  DATA DD,1D
0208:  DATA 1C,DC
020A:  DATA 14,D4
020C:  DATA D5,15
020E:  DATA D7,17
0210:  DATA 16,D6
0212:  DATA D2,12
0214:  DATA 13,D3
0216:  DATA 11,D1
0218:  DATA D0,10
021A:  DATA F0,30
021C:  DATA 31,F1
021E:  DATA 33,F3
0220:  DATA F2,32
0222:  DATA 36,F6
0224:  DATA F7,37
0226:  DATA F5,35
0228:  DATA 34,F4
022A:  DATA 3C,FC
022C:  DATA FD,3D
022E:  DATA FF,3F
0230:  DATA 3E,FE
0232:  DATA FA,3A
0234:  DATA 3B,FB
0236:  DATA 39,F9
0238:  DATA F8,38
023A:  DATA 28,E8
023C:  DATA E9,29
023E:  DATA EB,2B
0240:  DATA 2A,EA
0242:  DATA EE,2E
0244:  DATA 2F,EF
0246:  DATA 2D,ED
0248:  DATA EC,2C
024A:  DATA E4,24
024C:  DATA 25,E5
024E:  DATA 27,E7
0250:  DATA E6,26
0252:  DATA 22,E2
0254:  DATA E3,23
0256:  DATA E1,21
0258:  DATA 20,E0
025A:  DATA A0,60
025C:  DATA 61,A1
025E:  DATA 63,A3
0260:  DATA A2,62
0262:  DATA 66,A6
0264:  DATA A7,67
0266:  DATA A5,65
0268:  DATA 64,A4
026A:  DATA 6C,AC
026C:  DATA AD,6D
026E:  DATA AF,6F
0270:  DATA 6E,AE
0272:  DATA AA,6A
0274:  DATA 6B,AB
0276:  DATA 69,A9
0278:  DATA A8,68
027A:  DATA 78,B8
027C:  DATA B9,79
027E:  DATA BB,7B
0280:  DATA 7A,BA
0282:  DATA BE,7E
0284:  DATA 7F,BF
0286:  DATA 7D,BD
0288:  DATA BC,7C
028A:  DATA B4,74
028C:  DATA 75,B5
028E:  DATA 77,B7
0290:  DATA B6,76
0292:  DATA 72,B2
0294:  DATA B3,73
0296:  DATA B1,71
0298:  DATA 70,B0
029A:  DATA 50,90
029C:  DATA 91,51
029E:  DATA 93,53
02A0:  DATA 52,92
02A2:  DATA 96,56
02A4:  DATA 57,97
02A6:  DATA 55,95
02A8:  DATA 94,54
02AA:  DATA 9C,5C
02AC:  DATA 5D,9D
02AE:  DATA 5F,9F
02B0:  DATA 9E,5E
02B2:  DATA 5A,9A
02B4:  DATA 9B,5B
02B6:  DATA 99,59
02B8:  DATA 58,98
02BA:  DATA 88,48
02BC:  DATA 49,89
02BE:  DATA 4B,8B
02C0:  DATA 8A,4A
02C2:  DATA 4E,8E
02C4:  DATA 8F,4F
02C6:  DATA 8D,4D
02C8:  DATA 4C,8C
02CA:  DATA 44,84
02CC:  DATA 85,45
02CE:  DATA 87,47
02D0:  DATA 46,86
02D2:  DATA 82,42
02D4:  DATA 43,83
02D6:  DATA 41,81
02D8:  DATA 80,40
*
14EE:  MOVLB  1
14F0:  MOVF   xEB,W
14F2:  ANDLW  07
14F4:  MOVWF  00
14F6:  RRCF   xEB,W
14F8:  MOVWF  01
14FA:  RRCF   01,F
14FC:  RRCF   01,F
14FE:  MOVLW  1F
1500:  ANDWF  01,F
1502:  MOVF   01,W
1504:  ADDWF  xED,W
1506:  MOVWF  FE9
1508:  MOVLW  00
150A:  ADDWFC xEE,W
150C:  MOVWF  FEA
150E:  CLRF   01
1510:  INCF   01,F
1512:  INCF   00,F
1514:  BRA    1518
1516:  RLCF   01,F
1518:  DECFSZ 00,F
151A:  BRA    1516
151C:  MOVF   xEC,F
151E:  BZ    1526
1520:  MOVF   01,W
1522:  IORWF  FEF,F
1524:  BRA    152C
1526:  COMF   01,F
1528:  MOVF   01,W
152A:  ANDWF  FEF,F
152C:  MOVLB  0
152E:  RETURN 0
1530:  MOVLB  1
1532:  MOVF   xEB,W
1534:  ANDLW  07
1536:  MOVWF  00
1538:  RRCF   xEB,W
153A:  MOVWF  01
153C:  RRCF   01,F
153E:  RRCF   01,F
1540:  MOVLW  1F
1542:  ANDWF  01,F
1544:  MOVF   01,W
1546:  ADDWF  xEC,W
1548:  MOVWF  FE9
154A:  MOVLW  00
154C:  ADDWFC xED,W
154E:  MOVWF  FEA
1550:  MOVFF  FEF,01
1554:  INCF   00,F
1556:  BRA    155A
1558:  RRCF   01,F
155A:  DECFSZ 00,F
155C:  BRA    1558
155E:  MOVLW  01
1560:  ANDWF  01,F
1562:  MOVLB  0
1564:  RETURN 0
*
1A2C:  MOVLB  1
1A2E:  MOVF   xEC,W
1A30:  MULWF  xEE
1A32:  MOVFF  FF3,01
1A36:  MOVFF  FF4,00
1A3A:  MULWF  xEF
1A3C:  MOVF   FF3,W
1A3E:  ADDWF  00,F
1A40:  MOVF   xED,W
1A42:  MULWF  xEE
1A44:  MOVF   FF3,W
1A46:  ADDWFC 00,W
1A48:  MOVWF  02
1A4A:  MOVLB  0
1A4C:  RETURN 0
*
240E:  ADDWF  FE8,W
2410:  CLRF   FF7
2412:  RLCF   FF7,F
2414:  ADDLW  29
2416:  MOVWF  FF6
2418:  MOVLW  24
241A:  ADDWFC FF7,F
241C:  TBLRD*-
241E:  MOVF   FF5,W
2420:  MOVWF  FFA
2422:  TBLRD*
2424:  MOVF   FF5,W
2426:  MOVWF  FF9
2428:  DATA 00,1D
242A:  DATA 06,1D
242C:  DATA 0C,1D
242E:  DATA 12,1D
2430:  DATA 18,1D
2432:  DATA 1E,1D
2434:  DATA 24,1D
2436:  DATA 2A,1D
2438:  DATA 30,1D
243A:  DATA 36,1D
243C:  DATA 3C,1D
243E:  DATA 42,1D
2440:  DATA 48,1D
2442:  DATA 4E,1D
2444:  DATA 54,1D
2446:  DATA 5A,1D
2448:  DATA 60,1D
244A:  DATA 66,1D
244C:  DATA 6C,1D
244E:  DATA 72,1D
2450:  ADDWF  FE8,W
2452:  CLRF   FF7
2454:  RLCF   FF7,F
2456:  ADDLW  6B
2458:  MOVWF  FF6
245A:  MOVLW  24
245C:  ADDWFC FF7,F
245E:  TBLRD*-
2460:  MOVF   FF5,W
2462:  MOVWF  FFA
2464:  TBLRD*
2466:  MOVF   FF5,W
2468:  MOVWF  FF9
246A:  DATA 5A,1E
246C:  DATA 60,1E
246E:  DATA 66,1E
2470:  DATA 6C,1E
2472:  DATA 72,1E
2474:  DATA 78,1E
2476:  DATA 7E,1E
2478:  DATA 84,1E
247A:  DATA 8A,1E
247C:  DATA 90,1E
247E:  DATA 96,1E
2480:  DATA 9C,1E
2482:  DATA A2,1E
2484:  DATA A8,1E
2486:  DATA AE,1E
2488:  DATA B4,1E
248A:  DATA BA,1E
248C:  DATA C0,1E
248E:  DATA C6,1E
2490:  DATA CC,1E
2492:  ADDWF  FE8,W
2494:  CLRF   FF7
2496:  RLCF   FF7,F
2498:  ADDLW  AD
249A:  MOVWF  FF6
249C:  MOVLW  24
249E:  ADDWFC FF7,F
24A0:  TBLRD*-
24A2:  MOVF   FF5,W
24A4:  MOVWF  FFA
24A6:  TBLRD*
24A8:  MOVF   FF5,W
24AA:  MOVWF  FF9
24AC:  DATA EC,1F
24AE:  DATA F2,1F
24B0:  DATA F8,1F
24B2:  DATA FE,1F
24B4:  DATA 04,20
24B6:  DATA 0A,20
24B8:  DATA 10,20
24BA:  DATA 16,20
24BC:  DATA 1C,20
24BE:  DATA 22,20
24C0:  DATA 28,20
24C2:  DATA 2E,20
24C4:  DATA 34,20
24C6:  DATA 3A,20
24C8:  DATA 40,20
24CA:  DATA 46,20
24CC:  DATA 4C,20
24CE:  DATA 52,20
24D0:  DATA 58,20
24D2:  DATA 5E,20
24D4:  ADDWF  FE8,W
24D6:  CLRF   FF7
24D8:  RLCF   FF7,F
24DA:  ADDLW  EF
24DC:  MOVWF  FF6
24DE:  MOVLW  24
24E0:  ADDWFC FF7,F
24E2:  TBLRD*-
24E4:  MOVF   FF5,W
24E6:  MOVWF  FFA
24E8:  TBLRD*
24EA:  MOVF   FF5,W
24EC:  MOVWF  FF9
24EE:  DATA 44,21
24F0:  DATA 4A,21
24F2:  DATA 50,21
24F4:  DATA 56,21
24F6:  DATA 5C,21
24F8:  DATA 62,21
24FA:  DATA 68,21
24FC:  DATA 6E,21
24FE:  DATA 74,21
2500:  DATA 7A,21
2502:  DATA 80,21
2504:  DATA 86,21
2506:  DATA 8C,21
2508:  DATA 92,21
250A:  DATA 98,21
250C:  DATA 9E,21
250E:  DATA A4,21
2510:  DATA AA,21
2512:  DATA B0,21
2514:  DATA B6,21
*
7E32:  ADDWF  FE8,W
7E34:  CLRF   FF7
7E36:  RLCF   FF7,F
7E38:  ADDLW  4D
7E3A:  MOVWF  FF6
7E3C:  MOVLW  7E
7E3E:  ADDWFC FF7,F
7E40:  TBLRD*-
7E42:  MOVF   FF5,W
7E44:  MOVWF  FFA
7E46:  TBLRD*
7E48:  MOVF   FF5,W
7E4A:  MOVWF  FF9
7E4C:  DATA C0,7B
7E4E:  DATA C6,7B
7E50:  DATA CC,7B
7E52:  DATA D2,7B
7E54:  DATA D8,7B
7E56:  DATA DE,7B
7E58:  DATA E4,7B
7E5A:  DATA EA,7B
7E5C:  DATA F0,7B
7E5E:  DATA F6,7B
7E60:  DATA FC,7B
7E62:  DATA 02,7C
7E64:  DATA 08,7C
7E66:  DATA 0E,7C
7E68:  DATA 14,7C
7E6A:  DATA 1A,7C
7E6C:  DATA 20,7C
7E6E:  DATA 26,7C
7E70:  DATA 2C,7C
7E72:  DATA 32,7C
7E74:  ADDWF  FE8,W
7E76:  CLRF   FF7
7E78:  RLCF   FF7,F
7E7A:  ADDLW  8F
7E7C:  MOVWF  FF6
7E7E:  MOVLW  7E
7E80:  ADDWFC FF7,F
7E82:  TBLRD*-
7E84:  MOVF   FF5,W
7E86:  MOVWF  FFA
7E88:  TBLRD*
7E8A:  MOVF   FF5,W
7E8C:  MOVWF  FF9
7E8E:  DATA 50,7C
7E90:  DATA 56,7C
7E92:  DATA 5C,7C
7E94:  DATA 62,7C
7E96:  DATA 68,7C
7E98:  DATA 6E,7C
7E9A:  DATA 74,7C
7E9C:  DATA 7A,7C
7E9E:  DATA 80,7C
7EA0:  DATA 86,7C
7EA2:  DATA 8C,7C
7EA4:  DATA 92,7C
7EA6:  DATA 98,7C
7EA8:  DATA 9E,7C
7EAA:  DATA A4,7C
7EAC:  DATA AA,7C
7EAE:  DATA B0,7C
7EB0:  DATA B6,7C
7EB2:  DATA BC,7C
7EB4:  DATA C2,7C
....................  
.................... #list 
....................  
.................... //#device adc=8 
.................... #FUSES WDT 
.................... #FUSES WDT64                    //Watch Dog Timer uses 1:64 Postscale 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES PROTECT                //Code not protected from reading 
.................... //#FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... //#FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... //#FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... //#FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... //#FUSES NOWRT                    //Program memory not write protected 
.................... //#FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... //#FUSES FCMEN                    //Fail-safe clock monitor enabled 
....................  
.................... /* //jj 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... */ 
....................  
.................... #define CLOCK_SP   20000000   //Clock Speed 20MHz 
....................  
.................... //23S17 Define 
.................... #define IO_MULTIPLE_DEVICES 
.................... #define IO_CS_PIN PIN_A5 
....................  
.................... #use delay(clock=20000000,RESTART_WDT) 
*
05BE:  MOVLW  01
05C0:  MOVWF  FEA
05C2:  MOVLW  EF
05C4:  MOVWF  FE9
05C6:  MOVF   FEF,W
05C8:  BZ    05EC
05CA:  MOVLW  06
05CC:  MOVWF  01
05CE:  MOVLW  BF
05D0:  MOVWF  00
05D2:  CLRWDT
05D4:  DECFSZ 00,F
05D6:  BRA    05D2
05D8:  DECFSZ 01,F
05DA:  BRA    05CE
05DC:  MOVLW  7A
05DE:  MOVWF  00
05E0:  DECFSZ 00,F
05E2:  BRA    05E0
05E4:  BRA    05E6
05E6:  CLRWDT
05E8:  DECFSZ FEF,F
05EA:  BRA    05CA
05EC:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... /* 
.................... #include <16F886.h> 
.................... #device adc=10 
....................  
.................... #FUSES WDT                      //Watch Dog Timer 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... //#FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES PROTECT                  //Code protected from reads 
.................... //#FUSES CPD                      //Data EEPROM Code Protected 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... //#FUSES IESO                     //Internal External Switch Over mode enabled 
.................... //#FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... //#FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... //#FUSES BORV21                   //Brownout reset at 2.1V 
.................... //#FUSES WRT                      //Program Memory Write Protected 
....................  
.................... #use delay(clock=20000000,RESTART_WDT) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,restart_wdt) 
.................... */ 
....................  
....................  
.................... #include "D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_20 - Delay - SP - SMD - PIC18F252\23S17.c" // 16 bit I/O Expander 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                        23S17.c                                      //// 
.................... ////                                                                   //// 
.................... ////   Library for a MicroChip MCP23S17 SPI Port Expansion Chip        //// 
.................... ////                                                                   //// 
.................... //// The MCP23S17 device provides 16-bit, general purpose parallel I/O //// 
.................... //// expansion for SPI applications. The 16-bit I/O port functionally  //// 
.................... //// consists of two 8-bit ports (PORTA and PORTB). There are two      //// 
.................... //// interrupt pins, INTA and INTB, that can be associated with their  //// 
.................... //// respective ports, or can be logically ORed together so that both //// 
.................... //// pins will activate if either port causes an interrupt. The        //// 
.................... //// hardware address pins are used to determine the device address.   ////                                                 //// 
.................... ////                                                                   //// 
.................... ////  A #use spi must be provided by the main program.                 //// 
.................... ////                                                                   //// 
.................... ////  -------------------------------------------------------------    //// 
.................... ////  PIN LAYOUT                                                       //// 
.................... ////  -------------------------------------------------------------    //// 
.................... ////                                                                    //// 
.................... ////        -------------------------------------------                //// 
.................... ////        | 1 : GPB0          | 28: GPA7            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 2 : GPB1          | 27: GPA6            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 3 : GPB2          | 26: GPA5            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 4 : GPB3          | 25: GPA4            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 5 : GPB4          | 24: GPA3            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 6 : GPB5          | 23: GPA2            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 7 : GPB6          | 22: GPA1            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 8 : GPB7          | 21: GPA0            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 9 : Vdd           | 20: INTA            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 10: Vss           | 19: INTB            |                //// 
.................... ////        |     __            |     _____           |                //// 
.................... ////        | 11: CS            | 18: RESET           |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 12: SCK           | 17: A2              |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 13: SI            | 16: A1              |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 14: SO            | 15: A0              |                //// 
.................... ////        -------------------------------------------                //// 
.................... ////                                                                   //// 
.................... ////  -------------------------------------------------------------    //// 
.................... ////  FUNCTIONS                                                        //// 
.................... ////  -------------------------------------------------------------    //// 
.................... ////                                                                   //// 
.................... ////   void IO_INIT()                                                   ////                    
.................... ////     Initializes the 23S17 chips on the SPI bus                      ////                                                  
.................... ////                                                                   ////   
.................... ////  void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data)        //// 
.................... ////     Writes the value to the specified register and device          ////                                                             
.................... ////                                                                   ////   
.................... ////  int8 IO_READ_REGISTER(int8 address, int8 reg);                    //// 
.................... ////     Reads the value of the specified register and device          ////                                                            
.................... ////                                                                   ////   
.................... ////  void IO_OUTPUT_A(int8 address, int8 data);                       //// 
.................... ////     Outputs the value to PORTA on the specified device. Doesn't   //// 
.................... ////     change the direction of the port.                             //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_B(int8 address, int8 data);                       //// 
.................... ////     Outputs the value to PORTB on the specified device. Doesn't   //// 
.................... ////     change the direction of the port.                             //// 
.................... ////                                                                   ////       
.................... ////  int8 IO_INPUT_A(int8 address)                                    //// 
.................... ////     Returns the value of PORTA on the specified device. Doesn't   //// 
.................... ////     change the direction of the port.                             //// 
.................... ////                                                                   ////       
.................... ////  int8 IO_INPUT_B(int8 address)                                    //// 
.................... ////     Returns the value of PORTB on the specified device. Doesn't   //// 
.................... ////     change the direction of the port.                             //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state)           //// 
.................... ////     Outputs the value to specified pin and device. Doesn't change //// 
.................... ////      the direction of the pin.                                     //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_HIGH(int8 address, int8 pin)                      //// 
.................... ////     Sets the output high on the specified pin and device. Doesn't //// 
.................... ////     change the direction of the pin.                              //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_LOW(int8 address, int8 pin)                       //// 
.................... ////     Sets the output low on the specified pin and device. Doesn't  //// 
.................... ////     change the direction of the pin.                              //// 
.................... ////                                                                   ////    
.................... ////  void IO_OUTPUT_FLOAT(int8 address, int8 pin)                     //// 
.................... ////     Sets the pin to an input on the specified device.             //// 
.................... ////                                                                   //// 
.................... ////  void IO_OUTPUT_TOGGLE(int8 address, int8 pin)                    //// 
.................... ////     Toggles the output on the specified pin and device. Doesn't   //// 
.................... ////     change the direction of the pin.                              //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_DRIVE(int8 address, int8 pin)                     //// 
.................... ////     Sets the pin to an output on the specified device.            //// 
.................... ////                                                                   ////       
.................... ////  int1 IO_INPUT(int8 address, int8 pin)                            //// 
.................... ////     Gets the current value on the specified pin and device.       //// 
.................... ////                                                                   ////       
.................... ////  int1 IO_INPUT_STATE(int8 address, int8 pin)                      //// 
.................... ////     Gets the current value on the specified pin and device.       ////  
.................... ////     Doesn't change the direction of the pin.                      //// 
.................... ////                                                                   ////       
.................... ////  int8 IO_GET_TRIS_A(int8 address)                                 //// 
.................... ////     Gets the data direction register for PORTA on the specified   ////  
.................... ////      device.                                                       //// 
.................... ////                                                                   ////       
.................... ////  void IO_SET_TRIS_A(int8 address, int8 data)                      //// 
.................... ////     Sets the data direction register for PORTA on the specified   ////  
.................... ////      device.                                                       //// 
.................... ////                                                                   ////       
.................... ////  int8 IO_GET_TRIS_B(int8 address)                                 //// 
.................... ////     Gets the data direction register for PORTB on the specified   ////  
.................... ////      device.                                                       //// 
.................... ////                                                                   ////       
.................... ////  void IO_SET_TRIS_B(int8 address, int8 data)                      //// 
.................... ////     Sets the data direction register for PORTB on the specified   ////  
.................... ////      device.                                                       //// 
.................... ////                                                                   ////                                                                    //// 
.................... ////  NOTE: address is only valid if IO_MULTIPLE_DEVICES is defined    //// 
.................... ////        in your main program. Use the provided #defines as         //// 
.................... ////        parameters for the address, pin, and reg fields.           //// 
.................... ////                                                                    //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// VERSION HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... //// Author Date        Comments                                       //// 
.................... //// -----  -------     ----------------------------------             //// 
.................... //// TMH    Jul-29-2009 File Created                                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2009 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #ifndef MCP23S17 
.................... #define MCP23S17 
....................  
.................... /****************************************************************************** 
.................... **** DEFINES 
.................... ******************************************************************************/ 
....................  
.................... //This is the device address mask. Device supports up to 8 of the chips on the 
.................... //same bus. If multiple devices are to be used on the same bus, define  
.................... //IO_MULTIPLE_DEVICES in your program. This will add an address field to all  
.................... //functions. If IO_MULTIPLE_DEVICE is not defined, an address of 0 will be  
.................... //assumed (i.e. ground A2, A1, A0) 
.................... #define IO_DEVICE_ADDRESS_READ   0b01000001 
.................... #define IO_DEVICE_ADDRESS_WRITE  0b01000000 
....................  
.................... //User must define a CS pin in main. This pin can be connected to all similar 
.................... //devices on the bus. 
.................... //!#ifndef IO_CS_PIN 
.................... //!#error Must define a chip select pin. 
.................... //!#endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Address Defines 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Use these in the address field if using multiple 23S17 devices. If bit 3 
.................... //// in IOCON is cleared these no longer work and only device 0 can be operated 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifdef IO_MULTIPLE_DEVICES 
....................  
.................... #define IO_DEVICE_0   0b00000000 
.................... #define IO_DEVICE_1   0b00000010 
.................... #define IO_DEVICE_2   0b00000100 
.................... #define IO_DEVICE_3   0b00000110 
.................... #define IO_DEVICE_4   0b00001000 
.................... #define IO_DEVICE_5   0b00001010 
.................... #define IO_DEVICE_6   0b00001100 
.................... #define IO_DEVICE_7   0b00001110 
....................  
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Device Register Defines 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Used in the reg field. If IOCON bit 7 is cleared these no longer are  
.................... //// correct, use values to right. Refer to data sheet for more information 
.................... //// on their use. 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #define IODIRA      0x00     //0x00   Data Direction Register for PORTA 
.................... #define IPOLA     0x01     //0x02   Input Polarity Register for PORTA 
.................... #define GPINTENA    0x02     //0x04     Interrupt-on-change enable Register for PORTA                         
.................... #define DEFVALA   0x03     //0x06   Default Value Register for PORTA 
.................... #define INTCONA   0x04     //0x08   Interrupt-on-change control Register for PORTA                           
.................... #define IOCON      0x05     //0x0A   Configuration register for device                       
.................... #define GPPUA      0x06     //0x0C   100kOhm pullup resistor register for PORTA (sets pin to input when set)                            
.................... #define INTFA      0x07     //0x0E   Interrupt flag Register for PORTA                              
.................... #define INTCAPA   0x08     //0x10   Interrupt captured value Register for PORTA                   
.................... #define GPIOA      0x09     //0x12   General purpose I/O Register for PORTA                             
.................... #define OLATA      0x0A     //0x14   Output latch Register for PORTA 
....................  
.................... #define IODIRB    0x10     //0x01   Data Direction Register for PORTB 
.................... #define IPOLB     0x11     //0x03   Input Polarity Register for PORTB 
.................... #define GPINTENB    0x12     //0x05     Interrupt-on-change enable Register for PORTB 
.................... #define DEFVALB   0x13     //0x07   Default Value Register for PORTB 
.................... #define INTCONB   0x14     //0x09   Interrupt-on-change control Register for PORTB 
.................... //#define IOCON      0x15     //0x0B   //IOCON has 2 different addresses, both write to same register                               
.................... #define GPPUB      0x16     //0x0D   100kOhm pullup resistor register for PORTB (sets pin to input when set) 
.................... #define INTFB      0x17     //0x0F   Interrupt flag Register for PORTB  
.................... #define INTCAPB   0x18     //0x11   Interrupt captured value Register for PORTB 
.................... #define GPIOB      0x19     //0x13   General purpose I/O Register for PORTB 
.................... #define OLATB      0x1A     //0x15   Output latch Register for PORTB 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Pin Defines 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Use in the Pin field. 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define IO_PIN_A0      0x80 
.................... #define IO_PIN_A1      0x81 
.................... #define IO_PIN_A2      0x82 
.................... #define IO_PIN_A3      0x83 
.................... #define IO_PIN_A4      0x84 
.................... #define IO_PIN_A5      0x85 
.................... #define IO_PIN_A6      0x86 
.................... #define IO_PIN_A7      0x87 
....................  
.................... #define IO_PIN_B0      0x00 
.................... #define IO_PIN_B1      0x01 
.................... #define IO_PIN_B2      0x02 
.................... #define IO_PIN_B3      0x03 
.................... #define IO_PIN_B4      0x04 
.................... #define IO_PIN_B5      0x05 
.................... #define IO_PIN_B6      0x06 
.................... #define IO_PIN_B7      0x07 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IOCON Bits 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// OR wanted options together when setting the IOCON register. 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define IO_IOCON_BANK      0x80   //Sets register addresses. Initialized to 1.                             
.................... #define IO_IOCON_MIRROR    0x40   //Internally connect interrupt PINs.  
.................... #define IO_IOCON_SEQOP     0x20   //Sets ~Sequential/Byte mode. Driver only uses byte mode. 
.................... #define IO_IOCON_DISSLW    0x10    //Enables slew rate for SDA output                              
.................... #define IO_IOCON_HAEN      0x08   //Enables hardware address pins. If 0 only one device can be used. 
.................... #define IO_IOCON_ODR       0x04   //Open drain/~active drive interrupt pin outputs 
.................... #define IO_IOCON_INTPOL    0x02   //Sets INT output as active high/~low 
....................  
.................... /****************************************************************************** 
.................... **** FUNCTION PROTOTYPES 
.................... ******************************************************************************/ 
....................  
.................... void IO_INIT();   //don't need multiple inits because all devices are assumed 0 before HAEN is set 
....................  
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_WRITE_REGISTER(int8 reg, int8 data); 
.................... int8 IO_READ_REGISTER(int8 reg); 
.................... void IO_OUTPUT_A(int8 data); 
.................... void IO_OUTPUT_B(int8 data); 
.................... int8 IO_INPUT_A(); 
.................... int8 IO_INPUT_B(); 
.................... void IO_OUTPUT_BIT(int8 pin, int1 state); 
.................... void IO_OUTPUT_HIGH(int8 pin); 
.................... void IO_OUTPUT_LOW(int8 pin); 
.................... void IO_OUTPUT_FLOAT(int8 pin); 
.................... void IO_OUTPUT_TOGGLE(int8 pin); 
.................... void IO_OUTPUT_DRIVE(int8 pin); 
.................... int1 IO_INPUT(int8 pin); 
.................... int1 IO_INPUT_STATE(int8 pin); 
.................... int8 IO_GET_TRIS_A(); 
.................... void IO_SET_TRIS_A(int8 data); 
.................... int8 IO_GET_TRIS_B(); 
.................... void IO_SET_TRIS_B(int8 data); 
.................... #else 
.................... void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data); 
.................... int8 IO_READ_REGISTER(int8 address, int8 reg); 
.................... void IO_OUTPUT_A(int8 address, int8 data); 
.................... void IO_OUTPUT_B(int8 address, int8 data); 
.................... int8 IO_INPUT_A(int8 address); 
.................... int8 IO_INPUT_B(int8 address); 
.................... void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state); 
.................... void IO_OUTPUT_HIGH(int8 address, int8 pin); 
.................... void IO_OUTPUT_LOW(int8 address, int8 pin); 
.................... void IO_OUTPUT_FLOAT(int8 address, int8 pin); 
.................... void IO_OUTPUT_TOGGLE(int8 address, int8 pin); 
.................... void IO_OUTPUT_DRIVE(int8 address, int8 pin); 
.................... int1 IO_INPUT(int8 address, int8 pin); 
.................... int1 IO_INPUT_STATE(int8 address, int8 pin); 
.................... int8 IO_GET_TRIS_A(int8 address); 
.................... void IO_SET_TRIS_A(int8 address, int8 data); 
.................... int8 IO_GET_TRIS_B(int8 address); 
.................... void IO_SET_TRIS_B(int8 address, int8 data); 
.................... #endif 
....................  
.................... /****************************************************************************** 
.................... **** FUNCTIONS 
.................... ******************************************************************************/ 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INIT 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Must be called before anything else. Enables the MCP23S17 chip to have  
.................... //// the following settings: 
.................... ////      IO_IOCON_BANK    = 1    Sets addresses to align with the #defines 
.................... ////      IO_IOCON_MIRROR  = 0      INT pins are not internally connected 
.................... ////      IO_IOCON_SEQOP     = 1      Operating in Byte mode    
.................... ////      IO_IOCON_DISSLW  = 0      SDA output slew rate is enabled                              
.................... ////      IO_IOCON_HAEN     = x      A2, A1, A0 enabled only if IO_MULTIPLE_DEVICES is defined    
.................... ////      IO_IOCON_ODR      = 0      Interrupt will drive its level    
.................... ////      IO_IOCON_INTPOL  = 1      Interrupt is active-high 
.................... //// 
.................... //// If different settings are required, use an IO_WRITE_REGISTER() with IOCON 
.................... //// as the reg parameter. Note: if IO_IOCON_BANK is cleared then the #defines 
.................... //// for the register values are no longer valid. 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... void IO_INIT(){ 
....................  
....................    output_high(IO_CS_PIN); 
*
0620:  BCF    F92.5
0622:  BSF    F89.5
....................    output_drive(IO_CS_PIN); 
0624:  BCF    F92.5
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(0x0A, 0xA2);   //IOCON's address is 0xA until IOCON.Bank is set                          
....................    #else 
....................    IO_WRITE_REGISTER(IO_DEVICE_0, 0x0A, 0xAA); 
0626:  MOVLB  1
0628:  CLRF   xF1
062A:  MOVLW  0A
062C:  MOVWF  xF2
062E:  MOVLW  AA
0630:  MOVWF  xF3
0632:  MOVLB  0
0634:  RCALL  05EE
....................    IO_WRITE_REGISTER(IO_DEVICE_1, 0x0A, 0xAA);  //Edit by Jack 
0636:  MOVLW  02
0638:  MOVLB  1
063A:  MOVWF  xF1
063C:  MOVLW  0A
063E:  MOVWF  xF2
0640:  MOVLW  AA
0642:  MOVWF  xF3
0644:  MOVLB  0
0646:  RCALL  05EE
....................    IO_WRITE_REGISTER(IO_DEVICE_2, 0x0A, 0xAA);  //Edit by Jack 
0648:  MOVLW  04
064A:  MOVLB  1
064C:  MOVWF  xF1
064E:  MOVLW  0A
0650:  MOVWF  xF2
0652:  MOVLW  AA
0654:  MOVWF  xF3
0656:  MOVLB  0
0658:  RCALL  05EE
....................    IO_WRITE_REGISTER(IO_DEVICE_3, 0x0A, 0xAA);  //Edit by Jack 
065A:  MOVLW  06
065C:  MOVLB  1
065E:  MOVWF  xF1
0660:  MOVLW  0A
0662:  MOVWF  xF2
0664:  MOVLW  AA
0666:  MOVWF  xF3
0668:  MOVLB  0
066A:  RCALL  05EE
....................    IO_WRITE_REGISTER(IO_DEVICE_4, 0x0A, 0xAA);  //Edit by Jack 
066C:  MOVLW  08
066E:  MOVLB  1
0670:  MOVWF  xF1
0672:  MOVLW  0A
0674:  MOVWF  xF2
0676:  MOVLW  AA
0678:  MOVWF  xF3
067A:  MOVLB  0
067C:  RCALL  05EE
....................    IO_WRITE_REGISTER(IO_DEVICE_5, 0x0A, 0xAA);  //Edit by Jack 
067E:  MOVLW  0A
0680:  MOVLB  1
0682:  MOVWF  xF1
0684:  MOVWF  xF2
0686:  MOVLW  AA
0688:  MOVWF  xF3
068A:  MOVLB  0
068C:  RCALL  05EE
....................    IO_WRITE_REGISTER(IO_DEVICE_6, 0x0A, 0xAA);  //Edit by Jack 
068E:  MOVLW  0C
0690:  MOVLB  1
0692:  MOVWF  xF1
0694:  MOVLW  0A
0696:  MOVWF  xF2
0698:  MOVLW  AA
069A:  MOVWF  xF3
069C:  MOVLB  0
069E:  RCALL  05EE
....................    IO_WRITE_REGISTER(IO_DEVICE_7, 0x0A, 0xAA);  //Edit by Jack 
06A0:  MOVLW  0E
06A2:  MOVLB  1
06A4:  MOVWF  xF1
06A6:  MOVLW  0A
06A8:  MOVWF  xF2
06AA:  MOVLW  AA
06AC:  MOVWF  xF3
06AE:  MOVLB  0
06B0:  RCALL  05EE
....................    #endif 
06B2:  GOTO   74E6 (RETURN)
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_WRITE_REGISTER 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the value of the specified register. 
.................... //// 
.................... //// Parameters: 
.................... ////      reg - the register to be written. use provided defines. 
.................... ////      data - the data to be written. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_WRITE_REGISTER(int8 reg, int8 data){ 
.................... #else 
.................... void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data){ 
.................... #endif 
....................     
....................    output_low(IO_CS_PIN); 
*
05EE:  BCF    F92.5
05F0:  BCF    F89.5
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    spi_write(IO_DEVICE_ADDRESS_WRITE); 
....................    #else 
....................    spi_write(IO_DEVICE_ADDRESS_WRITE | address); 
05F2:  MOVLB  1
05F4:  MOVF   xF1,W
05F6:  IORLW  40
05F8:  MOVWF  xF4
05FA:  MOVF   FC9,W
05FC:  MOVFF  1F4,FC9
0600:  RRCF   FC7,W
0602:  BNC   0600
....................    #endif 
....................     
....................    spi_write(reg); 
0604:  MOVF   FC9,W
0606:  MOVFF  1F2,FC9
060A:  RRCF   FC7,W
060C:  BNC   060A
....................    spi_write(data); 
060E:  MOVF   FC9,W
0610:  MOVFF  1F3,FC9
0614:  RRCF   FC7,W
0616:  BNC   0614
....................     
....................    output_high(IO_CS_PIN); 
0618:  BCF    F92.5
061A:  BSF    F89.5
061C:  MOVLB  0
061E:  RETURN 0
....................  
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_READ_REGISTER 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the current value of the specified register. 
.................... //// 
.................... //// Parameters: 
.................... ////      reg - the register to be read. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int8 - the current value of the requested register 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_READ_REGISTER(int8 reg){ 
.................... #else 
.................... int8 IO_READ_REGISTER(int8 address, int8 reg){ 
.................... #endif 
....................    int8 retVal; 
....................  
....................    output_low(IO_CS_PIN); 
*
19BC:  BCF    F92.5
19BE:  BCF    F89.5
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    spi_write(IO_DEVICE_ADDRESS_READ); 
....................    #else 
....................    spi_write(IO_DEVICE_ADDRESS_READ | address); 
19C0:  MOVLB  1
19C2:  MOVF   xEA,W
19C4:  IORLW  41
19C6:  MOVWF  xED
19C8:  MOVF   FC9,W
19CA:  MOVFF  1ED,FC9
19CE:  RRCF   FC7,W
19D0:  BNC   19CE
....................    #endif 
....................     
....................    spi_write(reg); 
19D2:  MOVF   FC9,W
19D4:  MOVFF  1EB,FC9
19D8:  RRCF   FC7,W
19DA:  BNC   19D8
....................    retVal = spi_read(0); 
19DC:  MOVF   FC9,W
19DE:  CLRF   FC9
19E0:  RRCF   FC7,W
19E2:  BNC   19E0
19E4:  MOVFF  FC9,1EC
....................     
....................    output_high(IO_CS_PIN); 
19E8:  BCF    F92.5
19EA:  BSF    F89.5
....................     
....................    return retVal; 
19EC:  MOVFF  1EC,01
19F0:  MOVLB  0
19F2:  RETURN 0
....................  
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_A 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the current output value of Port A. Does NOT change the PORT's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////      data - the value to be written to Port A 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_A(int8 data){ 
.................... #else 
.................... void IO_OUTPUT_A(int8 address, int8 data){ 
.................... #endif 
....................  
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(OLATA, data); 
....................    #else 
....................    IO_WRITE_REGISTER(address, OLATA, data); 
*
14C2:  MOVFF  1EF,1F1
14C6:  MOVLW  0A
14C8:  MOVLB  1
14CA:  MOVWF  xF2
14CC:  MOVFF  1F0,1F3
14D0:  MOVLB  0
14D2:  CALL   05EE
....................    #endif 
14D6:  RETURN 0
....................  
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_B 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the current output value of Port B. Does NOT change the PORT's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////      data - the value to be written to Port B 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_B(int8 data){ 
.................... #else 
.................... void IO_OUTPUT_B(int8 address, int8 data){ 
.................... #endif 
....................  
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(OLATB, data); 
....................    #else 
....................    IO_WRITE_REGISTER(address, OLATB, data); 
14D8:  MOVFF  1EF,1F1
14DC:  MOVLW  1A
14DE:  MOVLB  1
14E0:  MOVWF  xF2
14E2:  MOVFF  1F0,1F3
14E6:  MOVLB  0
14E8:  CALL   05EE
....................    #endif 
14EC:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INPUT_A 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the current input value of Port A. Does NOT change the PORT's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int8 - PORTA's input value 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_INPUT_A(){ 
.................... #else 
.................... int8 IO_INPUT_A(int8 address){ 
.................... #endif 
....................  
....................    int8 retVal; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    retVal = IO_READ_REGISTER(GPIOA); 
....................    #else 
....................    retVal = IO_READ_REGISTER(address, GPIOA); 
*
19F4:  MOVFF  1E8,1EA
19F8:  MOVLW  09
19FA:  MOVLB  1
19FC:  MOVWF  xEB
19FE:  MOVLB  0
1A00:  RCALL  19BC
1A02:  MOVFF  01,1E9
....................    #endif 
....................     
....................    return retVal; 
1A06:  MOVLB  1
1A08:  MOVFF  1E9,01
1A0C:  MOVLB  0
1A0E:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INPUT_B 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the current input value of Port B. Does NOT change the PORT's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int8 - PORTB's input value 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_INPUT_B(){ 
.................... #else 
.................... int8 IO_INPUT_B(int8 address){ 
.................... #endif 
....................  
....................    int8 retVal; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    retVal = IO_READ_REGISTER(GPIOB); 
....................    #else 
....................    retVal = IO_READ_REGISTER(address, GPIOB); 
1A10:  MOVFF  1E8,1EA
1A14:  MOVLW  19
1A16:  MOVLB  1
1A18:  MOVWF  xEB
1A1A:  MOVLB  0
1A1C:  RCALL  19BC
1A1E:  MOVFF  01,1E9
....................    #endif 
....................     
....................    return retVal; 
1A22:  MOVLB  1
1A24:  MOVFF  1E9,01
1A28:  MOVLB  0
1A2A:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_BIT 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to the desired state. Does NOT change the PIN's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be changed. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_BIT(int8 pin, int1 state){ 
.................... #else 
.................... void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state){ 
.................... #endif 
....................     
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATA); 
....................       #endif 
....................       if(state){    //set high                       
....................          bit_set(tempReg, pin &0x0F);      
....................       }else{        //set low                       
....................          bit_clear(tempReg, pin &0x0F); 
....................       } 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATA, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATA, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATB); 
....................       #endif 
....................       if(state){    //set high                       
....................          bit_set(tempReg, pin);       
....................       }else{        //set low                       
....................          bit_clear(tempReg, pin); 
....................       } 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATB, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATB, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_HIGH 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to output high. Does NOT change the PIN's direction 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be set. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_HIGH(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_HIGH(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATA); 
....................       #endif 
....................       bit_set(tempReg, pin &0x0F);  
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATA, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATA, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATB); 
....................       #endif 
....................       bit_set(tempReg, pin);  
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATB, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATB, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_LOW 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to output low. Does NOT change the PIN's direction 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be cleared. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_LOW(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_LOW(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATA); 
....................       #endif 
....................       bit_clear(tempReg, pin &0x0F); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATA, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATA, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATB); 
....................       #endif 
....................       bit_clear(tempReg, pin); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATB, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATB, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_FLOAT 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to an input. 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be changed. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_FLOAT(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_FLOAT(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_GET_TRIS_A(); 
....................       #else 
....................       tempReg = IO_GET_TRIS_A(address); 
....................       #endif 
....................       bit_set(tempReg, pin &0x0F);  
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_SET_TRIS_A(tempReg); 
....................       #else 
....................       IO_SET_TRIS_A(address, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_GET_TRIS_B(); 
....................       #else 
....................       tempReg = IO_GET_TRIS_B(address); 
....................       #endif 
....................       bit_set(tempReg, pin);       
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_SET_TRIS_B(tempReg); 
....................       #else 
....................       IO_SET_TRIS_B(address, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_TOGGLE 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Toggles the specified PIN's output. 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be toggled. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_TOGGLE(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_TOGGLE(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATA); 
....................       #endif 
....................       tempReg ^= (1<< (pin&0x0F)); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATA, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATA, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATB); 
....................       #endif 
....................       tempReg ^= (1<< (pin&0x0F)); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATB, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATB, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_DRIVE 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to an output. 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be changed. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_DRIVE(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_DRIVE(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_GET_TRIS_A(); 
....................       #else 
....................       tempReg = IO_GET_TRIS_A(address); 
....................       #endif 
....................       bit_clear(tempReg, pin &0x0F); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_SET_TRIS_A(tempReg); 
....................       #else 
....................       IO_SET_TRIS_A(address, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_GET_TRIS_B(); 
....................       #else 
....................       tempReg = IO_GET_TRIS_B(address); 
....................       #endif 
....................       bit_clear(tempReg, pin);       
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_SET_TRIS_B(tempReg); 
....................       #else 
....................       IO_SET_TRIS_B(address, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INPUT 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the specified PIN's current input. Changes the PIN's direction to an 
.................... //// input. 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be read. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int1 - the state of the pin 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int1 IO_INPUT(int8 pin){ 
.................... #else 
.................... int1 IO_INPUT(int8 address, int8 pin){ 
.................... #endif 
....................    int1 retVal; 
....................    int8 tempReg; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_OUTPUT_FLOAT(pin); 
....................    #else 
....................    IO_OUTPUT_FLOAT(address, pin); 
....................    #endif 
....................     
....................    if(bit_test(pin, 7)){ 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(GPIOA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, GPIOA); 
....................       #endif 
....................    }else{ 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(GPIOB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, GPIOB); 
....................       #endif 
....................    } 
....................    retVal = bit_test(tempReg, pin&0x0F); 
....................     
....................    return retVal; 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INPUT_STATE 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the specified PIN's current input. Does NOT change the PIN's direction 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be read. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int1 - the state of the pin 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int1 IO_INPUT_STATE(int8 pin){ 
.................... #else 
.................... int1 IO_INPUT_STATE(int8 address, int8 pin){ 
.................... #endif 
....................    int1 retVal; 
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(GPIOA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, GPIOA); 
....................       #endif 
....................    }else{ 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(GPIOB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, GPIOB); 
....................       #endif 
....................    } 
....................    retVal = bit_test(tempReg, pin&0x0F); 
....................     
....................    return retVal; 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_GET_TRIS_A 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the device's port A data direction register. 
.................... //// 
.................... //// Parameters: 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      The device's IODIRB register value 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_GET_TRIS_A(){ 
.................... #else 
.................... int8 IO_GET_TRIS_A(int8 address){ 
.................... #endif 
....................  
....................    int8 retVal; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    retVal = IO_READ_REGISTER(IODIRA); 
....................    #else 
....................    retVal = IO_READ_REGISTER(address, IODIRA); 
....................    #endif 
....................     
....................    return retVal; 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_SET_TRIS_A 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the device's port A data direction register to the specified value. 
.................... //// 
.................... //// Parameters: 
.................... ////      data - value to be written to the register 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_SET_TRIS_A(int8 data){ 
.................... #else 
.................... void IO_SET_TRIS_A(int8 address, int8 data){ 
.................... #endif 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(IODIRA, data); 
....................    #else 
....................    IO_WRITE_REGISTER(address, IODIRA, data); 
*
06B6:  MOVFF  1E7,1F1
06BA:  MOVLB  1
06BC:  CLRF   xF2
06BE:  MOVFF  1E8,1F3
06C2:  MOVLB  0
06C4:  RCALL  05EE
....................    #endif 
06C6:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_GET_TRIS_B 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the device's port B data direction register. 
.................... //// 
.................... //// Parameters: 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      The device's IODIRB register value 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_GET_TRIS_B(){ 
.................... #else 
.................... int8 IO_GET_TRIS_B(int8 address){ 
.................... #endif 
....................  
....................    int8 retVal; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    retVal = IO_READ_REGISTER(IODIRB); 
....................    #else 
....................    retVal = IO_READ_REGISTER(address, IODIRB); 
....................    #endif 
....................     
....................    return retVal; 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_SET_TRIS_B 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the device's port B data direction register to the specified value. 
.................... //// 
.................... //// Parameters: 
.................... ////      data - value to be written to the register 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_SET_TRIS_B(int8 data){ 
.................... #else 
.................... void IO_SET_TRIS_B(int8 address, int8 data){ 
.................... #endif 
....................  
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(IODIRB, data); 
....................    #else 
....................    IO_WRITE_REGISTER(address, IODIRB, data); 
06C8:  MOVFF  1E7,1F1
06CC:  MOVLW  10
06CE:  MOVLB  1
06D0:  MOVWF  xF2
06D2:  MOVFF  1E8,1F3
06D6:  MOVLB  0
06D8:  RCALL  05EE
....................    #endif 
06DA:  RETURN 0
....................  
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define OnRelay   1 
.................... #define OffRelay   0 
....................  
.................... #define Pled        PIN_B5 
.................... #define I2C_SDA     PIN_C4 
.................... #define I2C_SCL     PIN_C3 
....................  
.................... #define Pack        PIN_C0 
.................... #define Preset      PIN_C1 
.................... #define Ptest       PIN_C2 
....................  
.................... #define Pbell       PIN_A3 
.................... #define Pbuzzer     PIN_A4 
....................  
.................... #define P485ctrl    PIN_B3       // ---jj 
.................... #define PTxD        PIN_C6 
.................... #define PRxD        PIN_C7 
....................  
.................... //#define PsyncR      PIN_B3 
.................... //#define PsyncS      PIN_B4 
....................  
.................... #define EXP_OUT_ENABLE  PIN_B0 
.................... #define EXP_OUT_CLOCK   PIN_B1 
.................... #define EXP_OUT_DO      PIN_B2 
....................  
.................... #define Red       0 
.................... #define Green     1 
.................... #define Ambian    2 
....................  
.................... //#define NUMBER_OF_595 8 
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PTxD,rcv=PRxD,bits=8,restart_wdt) 
*
15B6:  CLRWDT
15B8:  BTFSS  F9E.4
15BA:  BRA    15B6
15BC:  MOVWF  FAD
15BE:  RETURN 0
....................  
.................... //#USE SPI (  FORCE_HW, BITS=16, ENABLE=IO_CS_PIN, SAMPLE_RISE, stream=SPI_STREAM)  
.................... //#USE SPI (  FORCE_HW, BITS=16, ENABLE=IO_CS_PIN, SAMPLE_RISE, stream=SPI_STREAM2) 
....................  
.................... //#use spi(MASTER, MODE=0, SPI1, FORCE_HW) 
.................... //#use spi(MASTER, MSB_FIRST, BITS=8, MODE=0, BAUD=100000) 
.................... //#use spi(DI=PIN_B1, DO=PIN_B0, CLK=PIN_B2, ENABLE=PIN_B4, BITS=8) 
....................  
.................... void check_ack(void); 
.................... void check_test(void); 
.................... void check_reset(void); 
.................... int1 CheckAutoReset(unsigned char DatType); 
.................... void Read_Config(void); 
.................... void ForceAllAlarm(void); 
.................... void Read_input(void); 
....................  
.................... void initialIC(void); 
....................  
.................... int8 StatusTime = 0;         //Hearth beat LED Timer 
.................... int1 HearthbeatInd = 0;      //Hearth beat Indicator 
.................... int8 FlashingRateTime = 25; 
.................... int1 FlashingFlag = 0; 
.................... int8 TimeBase1s = 100; 
.................... int8 AutoAckDelayTime = 0; 
....................  
.................... int8 Input1_8_Send; 
.................... int8 Input9_16_Send; 
.................... int8 Input17_24_Send; 
.................... int8 Input25_32_Send; 
.................... int8 Input33_40_Send; 
.................... int8 Input41_48_Send; 
.................... int8 Input49_56_Send; 
.................... int8 Input57_64_Send; 
....................  
.................... int8 Ack1_8_Send; 
.................... int8 Ack9_16_Send; 
.................... int8 Ack17_24_Send; 
.................... int8 Ack25_32_Send; 
.................... int8 Ack33_40_Send; 
.................... int8 Ack41_48_Send; 
.................... int8 Ack49_56_Send; 
.................... int8 Ack57_64_Send; 
....................  
.................... int1 AutoAckFlag = 0; 
.................... int1 AutoResetFlag = 0; 
.................... int1 AutoTestFlag = 0; 
....................  
.................... int8 SBUF = 0x00; 
....................  
.................... int1 Test_fault = 0; 
.................... int8 T_test = 0x00; 
....................  
.................... int1 Test = 0; 
.................... int1 Ack_F = 0; 
.................... int1 Reset_F = 0; 
....................  
.................... int1 SyncStatus = 0;   //"0" -> No Sync signal 
.................... int1 SyncFlag = 0;     //use for debounce sync signal 
.................... int8 Synctimer = 0x00; //use for debounce sync signal 
....................  
.................... int8 Output1_8; 
.................... int8 Output9_16; 
....................  
.................... int8 Output595[4]; 
....................  
.................... int8 tempdata; 
.................... //int8 EEP_Config = 0x00;   // 
.................... //int8 NUMBER_OF_595 ; 
....................  
.................... int8 EEpDat; 
....................  
.................... volatile int1 RefreshConfigData =0; 
....................  
.................... ///////// Data from EEProm /////// 
.................... //int Device_Addr; 
....................  
.................... int8 InputType1_8; 
.................... int8 InputType9_16; 
.................... int8 InputType17_24; 
....................  
.................... int8 FaultType1_8; 
.................... int8 FaultType9_16; 
.................... int8 FaultType17_24; 
....................  
....................  
.................... int8 OutputType1_8; 
.................... int8 OutputType9_16; 
.................... int8 OutputType17_24; 
....................  
.................... int8 OutputBoth1_8; 
.................... int8 OutputBoth9_16; 
.................... int8 OutputBoth17_24; 
....................  
.................... int8 Alarm_Indicator1_8; 
.................... int8 Alarm_Indicator9_16; 
.................... int8 Alarm_Indicator17_24; 
....................  
.................... int8 Input1_8; 
.................... int8 Input9_10; 
.................... int8 Input11_18; 
.................... int8 Input19_20; 
....................  
.................... int8 Input9_16; 
.................... int8 Input17_24; 
.................... int8 Input25_32; 
....................  
.................... int8 Red1_8; 
.................... int8 Red9_10 ; 
.................... int8 Red11_18 ; 
.................... int8 Red19_20 ; 
.................... int8 Green1_8 ; 
.................... int8 Green9_10 ; 
.................... int8 Green11_18 ; 
.................... int8 Green19_20 ; 
....................  
.................... int8 OUTRed1_8; 
.................... int8 OUTRed9_10 ; 
.................... int8 OUTRed11_18 ; 
.................... int8 OUTRed19_20 ; 
.................... int8 OUTGreen1_8 ; 
.................... int8 OUTGreen9_10 ; 
.................... int8 OUTGreen11_18 ; 
.................... int8 OUTGreen19_20 ; 
....................  
.................... int8 AutoAck; 
.................... int8 AutoAckTime; 
.................... int8 FlashingRate; 
.................... int8 NoOfPoint; 
.................... int8 MasterSlaveSync; 
....................  
.................... int1 StartRead = 0; 
.................... volatile int8 StartReadCount; 
....................  
.................... //////////////////////////////// 
.................... ///////// tempolary register ////////// 
.................... //int8 temp; 
.................... //int1 RxDreceive = 0; 
....................  
.................... ////////////////////////////////////// 
.................... unsigned char const addr_sq = 0x10,end_sq = 0x11,code_sq = 0x12,start_addr_hi_sq = 0x13,start_addr_lo_sq = 0x14;         //serial sequnce 
.................... unsigned char const ubyte_hi_sq = 0x15,ubyte_lo_sq = 0x16,crc_hi_sq = 0x17,byte_count_sq = 0x19,data_sq = 0x20;      //serial sequnce 
....................  
....................  
.................... int1 recieve_completed = 0; 
.................... unsigned char sequence;         //keep sequence use for RxD 
.................... unsigned char Address; 
.................... unsigned char RxD_DataLen = 0x00; 
.................... unsigned char TxD_Buff[60]; 
.................... unsigned char RxD_Buff[60]; 
.................... unsigned char CRC_Lo; 
.................... unsigned char CRC_Hi; 
.................... int16 Send_check_Time = 500; //if no send reset buffer every 5 second 
....................  
.................... int16 Start_Address = 0x0000; 
.................... int16 No_PointCount = 0x0000; 
.................... unsigned char Data_ByteCount = 0x00; 
.................... unsigned char Data_Buff[30]; 
.................... //unsigned char DataTemp; 
.................... //unsigned char TxD_DataLen; 
....................  
.................... int8 MCP23s17_Ip_dat; 
....................  
....................  
.................... int8 MCP23s17_Op_dat; 
....................  
.................... unsigned char T_timeout;    //use for calculate RxD timeout 
.................... unsigned char index = 0x00; //use for Loop 
....................  
.................... int8 outmcp23 = 0; 
....................  
.................... unsigned char const CRC_Table_Hi[] = { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,  
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,  
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... };  
....................  
.................... unsigned  char const CRC_Table_Lo[] = { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,  
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,  
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,  
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... } ; 
....................  
.................... ///////////// Define Bit register //////////////////////////// 
....................  
.................... struct Bit64    // Inputt 
.................... { 
....................    int1 B1,B2,B3,B4,B5,B6,B7,B8,B9,B10; 
....................    int1 B11,B12,B13,B14,B15,B16,B17,B18,B19,B20; 
....................    int1 B21,B22,B23,B24,B25,B26,B27,B28,B29,B30; 
....................    //int1 B31,B32,B33,B34,B35,B36,B37,B38,B39,B40; 
....................    //int1 B41,B42,B43,B44,B45,B46,B47,B48,B49,B50; 
....................    //int1 B51,B52,B53,B54,B55,B56,B57,B58,B59,B60; 
....................    //int1 B61,B62,B63,B64; 
.................... }; 
....................  
....................    //Output   (LED Lit = "0") 
....................    //Inputt Type NO/NC (NO = "1" , NC = "0") 
....................    //Fault Type Manual/Auto (Manual = "1" , Auto = "0") 
....................    //Output Type Buz/Bell (Buzzer = "1" , Bell = "0") 
....................    //Output Both (Normal = "1" , Both = "0") 
....................    //Acknowledge flag (Acked = "1" , non Ack = "0") 
....................  
.................... struct Bit64 Inputt;//,Output,InputType;//,FaultType,OutputType,OutputBoth; 
.................... struct Bit64 Output,InputType; 
.................... struct Bit64 FaultType,OutputType,OutputBoth; 
.................... struct Bit64 AlarmIndicator,Ack,In,In2; 
.................... struct Bit64 LED_Colour,AckSend,RED_Colour,GREEN_Colour; 
....................  
.................... int1 FaultAgo[30]; 
.................... int1 FaultNow[30]; 
.................... int16 ReleaseTime[30]; 
.................... int16 FaultDelayTime[30]; 
....................  
.................... int1 FaultNCNO[21]; 
.................... #define NO 1 
.................... #define NC 0 
....................  
.................... //volatile int16 ReadIn_Count =0; 
.................... //int1 ReadIn_flag = 0; 
....................  
.................... int8 DelayTime1 = 0; 
.................... int8 DelayTime2 = 0; 
.................... int8 DelayTime3 = 0; 
.................... int8 DelayTime4 = 0; 
.................... int8 DelayTime5 = 0; 
.................... int8 DelayTime6 = 0; 
.................... int8 DelayTime7 = 0; 
.................... int8 DelayTime8 = 0; 
.................... int8 DelayTime9 = 0; 
.................... int8 DelayTime10 = 0; 
.................... int8 DelayTime11 = 0; 
.................... int8 DelayTime12 = 0; 
.................... int8 DelayTime13 = 0; 
.................... int8 DelayTime14 = 0; 
.................... int8 DelayTime15 = 0; 
.................... int8 DelayTime16 = 0; 
.................... int8 DelayTime17 = 0; 
.................... int8 DelayTime18 = 0; 
.................... int8 DelayTime19 = 0; 
.................... int8 DelayTime20 = 0; 
....................  
....................  
.................... //////////////////////////////--Function--///////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ///////////////////////////////MODBUS Routine////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void Alarmtosend(void) 
.................... { 
....................    Input1_8_Send = 0x00; 
15C0:  CLRF   1E
....................    Input9_16_Send = 0x00; 
15C2:  CLRF   1F
....................    Input17_24_Send = 0x00; 
15C4:  CLRF   20
....................     
....................     
....................    Ack1_8_Send = 0x00; 
15C6:  CLRF   26
....................    Ack9_16_Send = 0x00; 
15C8:  CLRF   27
....................    Ack17_24_Send = 0x00; 
15CA:  CLRF   28
....................  
....................     
....................    ///////////////////////////////////////////////////// 
....................    
....................    if((In.B1 == 0) && (Output.B1 ==0)) 
15CC:  MOVLB  1
15CE:  BTFSC  x35.0
15D0:  BRA    15DA
15D2:  BTFSC  x19.0
15D4:  BRA    15DA
....................       AckSend.B1 = 1; 
15D6:  BSF    x41.0
15D8:  BRA    15DC
....................    else 
....................       AckSend.B1 = 0; 
15DA:  BCF    x41.0
....................        
....................    if((In.B2 == 0) && (Output.B2 ==0)) 
15DC:  BTFSC  x35.1
15DE:  BRA    15E8
15E0:  BTFSC  x19.1
15E2:  BRA    15E8
....................       AckSend.B2 = 1; 
15E4:  BSF    x41.1
15E6:  BRA    15EA
....................    else 
....................       AckSend.B2 = 0; 
15E8:  BCF    x41.1
....................        
....................    if((In.B3 == 0) && (Output.B3 ==0)) 
15EA:  BTFSC  x35.2
15EC:  BRA    15F6
15EE:  BTFSC  x19.2
15F0:  BRA    15F6
....................       AckSend.B3 = 1; 
15F2:  BSF    x41.2
15F4:  BRA    15F8
....................    else 
....................       AckSend.B3 = 0; 
15F6:  BCF    x41.2
....................        
....................    if((In.B4 == 0) && (Output.B4 ==0)) 
15F8:  BTFSC  x35.3
15FA:  BRA    1604
15FC:  BTFSC  x19.3
15FE:  BRA    1604
....................       AckSend.B4 = 1; 
1600:  BSF    x41.3
1602:  BRA    1606
....................    else 
....................       AckSend.B4 = 0; 
1604:  BCF    x41.3
....................        
....................    if((In.B5 == 0) && (Output.B5 ==0)) 
1606:  BTFSC  x35.4
1608:  BRA    1612
160A:  BTFSC  x19.4
160C:  BRA    1612
....................       AckSend.B5 = 1; 
160E:  BSF    x41.4
1610:  BRA    1614
....................    else 
....................       AckSend.B5 = 0; 
1612:  BCF    x41.4
....................        
....................    if((In.B6 == 0) && (Output.B6 ==0)) 
1614:  BTFSC  x35.5
1616:  BRA    1620
1618:  BTFSC  x19.5
161A:  BRA    1620
....................       AckSend.B6 = 1; 
161C:  BSF    x41.5
161E:  BRA    1622
....................    else 
....................       AckSend.B6 = 0; 
1620:  BCF    x41.5
....................        
....................    if((In.B7 == 0) && (Output.B7 ==0)) 
1622:  BTFSC  x35.6
1624:  BRA    162E
1626:  BTFSC  x19.6
1628:  BRA    162E
....................       AckSend.B7 = 1; 
162A:  BSF    x41.6
162C:  BRA    1630
....................    else 
....................       AckSend.B7 = 0; 
162E:  BCF    x41.6
....................        
....................    if((In.B8 == 0) && (Output.B8 ==0)) 
1630:  BTFSC  x35.7
1632:  BRA    163C
1634:  BTFSC  x19.7
1636:  BRA    163C
....................       AckSend.B8 = 1; 
1638:  BSF    x41.7
163A:  BRA    163E
....................    else 
....................       AckSend.B8 = 0; 
163C:  BCF    x41.7
....................        
....................    if((In.B9 == 0) && (Output.B9 ==0)) 
163E:  BTFSC  x36.0
1640:  BRA    164A
1642:  BTFSC  x1A.0
1644:  BRA    164A
....................       AckSend.B9 = 1; 
1646:  BSF    x42.0
1648:  BRA    164C
....................    else 
....................       AckSend.B9 = 0; 
164A:  BCF    x42.0
....................        
....................    if((In.B10 == 0) && (Output.B10 ==0)) 
164C:  BTFSC  x36.1
164E:  BRA    1658
1650:  BTFSC  x1A.1
1652:  BRA    1658
....................       AckSend.B10 = 1; 
1654:  BSF    x42.1
1656:  BRA    165A
....................    else 
....................       AckSend.B10 = 0; 
1658:  BCF    x42.1
....................        
....................    if((In.B11 == 0) && (Output.B11 ==0)) 
165A:  BTFSC  x36.2
165C:  BRA    1666
165E:  BTFSC  x1A.2
1660:  BRA    1666
....................       AckSend.B11 = 1; 
1662:  BSF    x42.2
1664:  BRA    1668
....................    else 
....................       AckSend.B11 = 0; 
1666:  BCF    x42.2
....................        
....................    if((In.B12 == 0) && (Output.B12 ==0)) 
1668:  BTFSC  x36.3
166A:  BRA    1674
166C:  BTFSC  x1A.3
166E:  BRA    1674
....................       AckSend.B12 = 1; 
1670:  BSF    x42.3
1672:  BRA    1676
....................    else 
....................       AckSend.B12 = 0; 
1674:  BCF    x42.3
....................        
....................    if((In.B13 == 0) && (Output.B13 ==0)) 
1676:  BTFSC  x36.4
1678:  BRA    1682
167A:  BTFSC  x1A.4
167C:  BRA    1682
....................       AckSend.B13 = 1; 
167E:  BSF    x42.4
1680:  BRA    1684
....................    else 
....................       AckSend.B13 = 0; 
1682:  BCF    x42.4
....................        
....................    if((In.B14 == 0) && (Output.B14 ==0)) 
1684:  BTFSC  x36.5
1686:  BRA    1690
1688:  BTFSC  x1A.5
168A:  BRA    1690
....................       AckSend.B14 = 1; 
168C:  BSF    x42.5
168E:  BRA    1692
....................    else 
....................       AckSend.B14 = 0; 
1690:  BCF    x42.5
....................        
....................    if((In.B15 == 0) && (Output.B15 ==0)) 
1692:  BTFSC  x36.6
1694:  BRA    169E
1696:  BTFSC  x1A.6
1698:  BRA    169E
....................       AckSend.B15 = 1; 
169A:  BSF    x42.6
169C:  BRA    16A0
....................    else 
....................       AckSend.B15 = 0; 
169E:  BCF    x42.6
....................        
....................    if((In.B16 == 0) && (Output.B16 ==0)) 
16A0:  BTFSC  x36.7
16A2:  BRA    16AC
16A4:  BTFSC  x1A.7
16A6:  BRA    16AC
....................       AckSend.B16 = 1; 
16A8:  BSF    x42.7
16AA:  BRA    16AE
....................    else 
....................       AckSend.B16 = 0; 
16AC:  BCF    x42.7
....................        
....................    if((In.B17 == 0) && (Output.B17 ==0)) 
16AE:  BTFSC  x37.0
16B0:  BRA    16BA
16B2:  BTFSC  x1B.0
16B4:  BRA    16BA
....................       AckSend.B17 = 1; 
16B6:  BSF    x43.0
16B8:  BRA    16BC
....................    else 
....................       AckSend.B17 = 0; 
16BA:  BCF    x43.0
....................        
....................    if((In.B18 == 0) && (Output.B18 ==0)) 
16BC:  BTFSC  x37.1
16BE:  BRA    16C8
16C0:  BTFSC  x1B.1
16C2:  BRA    16C8
....................       AckSend.B18 = 1; 
16C4:  BSF    x43.1
16C6:  BRA    16CA
....................    else 
....................       AckSend.B18 = 0; 
16C8:  BCF    x43.1
....................        
....................    if((In.B19 == 0) && (Output.B19 ==0)) 
16CA:  BTFSC  x37.2
16CC:  BRA    16D6
16CE:  BTFSC  x1B.2
16D0:  BRA    16D6
....................       AckSend.B19 = 1; 
16D2:  BSF    x43.2
16D4:  BRA    16D8
....................    else 
....................       AckSend.B19 = 0; 
16D6:  BCF    x43.2
....................        
....................    if((In.B20 == 0) && (Output.B20 ==0)) 
16D8:  BTFSC  x37.3
16DA:  BRA    16E4
16DC:  BTFSC  x1B.3
16DE:  BRA    16E4
....................       AckSend.B20 = 1; 
16E0:  BSF    x43.3
16E2:  BRA    16E6
....................    else 
....................       AckSend.B20 = 0; 
16E4:  BCF    x43.3
....................     
....................     
....................     
....................    ///////////////////Ack///////////////////////////////// 
....................    Ack1_8_Send = Ack1_8_Send | AckSend.B8; 
16E6:  MOVLW  00
16E8:  BTFSC  x41.7
16EA:  MOVLW  01
16EC:  IORWF  26,F
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B7; 
16EE:  BCF    FD8.0
16F0:  RLCF   26,W
16F2:  MOVWF  xE8
16F4:  MOVLW  00
16F6:  BTFSC  x41.6
16F8:  MOVLW  01
16FA:  IORWF  xE8,W
16FC:  MOVWF  26
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B6; 
16FE:  BCF    FD8.0
1700:  RLCF   26,W
1702:  MOVWF  xE8
1704:  MOVLW  00
1706:  BTFSC  x41.5
1708:  MOVLW  01
170A:  IORWF  xE8,W
170C:  MOVWF  26
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B5; 
170E:  BCF    FD8.0
1710:  RLCF   26,W
1712:  MOVWF  xE8
1714:  MOVLW  00
1716:  BTFSC  x41.4
1718:  MOVLW  01
171A:  IORWF  xE8,W
171C:  MOVWF  26
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B4; 
171E:  BCF    FD8.0
1720:  RLCF   26,W
1722:  MOVWF  xE8
1724:  MOVLW  00
1726:  BTFSC  x41.3
1728:  MOVLW  01
172A:  IORWF  xE8,W
172C:  MOVWF  26
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B3; 
172E:  BCF    FD8.0
1730:  RLCF   26,W
1732:  MOVWF  xE8
1734:  MOVLW  00
1736:  BTFSC  x41.2
1738:  MOVLW  01
173A:  IORWF  xE8,W
173C:  MOVWF  26
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B2; 
173E:  BCF    FD8.0
1740:  RLCF   26,W
1742:  MOVWF  xE8
1744:  MOVLW  00
1746:  BTFSC  x41.1
1748:  MOVLW  01
174A:  IORWF  xE8,W
174C:  MOVWF  26
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B1; 
174E:  BCF    FD8.0
1750:  RLCF   26,W
1752:  MOVWF  xE8
1754:  MOVLW  00
1756:  BTFSC  x41.0
1758:  MOVLW  01
175A:  IORWF  xE8,W
175C:  MOVWF  26
....................     
....................    Ack9_16_Send = Ack9_16_Send | AckSend.B16; 
175E:  MOVLW  00
1760:  BTFSC  x42.7
1762:  MOVLW  01
1764:  IORWF  27,F
....................    Ack9_16_Send = (Ack9_16_Send << 1) | AckSend.B15; 
1766:  BCF    FD8.0
1768:  RLCF   27,W
176A:  MOVWF  xE8
176C:  MOVLW  00
176E:  BTFSC  x42.6
1770:  MOVLW  01
1772:  IORWF  xE8,W
1774:  MOVWF  27
....................    Ack9_16_Send = (Ack9_16_Send << 1) | AckSend.B14; 
1776:  BCF    FD8.0
1778:  RLCF   27,W
177A:  MOVWF  xE8
177C:  MOVLW  00
177E:  BTFSC  x42.5
1780:  MOVLW  01
1782:  IORWF  xE8,W
1784:  MOVWF  27
....................    Ack9_16_Send = (Ack9_16_Send << 1) | AckSend.B13; 
1786:  BCF    FD8.0
1788:  RLCF   27,W
178A:  MOVWF  xE8
178C:  MOVLW  00
178E:  BTFSC  x42.4
1790:  MOVLW  01
1792:  IORWF  xE8,W
1794:  MOVWF  27
....................    Ack9_16_Send = (Ack9_16_Send << 1) | AckSend.B12; 
1796:  BCF    FD8.0
1798:  RLCF   27,W
179A:  MOVWF  xE8
179C:  MOVLW  00
179E:  BTFSC  x42.3
17A0:  MOVLW  01
17A2:  IORWF  xE8,W
17A4:  MOVWF  27
....................    Ack9_16_Send = (Ack9_16_Send << 1) | AckSend.B11; 
17A6:  BCF    FD8.0
17A8:  RLCF   27,W
17AA:  MOVWF  xE8
17AC:  MOVLW  00
17AE:  BTFSC  x42.2
17B0:  MOVLW  01
17B2:  IORWF  xE8,W
17B4:  MOVWF  27
....................    Ack9_16_Send = (Ack9_16_Send << 1) | AckSend.B10; 
17B6:  BCF    FD8.0
17B8:  RLCF   27,W
17BA:  MOVWF  xE8
17BC:  MOVLW  00
17BE:  BTFSC  x42.1
17C0:  MOVLW  01
17C2:  IORWF  xE8,W
17C4:  MOVWF  27
....................    Ack9_16_Send = (Ack9_16_Send << 1) | AckSend.B9; 
17C6:  BCF    FD8.0
17C8:  RLCF   27,W
17CA:  MOVWF  xE8
17CC:  MOVLW  00
17CE:  BTFSC  x42.0
17D0:  MOVLW  01
17D2:  IORWF  xE8,W
17D4:  MOVWF  27
....................     
....................    Ack17_24_Send = Ack17_24_Send | AckSend.B24; 
17D6:  MOVLW  00
17D8:  BTFSC  x43.7
17DA:  MOVLW  01
17DC:  IORWF  28,F
....................    Ack17_24_Send = (Ack17_24_Send << 1) | AckSend.B23; 
17DE:  BCF    FD8.0
17E0:  RLCF   28,W
17E2:  MOVWF  xE8
17E4:  MOVLW  00
17E6:  BTFSC  x43.6
17E8:  MOVLW  01
17EA:  IORWF  xE8,W
17EC:  MOVWF  28
....................    Ack17_24_Send = (Ack17_24_Send << 1) | AckSend.B22; 
17EE:  BCF    FD8.0
17F0:  RLCF   28,W
17F2:  MOVWF  xE8
17F4:  MOVLW  00
17F6:  BTFSC  x43.5
17F8:  MOVLW  01
17FA:  IORWF  xE8,W
17FC:  MOVWF  28
....................    Ack17_24_Send = (Ack17_24_Send << 1) | AckSend.B21; 
17FE:  BCF    FD8.0
1800:  RLCF   28,W
1802:  MOVWF  xE8
1804:  MOVLW  00
1806:  BTFSC  x43.4
1808:  MOVLW  01
180A:  IORWF  xE8,W
180C:  MOVWF  28
....................    Ack17_24_Send = (Ack17_24_Send << 1) | AckSend.B20; 
180E:  BCF    FD8.0
1810:  RLCF   28,W
1812:  MOVWF  xE8
1814:  MOVLW  00
1816:  BTFSC  x43.3
1818:  MOVLW  01
181A:  IORWF  xE8,W
181C:  MOVWF  28
....................    Ack17_24_Send = (Ack17_24_Send << 1) | AckSend.B19; 
181E:  BCF    FD8.0
1820:  RLCF   28,W
1822:  MOVWF  xE8
1824:  MOVLW  00
1826:  BTFSC  x43.2
1828:  MOVLW  01
182A:  IORWF  xE8,W
182C:  MOVWF  28
....................    Ack17_24_Send = (Ack17_24_Send << 1) | AckSend.B18; 
182E:  BCF    FD8.0
1830:  RLCF   28,W
1832:  MOVWF  xE8
1834:  MOVLW  00
1836:  BTFSC  x43.1
1838:  MOVLW  01
183A:  IORWF  xE8,W
183C:  MOVWF  28
....................    Ack17_24_Send = (Ack17_24_Send << 1) | AckSend.B17; 
183E:  BCF    FD8.0
1840:  RLCF   28,W
1842:  MOVWF  xE8
1844:  MOVLW  00
1846:  BTFSC  x43.0
1848:  MOVLW  01
184A:  IORWF  xE8,W
184C:  MOVWF  28
....................     
....................    ///////////////////Fault///////////////////////////////// 
....................    Input1_8_Send = Input1_8_Send | In.B8; 
184E:  MOVLW  00
1850:  BTFSC  x35.7
1852:  MOVLW  01
1854:  IORWF  1E,F
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B7; 
1856:  BCF    FD8.0
1858:  RLCF   1E,W
185A:  MOVWF  xE8
185C:  MOVLW  00
185E:  BTFSC  x35.6
1860:  MOVLW  01
1862:  IORWF  xE8,W
1864:  MOVWF  1E
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B6; 
1866:  BCF    FD8.0
1868:  RLCF   1E,W
186A:  MOVWF  xE8
186C:  MOVLW  00
186E:  BTFSC  x35.5
1870:  MOVLW  01
1872:  IORWF  xE8,W
1874:  MOVWF  1E
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B5; 
1876:  BCF    FD8.0
1878:  RLCF   1E,W
187A:  MOVWF  xE8
187C:  MOVLW  00
187E:  BTFSC  x35.4
1880:  MOVLW  01
1882:  IORWF  xE8,W
1884:  MOVWF  1E
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B4; 
1886:  BCF    FD8.0
1888:  RLCF   1E,W
188A:  MOVWF  xE8
188C:  MOVLW  00
188E:  BTFSC  x35.3
1890:  MOVLW  01
1892:  IORWF  xE8,W
1894:  MOVWF  1E
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B3; 
1896:  BCF    FD8.0
1898:  RLCF   1E,W
189A:  MOVWF  xE8
189C:  MOVLW  00
189E:  BTFSC  x35.2
18A0:  MOVLW  01
18A2:  IORWF  xE8,W
18A4:  MOVWF  1E
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B2; 
18A6:  BCF    FD8.0
18A8:  RLCF   1E,W
18AA:  MOVWF  xE8
18AC:  MOVLW  00
18AE:  BTFSC  x35.1
18B0:  MOVLW  01
18B2:  IORWF  xE8,W
18B4:  MOVWF  1E
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B1; 
18B6:  BCF    FD8.0
18B8:  RLCF   1E,W
18BA:  MOVWF  xE8
18BC:  MOVLW  00
18BE:  BTFSC  x35.0
18C0:  MOVLW  01
18C2:  IORWF  xE8,W
18C4:  MOVWF  1E
....................     
....................    Input9_16_Send = Input9_16_Send | In.B16; 
18C6:  MOVLW  00
18C8:  BTFSC  x36.7
18CA:  MOVLW  01
18CC:  IORWF  1F,F
....................    Input9_16_Send = (Input9_16_Send << 1) | In.B15; 
18CE:  BCF    FD8.0
18D0:  RLCF   1F,W
18D2:  MOVWF  xE8
18D4:  MOVLW  00
18D6:  BTFSC  x36.6
18D8:  MOVLW  01
18DA:  IORWF  xE8,W
18DC:  MOVWF  1F
....................    Input9_16_Send = (Input9_16_Send << 1) | In.B14; 
18DE:  BCF    FD8.0
18E0:  RLCF   1F,W
18E2:  MOVWF  xE8
18E4:  MOVLW  00
18E6:  BTFSC  x36.5
18E8:  MOVLW  01
18EA:  IORWF  xE8,W
18EC:  MOVWF  1F
....................    Input9_16_Send = (Input9_16_Send << 1) | In.B13; 
18EE:  BCF    FD8.0
18F0:  RLCF   1F,W
18F2:  MOVWF  xE8
18F4:  MOVLW  00
18F6:  BTFSC  x36.4
18F8:  MOVLW  01
18FA:  IORWF  xE8,W
18FC:  MOVWF  1F
....................    Input9_16_Send = (Input9_16_Send << 1) | In.B12; 
18FE:  BCF    FD8.0
1900:  RLCF   1F,W
1902:  MOVWF  xE8
1904:  MOVLW  00
1906:  BTFSC  x36.3
1908:  MOVLW  01
190A:  IORWF  xE8,W
190C:  MOVWF  1F
....................    Input9_16_Send = (Input9_16_Send << 1) | In.B11; 
190E:  BCF    FD8.0
1910:  RLCF   1F,W
1912:  MOVWF  xE8
1914:  MOVLW  00
1916:  BTFSC  x36.2
1918:  MOVLW  01
191A:  IORWF  xE8,W
191C:  MOVWF  1F
....................    Input9_16_Send = (Input9_16_Send << 1) | In.B10; 
191E:  BCF    FD8.0
1920:  RLCF   1F,W
1922:  MOVWF  xE8
1924:  MOVLW  00
1926:  BTFSC  x36.1
1928:  MOVLW  01
192A:  IORWF  xE8,W
192C:  MOVWF  1F
....................    Input9_16_Send = (Input9_16_Send << 1) | In.B9; 
192E:  BCF    FD8.0
1930:  RLCF   1F,W
1932:  MOVWF  xE8
1934:  MOVLW  00
1936:  BTFSC  x36.0
1938:  MOVLW  01
193A:  IORWF  xE8,W
193C:  MOVWF  1F
....................     
....................    Input17_24_Send = Input17_24_Send | In.B24; 
193E:  MOVLW  00
1940:  BTFSC  x37.7
1942:  MOVLW  01
1944:  IORWF  20,F
....................    Input17_24_Send = (Input17_24_Send << 1) | In.B23; 
1946:  BCF    FD8.0
1948:  RLCF   20,W
194A:  MOVWF  xE8
194C:  MOVLW  00
194E:  BTFSC  x37.6
1950:  MOVLW  01
1952:  IORWF  xE8,W
1954:  MOVWF  20
....................    Input17_24_Send = (Input17_24_Send << 1) | In.B22; 
1956:  BCF    FD8.0
1958:  RLCF   20,W
195A:  MOVWF  xE8
195C:  MOVLW  00
195E:  BTFSC  x37.5
1960:  MOVLW  01
1962:  IORWF  xE8,W
1964:  MOVWF  20
....................    Input17_24_Send = (Input17_24_Send << 1) | In.B21; 
1966:  BCF    FD8.0
1968:  RLCF   20,W
196A:  MOVWF  xE8
196C:  MOVLW  00
196E:  BTFSC  x37.4
1970:  MOVLW  01
1972:  IORWF  xE8,W
1974:  MOVWF  20
....................    Input17_24_Send = (Input17_24_Send << 1) | In.B20; 
1976:  BCF    FD8.0
1978:  RLCF   20,W
197A:  MOVWF  xE8
197C:  MOVLW  00
197E:  BTFSC  x37.3
1980:  MOVLW  01
1982:  IORWF  xE8,W
1984:  MOVWF  20
....................    Input17_24_Send = (Input17_24_Send << 1) | In.B19; 
1986:  BCF    FD8.0
1988:  RLCF   20,W
198A:  MOVWF  xE8
198C:  MOVLW  00
198E:  BTFSC  x37.2
1990:  MOVLW  01
1992:  IORWF  xE8,W
1994:  MOVWF  20
....................    Input17_24_Send = (Input17_24_Send << 1) | In.B18; 
1996:  BCF    FD8.0
1998:  RLCF   20,W
199A:  MOVWF  xE8
199C:  MOVLW  00
199E:  BTFSC  x37.1
19A0:  MOVLW  01
19A2:  IORWF  xE8,W
19A4:  MOVWF  20
....................    Input17_24_Send = (Input17_24_Send << 1) | In.B17; 
19A6:  BCF    FD8.0
19A8:  RLCF   20,W
19AA:  MOVWF  xE8
19AC:  MOVLW  00
19AE:  BTFSC  x37.0
19B0:  MOVLW  01
19B2:  IORWF  xE8,W
19B4:  MOVWF  20
19B6:  MOVLB  0
19B8:  GOTO   3106 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void StoreReleaseFault() 
*
1A4E:  MOVLB  1
1A50:  CLRF   xE8
.................... { 
....................    Signed int8 i=0; 
....................    for(i=0;i<30;i++) 
1A52:  CLRF   xE8
1A54:  BTFSC  xE8.7
1A56:  BRA    1A5E
1A58:  MOVF   xE8,W
1A5A:  SUBLW  1D
1A5C:  BNC   1AA4
....................    { 
....................       FaultAgo[i] = FaultNow[i]; 
1A5E:  CLRF   03
1A60:  MOVF   xE8,W
1A62:  MOVWF  00
1A64:  BTFSC  FE8.7
1A66:  DECF   03,F
1A68:  MOVWF  xE9
1A6A:  MOVFF  03,1EA
1A6E:  CLRF   03
1A70:  MOVF   xE8,W
1A72:  MOVWF  00
1A74:  BTFSC  FE8.7
1A76:  DECF   03,F
1A78:  MOVWF  xEB
1A7A:  MOVLW  01
1A7C:  MOVWF  xED
1A7E:  MOVLW  51
1A80:  MOVWF  xEC
1A82:  MOVLB  0
1A84:  RCALL  1530
1A86:  MOVFF  1E9,1EB
1A8A:  MOVLB  1
1A8C:  CLRF   xEC
1A8E:  BTFSC  01.0
1A90:  INCF   xEC,F
1A92:  MOVLW  01
1A94:  MOVWF  xEE
1A96:  MOVLW  4D
1A98:  MOVWF  xED
1A9A:  MOVLB  0
1A9C:  RCALL  14EE
1A9E:  MOVLB  1
1AA0:  INCF   xE8,F
1AA2:  BRA    1A54
....................    } 
1AA4:  MOVLB  0
1AA6:  GOTO   21E6 (RETURN)
.................... } 
....................  
....................  
.................... void CRC(unsigned char *puchMsg , unsigned char usDataLen) 
.................... {  
....................    unsigned char uIndex ;                   /* fill index into CRC lookup table */ 
....................    unsigned char i ; 
....................  
....................    CRC_Hi = 0xFF ;                      /* high byte of CRC initialized */ 
*
1566:  SETF   xEA
....................    CRC_Lo = 0xFF ;                      /* low byte of CRC initialized */ 
1568:  SETF   xE9
....................  
....................    for(i = 0;i < usDataLen;i++) 
156A:  MOVLB  1
156C:  CLRF   xEC
156E:  MOVF   xEA,W
1570:  SUBWF  xEC,W
1572:  BC    15B2
....................    { 
....................       restart_wdt(); 
1574:  CLRWDT
....................       uIndex = CRC_Hi ^ (unsigned char) puchMsg[i] ; 
1576:  MOVF   xEC,W
1578:  ADDWF  xE8,W
157A:  MOVWF  FE9
157C:  MOVLW  00
157E:  ADDWFC xE9,W
1580:  MOVWF  FEA
1582:  MOVF   FEF,W
1584:  MOVLB  0
1586:  XORWF  xEA,W
1588:  MOVLB  1
158A:  MOVWF  xEB
....................       CRC_Hi = CRC_Lo ^ CRC_Table_Hi[uIndex] ; 
158C:  CLRF   03
158E:  MOVF   xEB,W
1590:  MOVLB  0
1592:  CALL   00BA
1596:  MOVWF  01
1598:  MOVF   xE9,W
159A:  XORWF  01,W
159C:  MOVWF  xEA
....................       CRC_Lo = CRC_Table_Lo[uIndex] ; 
159E:  CLRF   03
15A0:  MOVLB  1
15A2:  MOVF   xEB,W
15A4:  MOVLB  0
15A6:  CALL   01CA
15AA:  MOVWF  xE9
15AC:  MOVLB  1
15AE:  INCF   xEC,F
15B0:  BRA    156E
....................    } 
15B2:  MOVLB  0
15B4:  RETURN 0
.................... } 
....................  
.................... /********************************6B595 Driver*********************************/ 
.................... void Driver595() 
*
72F4:  MOVLB  1
72F6:  CLRF   xE7
.................... { 
....................    Signed int8 j=0; 
....................    int8 data_out ; 
....................  
....................    restart_wdt(); 
72F8:  CLRWDT
....................     
....................     data_out = (~Input19_20); 
72FA:  MOVFF  4C,1E8
72FE:  COMF   xE8,F
....................     for(j=7;j>=0;j--) 
7300:  MOVLW  07
7302:  MOVWF  xE7
7304:  BTFSC  xE7.7
7306:  BRA    7338
....................     { 
....................      //output_bit(EXP_OUT_DO,bit_test(Output595[i],j)); 
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
7308:  MOVFF  1E8,00
730C:  MOVF   xE7,W
730E:  MOVWF  01
7310:  BZ    731A
7312:  BCF    FD8.0
7314:  RRCF   00,F
7316:  DECFSZ 01,F
7318:  BRA    7312
731A:  BTFSC  00.0
731C:  BRA    7322
731E:  BCF    F8A.2
7320:  BRA    7324
7322:  BSF    F8A.2
7324:  BCF    F93.2
....................      output_high(EXP_OUT_CLOCK); 
7326:  BCF    F93.1
7328:  BSF    F8A.1
....................      delay_us(1); 
732A:  CLRWDT
732C:  BRA    732E
732E:  BRA    7330
....................      output_low(EXP_OUT_CLOCK); 
7330:  BCF    F93.1
7332:  BCF    F8A.1
7334:  DECF   xE7,F
7336:  BRA    7304
....................     } 
....................      
....................     data_out = (~Input11_18); 
7338:  MOVFF  4B,1E8
733C:  COMF   xE8,F
....................     for(j=7;j>=0;j--) 
733E:  MOVLW  07
7340:  MOVWF  xE7
7342:  BTFSC  xE7.7
7344:  BRA    7376
....................     { 
....................      //output_bit(EXP_OUT_DO,bit_test(Output595[i],j)); 
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
7346:  MOVFF  1E8,00
734A:  MOVF   xE7,W
734C:  MOVWF  01
734E:  BZ    7358
7350:  BCF    FD8.0
7352:  RRCF   00,F
7354:  DECFSZ 01,F
7356:  BRA    7350
7358:  BTFSC  00.0
735A:  BRA    7360
735C:  BCF    F8A.2
735E:  BRA    7362
7360:  BSF    F8A.2
7362:  BCF    F93.2
....................      output_high(EXP_OUT_CLOCK); 
7364:  BCF    F93.1
7366:  BSF    F8A.1
....................      delay_us(1); 
7368:  CLRWDT
736A:  BRA    736C
736C:  BRA    736E
....................      output_low(EXP_OUT_CLOCK); 
736E:  BCF    F93.1
7370:  BCF    F8A.1
7372:  DECF   xE7,F
7374:  BRA    7342
....................     } 
....................      
....................     data_out = (~Input9_10); 
7376:  MOVFF  4A,1E8
737A:  COMF   xE8,F
....................     for(j=7;j>=0;j--) 
737C:  MOVLW  07
737E:  MOVWF  xE7
7380:  BTFSC  xE7.7
7382:  BRA    73B4
....................     { 
....................      //output_bit(EXP_OUT_DO,bit_test(Output595[i],j)); 
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
7384:  MOVFF  1E8,00
7388:  MOVF   xE7,W
738A:  MOVWF  01
738C:  BZ    7396
738E:  BCF    FD8.0
7390:  RRCF   00,F
7392:  DECFSZ 01,F
7394:  BRA    738E
7396:  BTFSC  00.0
7398:  BRA    739E
739A:  BCF    F8A.2
739C:  BRA    73A0
739E:  BSF    F8A.2
73A0:  BCF    F93.2
....................      output_high(EXP_OUT_CLOCK); 
73A2:  BCF    F93.1
73A4:  BSF    F8A.1
....................      delay_us(1); 
73A6:  CLRWDT
73A8:  BRA    73AA
73AA:  BRA    73AC
....................      output_low(EXP_OUT_CLOCK); 
73AC:  BCF    F93.1
73AE:  BCF    F8A.1
73B0:  DECF   xE7,F
73B2:  BRA    7380
....................     } 
....................      
....................     data_out = (~Input1_8); 
73B4:  MOVFF  49,1E8
73B8:  COMF   xE8,F
....................     for(j=7;j>=0;j--) 
73BA:  MOVLW  07
73BC:  MOVWF  xE7
73BE:  BTFSC  xE7.7
73C0:  BRA    73F2
....................     { 
....................      //output_bit(EXP_OUT_DO,bit_test(Output595[i],j)); 
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
73C2:  MOVFF  1E8,00
73C6:  MOVF   xE7,W
73C8:  MOVWF  01
73CA:  BZ    73D4
73CC:  BCF    FD8.0
73CE:  RRCF   00,F
73D0:  DECFSZ 01,F
73D2:  BRA    73CC
73D4:  BTFSC  00.0
73D6:  BRA    73DC
73D8:  BCF    F8A.2
73DA:  BRA    73DE
73DC:  BSF    F8A.2
73DE:  BCF    F93.2
....................      output_high(EXP_OUT_CLOCK); 
73E0:  BCF    F93.1
73E2:  BSF    F8A.1
....................      delay_us(1); 
73E4:  CLRWDT
73E6:  BRA    73E8
73E8:  BRA    73EA
....................      output_low(EXP_OUT_CLOCK); 
73EA:  BCF    F93.1
73EC:  BCF    F8A.1
73EE:  DECF   xE7,F
73F0:  BRA    73BE
....................     } 
....................  // }  
....................    output_high(EXP_OUT_ENABLE); 
73F2:  BCF    F93.0
73F4:  BSF    F8A.0
....................    delay_us(1); 
73F6:  CLRWDT
73F8:  BRA    73FA
73FA:  BRA    73FC
....................    output_low(EXP_OUT_ENABLE); 
73FC:  BCF    F93.0
73FE:  BCF    F8A.0
7400:  MOVLB  0
7402:  GOTO   7D34 (RETURN)
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void checkCommand(void) 
.................... { 
....................    restart_wdt(); 
*
02DA:  CLRWDT
....................  
....................    //if(sequence == end_sq && Address == SBUF)     //check Address 
....................    if(sequence == end_sq )     //check Address 
02DC:  MOVF   66,W
02DE:  SUBWF  6E,W
02E0:  BNZ   0308
....................    { 
....................      RxD_DataLen = 0x00 ; 
02E2:  CLRF   70
....................      RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 1   Address 
02E4:  CLRF   03
02E6:  MOVF   70,W
02E8:  ADDLW  AD
02EA:  MOVWF  FE9
02EC:  MOVLW  00
02EE:  ADDWFC 03,W
02F0:  MOVWF  FEA
02F2:  MOVFF  2E,FEF
....................      restart_wdt(); 
02F6:  CLRWDT
....................      RxD_DataLen ++ ; 
02F8:  INCF   70,F
....................      sequence = addr_sq; 
02FA:  MOVLW  10
02FC:  MOVWF  6E
....................      T_timeout = 0x14; //200ms 
02FE:  MOVLW  14
0300:  MOVLB  1
0302:  MOVWF  x12
....................    } 
0304:  BRA    0506
0306:  MOVLB  0
....................    else if(sequence == addr_sq) 
0308:  MOVF   6E,W
030A:  SUBLW  10
030C:  BNZ   03A2
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 2   Function Code 
030E:  CLRF   03
0310:  MOVF   70,W
0312:  ADDLW  AD
0314:  MOVWF  FE9
0316:  MOVLW  00
0318:  ADDWFC 03,W
031A:  MOVWF  FEA
031C:  MOVFF  2E,FEF
....................       restart_wdt(); 
0320:  CLRWDT
....................       RxD_DataLen ++ ; 
0322:  INCF   70,F
....................  
....................        if(RxD_Buff[RxD_DataLen - 1] < 0x17)   //Function Code Must be less than 0x20 
0324:  MOVLW  01
0326:  SUBWF  70,W
0328:  CLRF   03
032A:  ADDLW  AD
032C:  MOVWF  FE9
032E:  MOVLW  00
0330:  ADDWFC 03,W
0332:  MOVWF  FEA
0334:  MOVF   FEF,W
0336:  SUBLW  16
0338:  BNC   0348
....................        { 
....................            sequence = code_sq; 
033A:  MOVFF  67,6E
....................            T_timeout = 0x14; //200ms 
033E:  MOVLW  14
0340:  MOVLB  1
0342:  MOVWF  x12
....................        } 
0344:  BRA    039E
0346:  MOVLB  0
....................        else if(RxD_Buff[RxD_DataLen - 1] == 0x20)   /////Read Setting////// 
0348:  MOVLW  01
034A:  SUBWF  70,W
034C:  CLRF   03
034E:  ADDLW  AD
0350:  MOVWF  FE9
0352:  MOVLW  00
0354:  ADDWFC 03,W
0356:  MOVWF  FEA
0358:  MOVF   FEF,W
035A:  SUBLW  20
035C:  BNZ   036C
....................        { 
....................           sequence = ubyte_lo_sq; 
035E:  MOVFF  6A,6E
....................           T_timeout = 0x14; //200ms 
0362:  MOVLW  14
0364:  MOVLB  1
0366:  MOVWF  x12
....................        } 
0368:  BRA    039E
036A:  MOVLB  0
....................        else if(RxD_Buff[RxD_DataLen - 1] == 0x21)   /////Write setting///// 
036C:  MOVLW  01
036E:  SUBWF  70,W
0370:  CLRF   03
0372:  ADDLW  AD
0374:  MOVWF  FE9
0376:  MOVLW  00
0378:  ADDWFC 03,W
037A:  MOVWF  FEA
037C:  MOVF   FEF,W
037E:  SUBLW  21
0380:  BNZ   0390
....................        { 
....................           sequence = byte_count_sq ; 
0382:  MOVFF  6C,6E
....................           T_timeout = 0x14; //200ms 
0386:  MOVLW  14
0388:  MOVLB  1
038A:  MOVWF  x12
....................        } 
038C:  BRA    039E
038E:  MOVLB  0
....................        else                           // Invalid Code 
....................        { 
....................           RxD_DataLen = 0x00; 
0390:  CLRF   70
....................           sequence = end_sq; 
0392:  MOVFF  66,6E
....................           T_timeout = 0x00; 
0396:  MOVLB  1
0398:  CLRF   x12
....................           output_bit(P485ctrl,0); 
039A:  BCF    F8A.3
039C:  BCF    F93.3
....................        } 
....................    } 
039E:  BRA    0506
03A0:  MOVLB  0
....................    else if(sequence == byte_count_sq) 
03A2:  MOVF   6C,W
03A4:  SUBWF  6E,W
03A6:  BNZ   03E0
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 3   Data Byte Count 
03A8:  CLRF   03
03AA:  MOVF   70,W
03AC:  ADDLW  AD
03AE:  MOVWF  FE9
03B0:  MOVLW  00
03B2:  ADDWFC 03,W
03B4:  MOVWF  FEA
03B6:  MOVFF  2E,FEF
....................       restart_wdt(); 
03BA:  CLRWDT
....................       RxD_DataLen ++ ; 
03BC:  INCF   70,F
....................       index = RxD_Buff[RxD_DataLen - 1] ;    //Data Byte Count 
03BE:  MOVLW  01
03C0:  SUBWF  70,W
03C2:  CLRF   03
03C4:  ADDLW  AD
03C6:  MOVWF  FE9
03C8:  MOVLW  00
03CA:  ADDWFC 03,W
03CC:  MOVWF  FEA
03CE:  MOVFF  FEF,113
....................       T_timeout = 0x14; //200ms 
03D2:  MOVLW  14
03D4:  MOVLB  1
03D6:  MOVWF  x12
....................       sequence = data_sq ; 
03D8:  MOVFF  6D,6E
....................    } 
03DC:  BRA    0506
03DE:  MOVLB  0
....................    else if(sequence == data_sq) 
03E0:  MOVF   6D,W
03E2:  SUBWF  6E,W
03E4:  BNZ   0410
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;      // 
03E6:  CLRF   03
03E8:  MOVF   70,W
03EA:  ADDLW  AD
03EC:  MOVWF  FE9
03EE:  MOVLW  00
03F0:  ADDWFC 03,W
03F2:  MOVWF  FEA
03F4:  MOVFF  2E,FEF
....................       restart_wdt(); 
03F8:  CLRWDT
....................       RxD_DataLen ++ ; 
03FA:  INCF   70,F
....................       index -- ;                     //Data Byte Count 
03FC:  MOVLB  1
03FE:  DECF   x13,F
....................       if(index == 0x00) 
0400:  MOVF   x13,F
0402:  BNZ   0408
....................       { 
....................          sequence = ubyte_lo_sq ;      //next CRC 
0404:  MOVFF  6A,6E
....................       } 
....................       T_timeout = 0x14; //200ms 
0408:  MOVLW  14
040A:  MOVWF  x12
....................    } 
040C:  BRA    0506
040E:  MOVLB  0
....................    else if(sequence == code_sq) 
0410:  MOVF   67,W
0412:  SUBWF  6E,W
0414:  BNZ   043A
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 3   Start address High Byte 
0416:  CLRF   03
0418:  MOVF   70,W
041A:  ADDLW  AD
041C:  MOVWF  FE9
041E:  MOVLW  00
0420:  ADDWFC 03,W
0422:  MOVWF  FEA
0424:  MOVFF  2E,FEF
....................       restart_wdt(); 
0428:  CLRWDT
....................       RxD_DataLen ++ ; 
042A:  INCF   70,F
....................       sequence = start_addr_hi_sq; 
042C:  MOVFF  68,6E
....................       T_timeout = 0x14; //200ms 
0430:  MOVLW  14
0432:  MOVLB  1
0434:  MOVWF  x12
....................  
....................    } 
0436:  BRA    0506
0438:  MOVLB  0
....................    else if(sequence == start_addr_hi_sq) 
043A:  MOVF   68,W
043C:  SUBWF  6E,W
043E:  BNZ   0464
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 4   Start address Low Byte 
0440:  CLRF   03
0442:  MOVF   70,W
0444:  ADDLW  AD
0446:  MOVWF  FE9
0448:  MOVLW  00
044A:  ADDWFC 03,W
044C:  MOVWF  FEA
044E:  MOVFF  2E,FEF
....................       restart_wdt(); 
0452:  CLRWDT
....................       RxD_DataLen ++ ; 
0454:  INCF   70,F
....................       sequence = start_addr_lo_sq; 
0456:  MOVFF  69,6E
....................       T_timeout = 0x14; //200ms 
045A:  MOVLW  14
045C:  MOVLB  1
045E:  MOVWF  x12
....................    } 
0460:  BRA    0506
0462:  MOVLB  0
....................    else if(sequence == start_addr_lo_sq) 
0464:  MOVF   69,W
0466:  SUBWF  6E,W
0468:  BNZ   048E
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 5   No. of point/force data High Byte 
046A:  CLRF   03
046C:  MOVF   70,W
046E:  ADDLW  AD
0470:  MOVWF  FE9
0472:  MOVLW  00
0474:  ADDWFC 03,W
0476:  MOVWF  FEA
0478:  MOVFF  2E,FEF
....................       restart_wdt(); 
047C:  CLRWDT
....................       RxD_DataLen ++ ; 
047E:  INCF   70,F
....................       sequence = ubyte_hi_sq; 
0480:  MOVLW  15
0482:  MOVWF  6E
....................       T_timeout = 0x14; //200ms 
0484:  MOVLW  14
0486:  MOVLB  1
0488:  MOVWF  x12
....................    } 
048A:  BRA    0506
048C:  MOVLB  0
....................    else if(sequence == ubyte_hi_sq) 
048E:  MOVF   6E,W
0490:  SUBLW  15
0492:  BNZ   04B8
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 6   No. of point/force data Low Byte 
0494:  CLRF   03
0496:  MOVF   70,W
0498:  ADDLW  AD
049A:  MOVWF  FE9
049C:  MOVLW  00
049E:  ADDWFC 03,W
04A0:  MOVWF  FEA
04A2:  MOVFF  2E,FEF
....................       restart_wdt(); 
04A6:  CLRWDT
....................       RxD_DataLen ++ ; 
04A8:  INCF   70,F
....................       sequence = ubyte_lo_sq; 
04AA:  MOVFF  6A,6E
....................       T_timeout = 0x14; //200ms 
04AE:  MOVLW  14
04B0:  MOVLB  1
04B2:  MOVWF  x12
....................    } 
04B4:  BRA    0506
04B6:  MOVLB  0
....................    else if(sequence == ubyte_lo_sq) 
04B8:  MOVF   6A,W
04BA:  SUBWF  6E,W
04BC:  BNZ   04E2
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 7   CRC High Byte 
04BE:  CLRF   03
04C0:  MOVF   70,W
04C2:  ADDLW  AD
04C4:  MOVWF  FE9
04C6:  MOVLW  00
04C8:  ADDWFC 03,W
04CA:  MOVWF  FEA
04CC:  MOVFF  2E,FEF
....................       restart_wdt(); 
04D0:  CLRWDT
....................       RxD_DataLen ++ ; 
04D2:  INCF   70,F
....................       sequence = crc_hi_sq; 
04D4:  MOVFF  6B,6E
....................       T_timeout = 0x14; //200ms 
04D8:  MOVLW  14
04DA:  MOVLB  1
04DC:  MOVWF  x12
....................    } 
04DE:  BRA    0506
04E0:  MOVLB  0
....................    else if(sequence == crc_hi_sq) 
04E2:  MOVF   6B,W
04E4:  SUBWF  6E,W
04E6:  BNZ   0506
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 8   CRC Low Byte 
04E8:  CLRF   03
04EA:  MOVF   70,W
04EC:  ADDLW  AD
04EE:  MOVWF  FE9
04F0:  MOVLW  00
04F2:  ADDWFC 03,W
04F4:  MOVWF  FEA
04F6:  MOVFF  2E,FEF
....................       restart_wdt(); 
04FA:  CLRWDT
....................       sequence = end_sq; 
04FC:  MOVFF  66,6E
....................       T_timeout = 0x00; 
0500:  MOVLB  1
0502:  CLRF   x12
....................       //T_timeout = 0x14; //200ms 
....................       recieve_completed = 1 ;            //Recieve completed then translate 
0504:  BSF    30.5
0506:  MOVLB  0
....................    } 
0508:  GOTO   0518 (RETURN)
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///////////////////// MODBUS FUNCTION ////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void Modbus_Function(void) 
.................... { 
....................    restart_wdt(); 
*
28C8:  CLRWDT
....................    CRC(RxD_Buff , RxD_DataLen - 1); 
28CA:  MOVLW  01
28CC:  SUBWF  70,W
28CE:  MOVLB  1
28D0:  MOVWF  xE7
28D2:  CLRF   xE9
28D4:  MOVLW  AD
28D6:  MOVWF  xE8
28D8:  MOVFF  1E7,1EA
28DC:  MOVLB  0
28DE:  CALL   1566
....................  
....................    if(CRC_Hi == RxD_Buff[RxD_DataLen - 1] && CRC_Lo == RxD_Buff[RxD_DataLen]) 
28E2:  MOVLW  01
28E4:  SUBWF  70,W
28E6:  CLRF   03
28E8:  ADDLW  AD
28EA:  MOVWF  FE9
28EC:  MOVLW  00
28EE:  ADDWFC 03,W
28F0:  MOVWF  FEA
28F2:  MOVF   FEF,W
28F4:  SUBWF  xEA,W
28F6:  BTFSS  FD8.2
28F8:  GOTO   4014
28FC:  CLRF   03
28FE:  MOVF   70,W
2900:  ADDLW  AD
2902:  MOVWF  FE9
2904:  MOVLW  00
2906:  ADDWFC 03,W
2908:  MOVWF  FEA
290A:  MOVF   FEF,W
290C:  SUBWF  xE9,W
290E:  BTFSS  FD8.2
2910:  GOTO   4014
....................    { 
....................     
....................           
....................       if((RxD_Buff[0] == 0xAA)&&(RxD_Buff[1] == 0x20)) //Read Setting//0xAA Is Any Address  
2914:  MOVF   xAD,W
2916:  SUBLW  AA
2918:  BTFSS  FD8.2
291A:  BRA    2C32
291C:  MOVF   xAE,W
291E:  SUBLW  20
2920:  BTFSS  FD8.2
2922:  BRA    2C32
....................       { 
....................          TxD_Buff[0] = Address ;         //Address 
2924:  MOVFF  6F,71
....................          TxD_Buff[1] = 0x20 ;            //function code 
2928:  MOVLW  20
292A:  MOVWF  72
....................          TxD_Buff[2] = 0x1C ;           //28 Byte  //Data Byte count 
292C:  MOVLW  1C
292E:  MOVWF  73
....................          TxD_Buff[3] = InputType1_8 ;    //1 
2930:  MOVFF  3A,74
....................          TxD_Buff[4] = InputType9_16 ;  //2 
2934:  MOVFF  3B,75
....................          TxD_Buff[5] = InputType17_24 ;//3 
2938:  MOVFF  3C,76
....................           
....................          TxD_Buff[6] = FaultType1_8 ;  //4 
293C:  MOVFF  3D,77
....................          TxD_Buff[7] = FaultType9_16 ; //5 
2940:  MOVFF  3E,78
....................          TxD_Buff[8] = FaultType17_24 ;   //6 
2944:  MOVFF  3F,79
....................          
....................          TxD_Buff[9] = OutputType1_8 ; //7 
2948:  MOVFF  40,7A
....................          TxD_Buff[10] = OutputType9_16 ;  //8 
294C:  MOVFF  41,7B
....................          TxD_Buff[11] = OutputType17_24 ; //9 
2950:  MOVFF  42,7C
....................          
....................          TxD_Buff[12] = OutputBoth1_8 ;   //10 
2954:  MOVFF  43,7D
....................          TxD_Buff[13] = OutputBoth9_16 ;  //11 
2958:  MOVFF  44,7E
....................          TxD_Buff[14] = OutputBoth17_24 ; //12 
295C:  MOVFF  45,7F
....................          
....................          TxD_Buff[15] = Alarm_Indicator1_8 ; //13 
2960:  MOVFF  46,80
....................          TxD_Buff[16] = Alarm_Indicator9_16 ;   //14 
2964:  MOVFF  47,81
....................          TxD_Buff[17] = Alarm_Indicator17_24 ;  //15 
2968:  MOVFF  48,82
....................          
....................           TxD_Buff[18] = read_eeprom(0x10);//Red1_8;    //16 
296C:  MOVFF  FF2,1E7
2970:  BCF    FF2.7
2972:  MOVLW  10
2974:  MOVWF  FA9
2976:  BCF    FA6.6
2978:  BCF    FA6.7
297A:  BSF    FA6.0
297C:  MOVF   FA8,W
297E:  MOVLB  1
2980:  BTFSC  xE7.7
2982:  BSF    FF2.7
2984:  MOVLB  0
2986:  MOVWF  x83
....................           TxD_Buff[19] = read_eeprom(0x11);//Red9_10;      //17 
2988:  MOVFF  FF2,1E7
298C:  BCF    FF2.7
298E:  MOVLW  11
2990:  MOVWF  FA9
2992:  BCF    FA6.6
2994:  BCF    FA6.7
2996:  BSF    FA6.0
2998:  MOVF   FA8,W
299A:  MOVLB  1
299C:  BTFSC  xE7.7
299E:  BSF    FF2.7
29A0:  MOVLB  0
29A2:  MOVWF  x84
....................           TxD_Buff[20] = read_eeprom(0x12);//Red11_18;     //18 
29A4:  MOVFF  FF2,1E7
29A8:  BCF    FF2.7
29AA:  MOVLW  12
29AC:  MOVWF  FA9
29AE:  BCF    FA6.6
29B0:  BCF    FA6.7
29B2:  BSF    FA6.0
29B4:  MOVF   FA8,W
29B6:  MOVLB  1
29B8:  BTFSC  xE7.7
29BA:  BSF    FF2.7
29BC:  MOVLB  0
29BE:  MOVWF  x85
....................           TxD_Buff[21] = read_eeprom(0x13);//Red19_20;     //19 
29C0:  MOVFF  FF2,1E7
29C4:  BCF    FF2.7
29C6:  MOVLW  13
29C8:  MOVWF  FA9
29CA:  BCF    FA6.6
29CC:  BCF    FA6.7
29CE:  BSF    FA6.0
29D0:  MOVF   FA8,W
29D2:  MOVLB  1
29D4:  BTFSC  xE7.7
29D6:  BSF    FF2.7
29D8:  MOVLB  0
29DA:  MOVWF  x86
....................            
....................           TxD_Buff[22] = read_eeprom(0x14);//Green1_8;     //20 
29DC:  MOVFF  FF2,1E7
29E0:  BCF    FF2.7
29E2:  MOVLW  14
29E4:  MOVWF  FA9
29E6:  BCF    FA6.6
29E8:  BCF    FA6.7
29EA:  BSF    FA6.0
29EC:  MOVF   FA8,W
29EE:  MOVLB  1
29F0:  BTFSC  xE7.7
29F2:  BSF    FF2.7
29F4:  MOVLB  0
29F6:  MOVWF  x87
....................           TxD_Buff[23] = read_eeprom(0x15);//Green9_10;    //21 
29F8:  MOVFF  FF2,1E7
29FC:  BCF    FF2.7
29FE:  MOVLW  15
2A00:  MOVWF  FA9
2A02:  BCF    FA6.6
2A04:  BCF    FA6.7
2A06:  BSF    FA6.0
2A08:  MOVF   FA8,W
2A0A:  MOVLB  1
2A0C:  BTFSC  xE7.7
2A0E:  BSF    FF2.7
2A10:  MOVLB  0
2A12:  MOVWF  x88
....................           TxD_Buff[24] = read_eeprom(0x16);//Green11_18;      //22 
2A14:  MOVFF  FF2,1E7
2A18:  BCF    FF2.7
2A1A:  MOVLW  16
2A1C:  MOVWF  FA9
2A1E:  BCF    FA6.6
2A20:  BCF    FA6.7
2A22:  BSF    FA6.0
2A24:  MOVF   FA8,W
2A26:  MOVLB  1
2A28:  BTFSC  xE7.7
2A2A:  BSF    FF2.7
2A2C:  MOVLB  0
2A2E:  MOVWF  x89
....................           TxD_Buff[25] = read_eeprom(0x17);//Green19_20;      //23 
2A30:  MOVFF  FF2,1E7
2A34:  BCF    FF2.7
2A36:  MOVLW  17
2A38:  MOVWF  FA9
2A3A:  BCF    FA6.6
2A3C:  BCF    FA6.7
2A3E:  BSF    FA6.0
2A40:  MOVF   FA8,W
2A42:  MOVLB  1
2A44:  BTFSC  xE7.7
2A46:  BSF    FF2.7
2A48:  MOVLB  0
2A4A:  MOVWF  x8A
....................         
....................         
....................          TxD_Buff[26] = AutoAck ;            //24 
2A4C:  MOVFF  60,8B
....................          TxD_Buff[27] = AutoAckTime ;        //25 
2A50:  MOVFF  61,8C
....................          TxD_Buff[28] = FlashingRate ;       //26 
2A54:  MOVFF  62,8D
....................          TxD_Buff[29] = NoOfPoint ;          //27 
2A58:  MOVFF  63,8E
....................          TxD_Buff[30] = FaultDelayTime[0] ;    //28 
2A5C:  MOVFF  191,8F
....................          TxD_Buff[31] = Address ;            //29 
2A60:  MOVFF  6F,90
....................  
....................  
....................          TxD_Buff[32] = FaultDelayTime[1] ; 
2A64:  MOVFF  193,91
....................          TxD_Buff[33] = FaultDelayTime[2] ; 
2A68:  MOVFF  195,92
....................          TxD_Buff[34] = FaultDelayTime[3] ; 
2A6C:  MOVFF  197,93
....................          TxD_Buff[35] = FaultDelayTime[4] ; 
2A70:  MOVFF  199,94
....................          TxD_Buff[36] = FaultDelayTime[5] ; 
2A74:  MOVFF  19B,95
....................          TxD_Buff[37] = FaultDelayTime[6] ; 
2A78:  MOVFF  19D,96
....................          TxD_Buff[38] = FaultDelayTime[7] ; 
2A7C:  MOVFF  19F,97
....................          TxD_Buff[39] = FaultDelayTime[8] ; 
2A80:  MOVFF  1A1,98
....................          TxD_Buff[40] = FaultDelayTime[9] ; 
2A84:  MOVFF  1A3,99
....................          TxD_Buff[41] = FaultDelayTime[10] ; 
2A88:  MOVFF  1A5,9A
....................          TxD_Buff[42] = FaultDelayTime[11] ; 
2A8C:  MOVFF  1A7,9B
....................          TxD_Buff[43] = FaultDelayTime[12] ; 
2A90:  MOVFF  1A9,9C
....................          TxD_Buff[44] = FaultDelayTime[13] ; 
2A94:  MOVFF  1AB,9D
....................          TxD_Buff[45] = FaultDelayTime[14] ; 
2A98:  MOVFF  1AD,9E
....................          TxD_Buff[46] = FaultDelayTime[15] ; 
2A9C:  MOVFF  1AF,9F
....................          TxD_Buff[47] = FaultDelayTime[16] ; 
2AA0:  MOVFF  1B1,A0
....................          TxD_Buff[48] = FaultDelayTime[17] ; 
2AA4:  MOVFF  1B3,A1
....................          TxD_Buff[49] = FaultDelayTime[18] ; 
2AA8:  MOVFF  1B5,A2
....................          TxD_Buff[50] = FaultDelayTime[19] ; 
2AAC:  MOVFF  1B7,A3
....................          TxD_Buff[51] = FaultDelayTime[20] ; 
2AB0:  MOVFF  1B9,A4
....................           
....................           
....................          CRC(TxD_Buff,52)   ; //Cal CRC 49 byte 
2AB4:  MOVLB  1
2AB6:  CLRF   xE9
2AB8:  MOVLW  71
2ABA:  MOVWF  xE8
2ABC:  MOVLW  34
2ABE:  MOVWF  xEA
2AC0:  MOVLB  0
2AC2:  CALL   1566
....................  
....................          TxD_Buff[52] = CRC_Hi ; 
2AC6:  MOVFF  EA,A5
....................          TxD_Buff[53] = CRC_Lo ; 
2ACA:  MOVFF  E9,A6
....................  
....................          output_bit(P485ctrl,1); 
2ACE:  BSF    F8A.3
2AD0:  BCF    F93.3
....................          delay_ms(10); 
2AD2:  MOVLW  0A
2AD4:  MOVLB  1
2AD6:  MOVWF  xEF
2AD8:  MOVLB  0
2ADA:  CALL   05BE
....................  
....................          putc(Txd_Buff[0]); 
2ADE:  MOVF   71,W
2AE0:  CALL   15B6
....................          putc(Txd_Buff[1]); 
2AE4:  MOVF   72,W
2AE6:  CALL   15B6
....................          putc(Txd_Buff[2]); 
2AEA:  MOVF   73,W
2AEC:  CALL   15B6
....................          putc(Txd_Buff[3]); 
2AF0:  MOVF   74,W
2AF2:  CALL   15B6
....................          putc(Txd_Buff[4]); 
2AF6:  MOVF   75,W
2AF8:  CALL   15B6
....................          putc(Txd_Buff[5]); 
2AFC:  MOVF   76,W
2AFE:  CALL   15B6
....................          putc(Txd_Buff[6]); 
2B02:  MOVF   77,W
2B04:  CALL   15B6
....................          putc(Txd_Buff[7]); 
2B08:  MOVF   78,W
2B0A:  CALL   15B6
....................          putc(Txd_Buff[8]); 
2B0E:  MOVF   79,W
2B10:  CALL   15B6
....................          putc(Txd_Buff[9]); 
2B14:  MOVF   7A,W
2B16:  CALL   15B6
....................          putc(Txd_Buff[10]); 
2B1A:  MOVF   7B,W
2B1C:  CALL   15B6
....................          putc(Txd_Buff[11]); 
2B20:  MOVF   7C,W
2B22:  CALL   15B6
....................          putc(Txd_Buff[12]); 
2B26:  MOVF   7D,W
2B28:  CALL   15B6
....................          putc(Txd_Buff[13]); 
2B2C:  MOVF   7E,W
2B2E:  CALL   15B6
....................          putc(Txd_Buff[14]); 
2B32:  MOVF   7F,W
2B34:  CALL   15B6
....................          putc(Txd_Buff[15]); 
2B38:  MOVF   x80,W
2B3A:  CALL   15B6
....................          putc(Txd_Buff[16]); 
2B3E:  MOVF   x81,W
2B40:  CALL   15B6
....................          putc(Txd_Buff[17]); 
2B44:  MOVF   x82,W
2B46:  CALL   15B6
....................          putc(Txd_Buff[18]); 
2B4A:  MOVF   x83,W
2B4C:  CALL   15B6
....................          putc(Txd_Buff[19]); 
2B50:  MOVF   x84,W
2B52:  CALL   15B6
....................          putc(Txd_Buff[20]); 
2B56:  MOVF   x85,W
2B58:  CALL   15B6
....................          putc(Txd_Buff[21]); 
2B5C:  MOVF   x86,W
2B5E:  CALL   15B6
....................          putc(Txd_Buff[22]); 
2B62:  MOVF   x87,W
2B64:  CALL   15B6
....................          putc(Txd_Buff[23]); 
2B68:  MOVF   x88,W
2B6A:  CALL   15B6
....................          putc(Txd_Buff[24]); 
2B6E:  MOVF   x89,W
2B70:  CALL   15B6
....................          putc(Txd_Buff[25]); 
2B74:  MOVF   x8A,W
2B76:  CALL   15B6
....................          putc(Txd_Buff[26]); 
2B7A:  MOVF   x8B,W
2B7C:  CALL   15B6
....................          putc(Txd_Buff[27]); 
2B80:  MOVF   x8C,W
2B82:  CALL   15B6
....................          putc(Txd_Buff[28]); 
2B86:  MOVF   x8D,W
2B88:  CALL   15B6
....................          putc(Txd_Buff[29]); 
2B8C:  MOVF   x8E,W
2B8E:  CALL   15B6
....................          putc(Txd_Buff[30]); 
2B92:  MOVF   x8F,W
2B94:  CALL   15B6
....................          putc(Txd_Buff[31]); 
2B98:  MOVF   x90,W
2B9A:  CALL   15B6
....................           
....................          putc(Txd_Buff[32]); 
2B9E:  MOVF   x91,W
2BA0:  CALL   15B6
....................          putc(Txd_Buff[33]); 
2BA4:  MOVF   x92,W
2BA6:  CALL   15B6
....................          putc(Txd_Buff[34]); 
2BAA:  MOVF   x93,W
2BAC:  CALL   15B6
....................          putc(Txd_Buff[35]); 
2BB0:  MOVF   x94,W
2BB2:  CALL   15B6
....................          putc(Txd_Buff[36]); 
2BB6:  MOVF   x95,W
2BB8:  CALL   15B6
....................          putc(Txd_Buff[37]); 
2BBC:  MOVF   x96,W
2BBE:  CALL   15B6
....................          putc(Txd_Buff[38]); 
2BC2:  MOVF   x97,W
2BC4:  CALL   15B6
....................          putc(Txd_Buff[39]); 
2BC8:  MOVF   x98,W
2BCA:  CALL   15B6
....................          putc(Txd_Buff[40]); 
2BCE:  MOVF   x99,W
2BD0:  CALL   15B6
....................          putc(Txd_Buff[41]); 
2BD4:  MOVF   x9A,W
2BD6:  CALL   15B6
....................           
....................          putc(Txd_Buff[42]); 
2BDA:  MOVF   x9B,W
2BDC:  CALL   15B6
....................          putc(Txd_Buff[43]); 
2BE0:  MOVF   x9C,W
2BE2:  CALL   15B6
....................          putc(Txd_Buff[44]); 
2BE6:  MOVF   x9D,W
2BE8:  CALL   15B6
....................          putc(Txd_Buff[45]); 
2BEC:  MOVF   x9E,W
2BEE:  CALL   15B6
....................          putc(Txd_Buff[46]); 
2BF2:  MOVF   x9F,W
2BF4:  CALL   15B6
....................          putc(Txd_Buff[47]); 
2BF8:  MOVF   xA0,W
2BFA:  CALL   15B6
....................          putc(Txd_Buff[48]); 
2BFE:  MOVF   xA1,W
2C00:  CALL   15B6
....................          putc(Txd_Buff[49]); 
2C04:  MOVF   xA2,W
2C06:  CALL   15B6
....................          putc(Txd_Buff[50]); 
2C0A:  MOVF   xA3,W
2C0C:  CALL   15B6
....................          putc(Txd_Buff[51]); 
2C10:  MOVF   xA4,W
2C12:  CALL   15B6
....................           
....................          putc(Txd_Buff[52]); 
2C16:  MOVF   xA5,W
2C18:  CALL   15B6
....................          putc(Txd_Buff[53]); 
2C1C:  MOVF   xA6,W
2C1E:  CALL   15B6
....................         
....................          delay_ms(3); 
2C22:  MOVLW  03
2C24:  MOVLB  1
2C26:  MOVWF  xEF
2C28:  MOVLB  0
2C2A:  CALL   05BE
....................          output_bit(P485ctrl,0); 
2C2E:  BCF    F8A.3
2C30:  BCF    F93.3
....................           
....................       } 
....................       
....................    /////////////////////////////////////////////////////////////// 
....................    if(RxD_Buff[0] == Address) 
2C32:  MOVF   6F,W
2C34:  SUBWF  xAD,W
2C36:  BTFSS  FD8.2
2C38:  GOTO   400C
....................    { 
....................           
....................       if(RxD_Buff[1] == 0x01)///////////// READ COIL ///////////////////// 
2C3C:  DECFSZ xAE,W
2C3E:  BRA    30FA
....................          { 
....................             //Do Read Coil 
....................             Start_Address = RxD_Buff[2] ; 
2C40:  CLRF   xEE
2C42:  MOVFF  AF,ED
....................             Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Start Address 16 bit 
2C46:  MOVFF  ED,EE
2C4A:  MOVLB  1
2C4C:  CLRF   xE7
2C4E:  MOVF   xE7,W
2C50:  MOVLB  0
2C52:  IORWF  xB0,W
2C54:  MOVWF  xED
2C56:  MOVLB  0
....................             No_PointCount = RxD_Buff[4] ; 
2C58:  CLRF   xF0
2C5A:  MOVFF  B1,EF
....................             No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;      //No. of Point 16 bit 
2C5E:  MOVFF  EF,F0
2C62:  MOVLB  1
2C64:  CLRF   xE7
2C66:  MOVF   xE7,W
2C68:  MOVLB  0
2C6A:  IORWF  xB2,W
2C6C:  MOVWF  xEF
2C6E:  MOVLB  0
....................  
....................             if(Start_Address < 0x10 && (Start_Address + No_PointCount) <= 0x14)  //Valid point 0-20 
2C70:  MOVF   xEE,F
2C72:  BTFSS  FD8.2
2C74:  BRA    308E
2C76:  MOVF   xED,W
2C78:  SUBLW  0F
2C7A:  BTFSS  FD8.0
2C7C:  BRA    308E
2C7E:  MOVF   xEF,W
2C80:  ADDWF  xED,W
2C82:  MOVLB  1
2C84:  MOVWF  xE7
2C86:  MOVLB  0
2C88:  MOVF   xF0,W
2C8A:  ADDWFC xEE,W
2C8C:  MOVLB  1
2C8E:  MOVWF  xE8
2C90:  MOVF   xE8,F
2C92:  BTFSC  FD8.2
2C94:  BRA    2C9A
2C96:  MOVLB  0
2C98:  BRA    308E
2C9A:  MOVF   xE7,W
2C9C:  SUBLW  14
2C9E:  BTFSC  FD8.0
2CA0:  BRA    2CA6
2CA2:  MOVLB  0
2CA4:  BRA    308E
....................             { 
....................                if(No_PointCount < 9) Data_ByteCount = 0x01; 
2CA6:  MOVLB  0
2CA8:  MOVF   xF0,F
2CAA:  BNZ   2CB8
2CAC:  MOVF   xEF,W
2CAE:  SUBLW  08
2CB0:  BNC   2CB8
2CB2:  MOVLW  01
2CB4:  MOVWF  xF1
2CB6:  BRA    2CDC
....................                else if(No_PointCount < 17) Data_ByteCount = 0x02 ; 
2CB8:  MOVF   xF0,F
2CBA:  BNZ   2CC8
2CBC:  MOVF   xEF,W
2CBE:  SUBLW  10
2CC0:  BNC   2CC8
2CC2:  MOVLW  02
2CC4:  MOVWF  xF1
2CC6:  BRA    2CDC
....................                else if(No_PointCount < 25) Data_ByteCount = 0x03 ; 
2CC8:  MOVF   xF0,F
2CCA:  BNZ   2CD8
2CCC:  MOVF   xEF,W
2CCE:  SUBLW  18
2CD0:  BNC   2CD8
2CD2:  MOVLW  03
2CD4:  MOVWF  xF1
2CD6:  BRA    2CDC
....................                else   Data_ByteCount = 0x01 ; //----Jack 
2CD8:  MOVLW  01
2CDA:  MOVWF  xF1
....................  
....................                if(Data_ByteCount == 0x01) 
2CDC:  DECFSZ xF1,W
2CDE:  BRA    2E20
....................                { 
....................  
....................                   if(Start_Address < 0x09) 
2CE0:  MOVF   xEE,F
2CE2:  BNZ   2CFE
2CE4:  MOVF   xED,W
2CE6:  SUBLW  08
2CE8:  BNC   2CFE
....................                   { 
....................                      //Data_Buff[0] = ~output[0] >> Start_Address ; 
....................                      //DataTemp = ~output[1] << (0x08 - Start_Address) ; 
....................                      //Data_Buff[0] = (~output[0] >> Start_Address) | DataTemp;   //Low Byte 
....................                       Data_Buff[0] = Input1_8 >> Start_Address ; 
2CEA:  MOVFF  49,F2
2CEE:  MOVF   xED,W
2CF0:  MOVWF  01
2CF2:  BZ    2CFC
2CF4:  BCF    FD8.0
2CF6:  RRCF   xF2,F
2CF8:  DECFSZ 01,F
2CFA:  BRA    2CF4
....................                       //DataTemp = Input9_16 << (0x08 - Start_Address) ;//JJ 
....................                       //Data_Buff[0] = (Input1_8 >> Start_Address) | DataTemp;   //Low Byte//JJ 
....................                   } 
2CFC:  BRA    2D32
....................                   else if(Start_Address > 0x08 && Start_Address < 0x10) 
2CFE:  MOVF   xEE,F
2D00:  BNZ   2D08
2D02:  MOVF   xED,W
2D04:  SUBLW  08
2D06:  BC    2D32
2D08:  MOVF   xEE,F
2D0A:  BNZ   2D32
2D0C:  MOVF   xED,W
2D0E:  SUBLW  0F
2D10:  BNC   2D32
....................                   { 
....................                      //Data_Buff[0] = ~output[1] >> (Start_Address - 0x08) ; 
....................                      Data_Buff[0] = Input9_16 >> (Start_Address - 0x08) ; 
2D12:  MOVLW  08
2D14:  SUBWF  xED,W
2D16:  MOVWF  00
2D18:  MOVLW  00
2D1A:  SUBWFB xEE,W
2D1C:  MOVWF  03
2D1E:  MOVFF  00,01
2D22:  MOVFF  4D,F2
2D26:  MOVF   01,F
2D28:  BZ    2D32
2D2A:  BCF    FD8.0
2D2C:  RRCF   xF2,F
2D2E:  DECFSZ 01,F
2D30:  BRA    2D2A
....................                   } 
....................  
....................  
....................                   if(No_PointCount == 0x08) 
2D32:  MOVF   xEF,W
2D34:  SUBLW  08
2D36:  BNZ   2D3E
2D38:  MOVF   xF0,F
2D3A:  BNZ   2D3E
....................                   { 
....................                      Data_Buff[0] = Data_Buff[0] & 0xFF ; //8 Point High Byte 
....................                   } 
2D3C:  BRA    2DA8
....................                   else if(No_PointCount == 0x07) 
2D3E:  MOVF   xEF,W
2D40:  SUBLW  07
2D42:  BNZ   2D4C
2D44:  MOVF   xF0,F
2D46:  BNZ   2D4C
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x7F ; //7 Point High Byte 
2D48:  BCF    xF2.7
....................                   } 
2D4A:  BRA    2DA8
....................                   else if(No_PointCount == 0x06) 
2D4C:  MOVF   xEF,W
2D4E:  SUBLW  06
2D50:  BNZ   2D5C
2D52:  MOVF   xF0,F
2D54:  BNZ   2D5C
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x3F ; //6 Point High Byte 
2D56:  MOVLW  3F
2D58:  ANDWF  xF2,F
....................                   } 
2D5A:  BRA    2DA8
....................                   else if(No_PointCount == 0x05) 
2D5C:  MOVF   xEF,W
2D5E:  SUBLW  05
2D60:  BNZ   2D6C
2D62:  MOVF   xF0,F
2D64:  BNZ   2D6C
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x1F ; //5 Point High Byte 
2D66:  MOVLW  1F
2D68:  ANDWF  xF2,F
....................                   } 
2D6A:  BRA    2DA8
....................                   else if(No_PointCount == 0x04) 
2D6C:  MOVF   xEF,W
2D6E:  SUBLW  04
2D70:  BNZ   2D7C
2D72:  MOVF   xF0,F
2D74:  BNZ   2D7C
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x0F ; //4 Point High Byte 
2D76:  MOVLW  0F
2D78:  ANDWF  xF2,F
....................                   } 
2D7A:  BRA    2DA8
....................                   else if(No_PointCount == 0x03) 
2D7C:  MOVF   xEF,W
2D7E:  SUBLW  03
2D80:  BNZ   2D8C
2D82:  MOVF   xF0,F
2D84:  BNZ   2D8C
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x07 ; //3 Point High Byte 
2D86:  MOVLW  07
2D88:  ANDWF  xF2,F
....................                   } 
2D8A:  BRA    2DA8
....................                   else if(No_PointCount == 0x02) 
2D8C:  MOVF   xEF,W
2D8E:  SUBLW  02
2D90:  BNZ   2D9C
2D92:  MOVF   xF0,F
2D94:  BNZ   2D9C
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x03 ; //2 Point High Byte 
2D96:  MOVLW  03
2D98:  ANDWF  xF2,F
....................                   } 
2D9A:  BRA    2DA8
....................                   else if(No_PointCount == 0x01) 
2D9C:  DECFSZ xEF,W
2D9E:  BRA    2DA8
2DA0:  MOVF   xF0,F
2DA2:  BNZ   2DA8
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x01 ; //1 Point High Byte 
2DA4:  MOVLW  01
2DA6:  ANDWF  xF2,F
....................                   } 
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
2DA8:  MOVFF  6F,71
....................                   TxD_Buff[1] = 0x01 ;         //Function Code 
2DAC:  MOVLW  01
2DAE:  MOVWF  72
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
2DB0:  MOVFF  F1,73
....................                   TxD_Buff[3] = Data_Buff[0] ;   //Data 
2DB4:  MOVFF  F2,74
....................  
....................                   CRC(TxD_Buff,4)   ;            //Cal CRC 5 Byte 
2DB8:  MOVLB  1
2DBA:  CLRF   xE9
2DBC:  MOVLW  71
2DBE:  MOVWF  xE8
2DC0:  MOVLW  04
2DC2:  MOVWF  xEA
2DC4:  MOVLB  0
2DC6:  CALL   1566
....................  
....................                   TxD_Buff[4] = CRC_Hi ; 
2DCA:  MOVFF  EA,75
....................                   TxD_Buff[5] = CRC_Lo ; 
2DCE:  MOVFF  E9,76
....................  
....................                   //TxD_DataLen = 0x06 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
2DD2:  BSF    F8A.3
2DD4:  BCF    F93.3
....................                   restart_wdt(); 
2DD6:  CLRWDT
....................                   delay_ms(4); 
2DD8:  MOVLW  04
2DDA:  MOVLB  1
2DDC:  MOVWF  xEF
2DDE:  MOVLB  0
2DE0:  CALL   05BE
....................                   restart_wdt(); 
2DE4:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2DE6:  MOVF   71,W
2DE8:  CALL   15B6
....................                   putc(TxD_Buff[1]) ;               //Function Code 
2DEC:  MOVF   72,W
2DEE:  CALL   15B6
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
2DF2:  MOVF   73,W
2DF4:  CALL   15B6
....................                   putc(TxD_Buff[3]) ; 
2DF8:  MOVF   74,W
2DFA:  CALL   15B6
....................                   putc(TxD_Buff[4]) ; 
2DFE:  MOVF   75,W
2E00:  CALL   15B6
....................                   putc(TxD_Buff[5]) ; 
2E04:  MOVF   76,W
2E06:  CALL   15B6
....................                   //putc(TxD_Buff[6]) ; 
....................                   //putc(TxD_Buff[7]) ; 
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................                 
....................                   restart_wdt(); 
2E0A:  CLRWDT
....................                   delay_ms(3); 
2E0C:  MOVLW  03
2E0E:  MOVLB  1
2E10:  MOVWF  xEF
2E12:  MOVLB  0
2E14:  CALL   05BE
....................                   restart_wdt(); 
2E18:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2E1A:  BCF    F8A.3
2E1C:  BCF    F93.3
....................                
....................                } 
2E1E:  BRA    308C
....................                else if(Data_ByteCount == 0x02) 
2E20:  MOVF   xF1,W
2E22:  SUBLW  02
2E24:  BTFSS  FD8.2
2E26:  BRA    2FE2
....................                { 
....................                   //Data_Buff[1] = ~output[1] >> Start_Address ; 
....................                   //DataTemp = ~output[1] << (0x08 - Start_Address) ; 
....................                   //Data_Buff[0] = (~output[0] >> Start_Address) | DataTemp;   //Low Byte 
....................                    
....................                   //Data_Buff[1] = Output9_16 >> Start_Address ;//jj 
....................                   //DataTemp = Output9_16 << (0x08 - Start_Address) ;//jj 
....................                   //Data_Buff[0] = (Output1_8 >> Start_Address) | DataTemp;   //Low Byte//jj 
....................                   Data_Buff[0] = Input1_8 >> Start_Address ; 
2E28:  MOVFF  49,F2
2E2C:  MOVF   xED,W
2E2E:  MOVWF  01
2E30:  BZ    2E3A
2E32:  BCF    FD8.0
2E34:  RRCF   xF2,F
2E36:  DECFSZ 01,F
2E38:  BRA    2E32
....................                   Data_Buff[1] = Input9_16 ;// >> Start_Address ; 
2E3A:  MOVFF  4D,F3
....................  
....................  
....................                   if((No_PointCount - 0x07) == 0x08) 
2E3E:  MOVLW  07
2E40:  SUBWF  xEF,W
2E42:  MOVLB  1
2E44:  MOVWF  xE7
2E46:  MOVLW  00
2E48:  MOVLB  0
2E4A:  SUBWFB xF0,W
2E4C:  MOVLB  1
2E4E:  MOVWF  xE8
2E50:  MOVF   xE7,W
2E52:  SUBLW  08
2E54:  BNZ   2E5C
2E56:  MOVF   xE8,F
2E58:  BNZ   2E5C
....................                   { 
....................                      Data_Buff[1] = Data_Buff[1] & 0xFF ; //16 Point High Byte 
....................                   } 
2E5A:  BRA    2F62
....................                   else if((No_PointCount - 0x07) == 0x07) 
2E5C:  MOVLW  07
2E5E:  MOVLB  0
2E60:  SUBWF  xEF,W
2E62:  MOVLB  1
2E64:  MOVWF  xE7
2E66:  MOVLW  00
2E68:  MOVLB  0
2E6A:  SUBWFB xF0,W
2E6C:  MOVLB  1
2E6E:  MOVWF  xE8
2E70:  MOVF   xE7,W
2E72:  SUBLW  07
2E74:  BNZ   2E80
2E76:  MOVF   xE8,F
2E78:  BNZ   2E80
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x7F ; //15 Point High Byte 
2E7A:  MOVLB  0
2E7C:  BCF    xF3.7
....................                   } 
2E7E:  BRA    2F60
....................                   else if((No_PointCount - 0x07) == 0x06) 
2E80:  MOVLW  07
2E82:  MOVLB  0
2E84:  SUBWF  xEF,W
2E86:  MOVLB  1
2E88:  MOVWF  xE7
2E8A:  MOVLW  00
2E8C:  MOVLB  0
2E8E:  SUBWFB xF0,W
2E90:  MOVLB  1
2E92:  MOVWF  xE8
2E94:  MOVF   xE7,W
2E96:  SUBLW  06
2E98:  BNZ   2EA6
2E9A:  MOVF   xE8,F
2E9C:  BNZ   2EA6
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x3F ; //14 Point High Byte 
2E9E:  MOVLW  3F
2EA0:  MOVLB  0
2EA2:  ANDWF  xF3,F
....................                   } 
2EA4:  BRA    2F60
....................                   else if((No_PointCount - 0x07) == 0x05) 
2EA6:  MOVLW  07
2EA8:  MOVLB  0
2EAA:  SUBWF  xEF,W
2EAC:  MOVLB  1
2EAE:  MOVWF  xE7
2EB0:  MOVLW  00
2EB2:  MOVLB  0
2EB4:  SUBWFB xF0,W
2EB6:  MOVLB  1
2EB8:  MOVWF  xE8
2EBA:  MOVF   xE7,W
2EBC:  SUBLW  05
2EBE:  BNZ   2ECC
2EC0:  MOVF   xE8,F
2EC2:  BNZ   2ECC
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x1F ; //13 Point High Byte 
2EC4:  MOVLW  1F
2EC6:  MOVLB  0
2EC8:  ANDWF  xF3,F
....................                   } 
2ECA:  BRA    2F60
....................                   else if((No_PointCount - 0x07) == 0x04) 
2ECC:  MOVLW  07
2ECE:  MOVLB  0
2ED0:  SUBWF  xEF,W
2ED2:  MOVLB  1
2ED4:  MOVWF  xE7
2ED6:  MOVLW  00
2ED8:  MOVLB  0
2EDA:  SUBWFB xF0,W
2EDC:  MOVLB  1
2EDE:  MOVWF  xE8
2EE0:  MOVF   xE7,W
2EE2:  SUBLW  04
2EE4:  BNZ   2EF2
2EE6:  MOVF   xE8,F
2EE8:  BNZ   2EF2
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x0F ; //12 Point High Byte 
2EEA:  MOVLW  0F
2EEC:  MOVLB  0
2EEE:  ANDWF  xF3,F
....................                   } 
2EF0:  BRA    2F60
....................                   else if((No_PointCount - 0x07) == 0x03) 
2EF2:  MOVLW  07
2EF4:  MOVLB  0
2EF6:  SUBWF  xEF,W
2EF8:  MOVLB  1
2EFA:  MOVWF  xE7
2EFC:  MOVLW  00
2EFE:  MOVLB  0
2F00:  SUBWFB xF0,W
2F02:  MOVLB  1
2F04:  MOVWF  xE8
2F06:  MOVF   xE7,W
2F08:  SUBLW  03
2F0A:  BNZ   2F18
2F0C:  MOVF   xE8,F
2F0E:  BNZ   2F18
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x07 ; //11 Point High Byte 
2F10:  MOVLW  07
2F12:  MOVLB  0
2F14:  ANDWF  xF3,F
....................                   } 
2F16:  BRA    2F60
....................                   else if((No_PointCount - 0x07) == 0x02) 
2F18:  MOVLW  07
2F1A:  MOVLB  0
2F1C:  SUBWF  xEF,W
2F1E:  MOVLB  1
2F20:  MOVWF  xE7
2F22:  MOVLW  00
2F24:  MOVLB  0
2F26:  SUBWFB xF0,W
2F28:  MOVLB  1
2F2A:  MOVWF  xE8
2F2C:  MOVF   xE7,W
2F2E:  SUBLW  02
2F30:  BNZ   2F3E
2F32:  MOVF   xE8,F
2F34:  BNZ   2F3E
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x03 ; //10 Point High Byte 
2F36:  MOVLW  03
2F38:  MOVLB  0
2F3A:  ANDWF  xF3,F
....................                   } 
2F3C:  BRA    2F60
....................                   else if((No_PointCount - 0x07) == 0x01) 
2F3E:  MOVLW  07
2F40:  MOVLB  0
2F42:  SUBWF  xEF,W
2F44:  MOVLB  1
2F46:  MOVWF  xE7
2F48:  MOVLW  00
2F4A:  MOVLB  0
2F4C:  SUBWFB xF0,W
2F4E:  MOVLB  1
2F50:  MOVWF  xE8
2F52:  DECFSZ xE7,W
2F54:  BRA    2F62
2F56:  MOVF   xE8,F
2F58:  BNZ   2F62
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x01 ; //9 Point High Byte 
2F5A:  MOVLW  01
2F5C:  MOVLB  0
2F5E:  ANDWF  xF3,F
2F60:  MOVLB  1
....................                   } 
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
2F62:  MOVFF  6F,71
....................                   TxD_Buff[1] = 0x01 ;         //Function Code 
2F66:  MOVLW  01
2F68:  MOVWF  72
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
2F6A:  MOVFF  F1,73
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
2F6E:  MOVFF  F2,74
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
2F72:  MOVFF  F3,75
....................  
....................                   CRC(TxD_Buff,5)   ;            //Cal CRC 5 Byte 
2F76:  CLRF   xE9
2F78:  MOVLW  71
2F7A:  MOVWF  xE8
2F7C:  MOVLW  05
2F7E:  MOVWF  xEA
2F80:  MOVLB  0
2F82:  CALL   1566
....................  
....................                   TxD_Buff[5] = CRC_Hi ; 
2F86:  MOVFF  EA,76
....................                   TxD_Buff[6] = CRC_Lo ; 
2F8A:  MOVFF  E9,77
....................  
....................                   //TxD_DataLen = 0x07 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
2F8E:  BSF    F8A.3
2F90:  BCF    F93.3
....................                   restart_wdt(); 
2F92:  CLRWDT
....................                   delay_ms(4); 
2F94:  MOVLW  04
2F96:  MOVLB  1
2F98:  MOVWF  xEF
2F9A:  MOVLB  0
2F9C:  CALL   05BE
....................                   restart_wdt(); 
2FA0:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2FA2:  MOVF   71,W
2FA4:  CALL   15B6
....................                   putc(TxD_Buff[1]) ;               //Function Code 
2FA8:  MOVF   72,W
2FAA:  CALL   15B6
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
2FAE:  MOVF   73,W
2FB0:  CALL   15B6
....................                   putc(TxD_Buff[3]) ; 
2FB4:  MOVF   74,W
2FB6:  CALL   15B6
....................                   putc(TxD_Buff[4]) ; 
2FBA:  MOVF   75,W
2FBC:  CALL   15B6
....................                   putc(TxD_Buff[5]) ; 
2FC0:  MOVF   76,W
2FC2:  CALL   15B6
....................                   putc(TxD_Buff[6]) ; 
2FC6:  MOVF   77,W
2FC8:  CALL   15B6
....................                   //putc(TxD_Buff[7]) ; 
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
2FCC:  CLRWDT
....................                   delay_ms(3); 
2FCE:  MOVLW  03
2FD0:  MOVLB  1
2FD2:  MOVWF  xEF
2FD4:  MOVLB  0
2FD6:  CALL   05BE
....................                   restart_wdt(); 
2FDA:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2FDC:  BCF    F8A.3
2FDE:  BCF    F93.3
....................                
....................                } 
2FE0:  BRA    308C
....................                else if(Data_ByteCount == 0x03) 
2FE2:  MOVF   xF1,W
2FE4:  SUBLW  03
2FE6:  BNZ   308C
....................                { 
....................                   Data_Buff[0] = Input1_8 >> Start_Address ; 
2FE8:  MOVFF  49,F2
2FEC:  MOVF   xED,W
2FEE:  MOVWF  01
2FF0:  BZ    2FFA
2FF2:  BCF    FD8.0
2FF4:  RRCF   xF2,F
2FF6:  DECFSZ 01,F
2FF8:  BRA    2FF2
....................                   Data_Buff[1] = Input9_16 ;// >> Start_Address ; 
2FFA:  MOVFF  4D,F3
....................                   Data_Buff[2] = Input17_24 ;// >> Start_Address ; 
2FFE:  MOVFF  4E,F4
....................                    
....................                   TxD_Buff[0] = Address ;         //Address 
3002:  MOVFF  6F,71
....................                   TxD_Buff[1] = 0x01 ;         //Function Code 
3006:  MOVLW  01
3008:  MOVWF  72
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
300A:  MOVFF  F1,73
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
300E:  MOVFF  F2,74
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
3012:  MOVFF  F3,75
....................                   TxD_Buff[5] = Data_Buff[2] ;   
3016:  MOVFF  F4,76
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 5 Byte 
301A:  MOVLB  1
301C:  CLRF   xE9
301E:  MOVLW  71
3020:  MOVWF  xE8
3022:  MOVLW  06
3024:  MOVWF  xEA
3026:  MOVLB  0
3028:  CALL   1566
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
302C:  MOVFF  EA,77
....................                   TxD_Buff[7] = CRC_Lo ; 
3030:  MOVFF  E9,78
....................  
....................                   //TxD_DataLen = 0x07 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
3034:  BSF    F8A.3
3036:  BCF    F93.3
....................                   restart_wdt(); 
3038:  CLRWDT
....................                   delay_ms(4); 
303A:  MOVLW  04
303C:  MOVLB  1
303E:  MOVWF  xEF
3040:  MOVLB  0
3042:  CALL   05BE
....................                   restart_wdt(); 
3046:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
3048:  MOVF   71,W
304A:  CALL   15B6
....................                   putc(TxD_Buff[1]) ;               //Function Code 
304E:  MOVF   72,W
3050:  CALL   15B6
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
3054:  MOVF   73,W
3056:  CALL   15B6
....................                   putc(TxD_Buff[3]) ; 
305A:  MOVF   74,W
305C:  CALL   15B6
....................                   putc(TxD_Buff[4]) ; 
3060:  MOVF   75,W
3062:  CALL   15B6
....................                   putc(TxD_Buff[5]) ; 
3066:  MOVF   76,W
3068:  CALL   15B6
....................                   putc(TxD_Buff[6]) ; 
306C:  MOVF   77,W
306E:  CALL   15B6
....................                   putc(TxD_Buff[7]) ; 
3072:  MOVF   78,W
3074:  CALL   15B6
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
3078:  CLRWDT
....................                   delay_ms(3); 
307A:  MOVLW  03
307C:  MOVLB  1
307E:  MOVWF  xEF
3080:  MOVLB  0
3082:  CALL   05BE
....................                   restart_wdt(); 
3086:  CLRWDT
....................                   output_bit(P485ctrl,0); 
3088:  BCF    F8A.3
308A:  BCF    F93.3
....................                 
....................                } 
....................             } 
308C:  BRA    30FA
....................             else 
....................             { 
....................                //invalid parameter 
....................                TxD_Buff[0] = Address ;         //Address 
308E:  MOVFF  6F,71
....................                TxD_Buff[1] = 0x81 ;         //Function Code 
3092:  MOVLW  81
3094:  MOVWF  72
....................                TxD_Buff[2] = 0x02 ;         //illegal data address 
3096:  MOVLW  02
3098:  MOVWF  73
....................  
....................                CRC(TxD_Buff,3)   ;            //Cal CRC 3 Byte 
309A:  MOVLB  1
309C:  CLRF   xE9
309E:  MOVLW  71
30A0:  MOVWF  xE8
30A2:  MOVLW  03
30A4:  MOVWF  xEA
30A6:  MOVLB  0
30A8:  CALL   1566
....................  
....................                TxD_Buff[3] = CRC_Hi ; 
30AC:  MOVFF  EA,74
....................                TxD_Buff[4] = CRC_Lo ; 
30B0:  MOVFF  E9,75
....................  
....................                //TxD_DataLen = 0x05 ; 
....................                //rs485_ctrl = 1; 
....................                //restart_wdt(); 
....................                //dmsec(4); 
....................                //restart_wdt(); 
....................                //send = 1; 
....................                //TI=1; 
....................                output_bit(P485ctrl,1); 
30B4:  BSF    F8A.3
30B6:  BCF    F93.3
....................                restart_wdt(); 
30B8:  CLRWDT
....................                delay_ms(4); 
30BA:  MOVLW  04
30BC:  MOVLB  1
30BE:  MOVWF  xEF
30C0:  MOVLB  0
30C2:  CALL   05BE
....................                restart_wdt(); 
30C6:  CLRWDT
....................  
....................                putc(TxD_Buff[0]) ;               //Address 
30C8:  MOVF   71,W
30CA:  CALL   15B6
....................                putc(TxD_Buff[1]) ;               //Function Code 
30CE:  MOVF   72,W
30D0:  CALL   15B6
....................                putc(TxD_Buff[2]) ;               //Byte Count 
30D4:  MOVF   73,W
30D6:  CALL   15B6
....................                putc(TxD_Buff[3]) ; 
30DA:  MOVF   74,W
30DC:  CALL   15B6
....................                putc(TxD_Buff[4]) ; 
30E0:  MOVF   75,W
30E2:  CALL   15B6
....................  
....................                restart_wdt(); 
30E6:  CLRWDT
....................                delay_ms(3); 
30E8:  MOVLW  03
30EA:  MOVLB  1
30EC:  MOVWF  xEF
30EE:  MOVLB  0
30F0:  CALL   05BE
....................                restart_wdt(); 
30F4:  CLRWDT
....................                output_bit(P485ctrl,0); 
30F6:  BCF    F8A.3
30F8:  BCF    F93.3
....................                 
....................             } 
....................          } 
.................... ////\*/ 
....................                  /*-------------jack----*/ 
....................   
....................       if(RxD_Buff[1] == 0x07)///////////// READ COIL (esp code)//////////// 
30FA:  MOVF   xAE,W
30FC:  SUBLW  07
30FE:  BTFSS  FD8.2
3100:  BRA    325E
....................       { 
....................          Alarmtosend(); 
3102:  GOTO   15C0
....................           
....................          disable_interrupts(INT_TIMER2); 
3106:  BCF    F9D.1
....................          //----------------------------------jj----------------------------// 
....................           
....................             Data_Buff[0] = Input1_8_Send ; //>> Start_Address ; 
3108:  MOVFF  1E,F2
....................             Data_Buff[1] = Input9_16_Send ;// >> Start_Address ; 
310C:  MOVFF  1F,F3
....................             Data_Buff[2] = Input17_24_Send ;// >> Start_Address ; 
3110:  MOVFF  20,F4
....................             Data_Buff[3] = Input25_32_Send ; 
3114:  MOVFF  21,F5
....................             Data_Buff[4] = Input33_40_Send ; 
3118:  MOVFF  22,F6
....................             Data_Buff[5] = Input41_48_Send ; 
311C:  MOVFF  23,F7
....................             Data_Buff[6] = Input49_56_Send ; 
3120:  MOVFF  24,F8
....................             Data_Buff[7] = Input57_64_Send ; 
3124:  MOVFF  25,F9
....................             
....................             Data_Buff[8] = Ack1_8_Send ; 
3128:  MOVFF  26,FA
....................             Data_Buff[9] = Ack9_16_Send ; 
312C:  MOVFF  27,FB
....................             Data_Buff[10] = Ack17_24_Send ; 
3130:  MOVFF  28,FC
....................             Data_Buff[11] = Ack25_32_Send ; 
3134:  MOVFF  29,FD
....................             Data_Buff[12] = Ack33_40_Send ; 
3138:  MOVFF  2A,FE
....................             Data_Buff[13] = Ack41_48_Send ; 
313C:  MOVFF  2B,FF
....................             Data_Buff[14] = Ack49_56_Send ; 
3140:  MOVFF  2C,100
....................             Data_Buff[15] = Ack57_64_Send ; 
3144:  MOVFF  2D,101
....................     
....................              
....................              
....................             TxD_Buff[0] = Address ;         //Address 
3148:  MOVFF  6F,71
....................             TxD_Buff[1] = 0x07 ;         //Function Code 
314C:  MOVLW  07
314E:  MOVWF  72
....................             TxD_Buff[2] = Data_ByteCount=0x10;   //Byte Count 
3150:  MOVLW  10
3152:  MOVWF  xF1
3154:  MOVFF  F1,73
....................             TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
3158:  MOVFF  F2,74
....................             TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
315C:  MOVFF  F3,75
....................             TxD_Buff[5] = Data_Buff[2] ;   
3160:  MOVFF  F4,76
....................             TxD_Buff[6] = Data_Buff[3] ; 
3164:  MOVFF  F5,77
....................             TxD_Buff[7] = Data_Buff[4] ; 
3168:  MOVFF  F6,78
....................             TxD_Buff[8] = Data_Buff[5] ; 
316C:  MOVFF  F7,79
....................             TxD_Buff[9] = Data_Buff[6] ; 
3170:  MOVFF  F8,7A
....................             TxD_Buff[10] = Data_Buff[7] ; 
3174:  MOVFF  F9,7B
....................                
....................            TxD_Buff[11] = Data_Buff[8] ; //Ack1-8 
3178:  MOVFF  FA,7C
....................            TxD_Buff[12] = Data_Buff[9] ; 
317C:  MOVFF  FB,7D
....................            TxD_Buff[13] = Data_Buff[10] ; 
3180:  MOVFF  FC,7E
....................            TxD_Buff[14] = Data_Buff[11] ; 
3184:  MOVFF  FD,7F
....................            TxD_Buff[15] = Data_Buff[12] ; 
3188:  MOVFF  FE,80
....................            TxD_Buff[16] = Data_Buff[13] ; 
318C:  MOVFF  FF,81
....................            TxD_Buff[17] = Data_Buff[14] ; 
3190:  MOVFF  100,82
....................            TxD_Buff[18] = Data_Buff[15] ; //Ack57-64 
3194:  MOVFF  101,83
....................  
....................            CRC(TxD_Buff,19);            //Cal CRC 5 Byte 
3198:  MOVLB  1
319A:  CLRF   xE9
319C:  MOVLW  71
319E:  MOVWF  xE8
31A0:  MOVLW  13
31A2:  MOVWF  xEA
31A4:  MOVLB  0
31A6:  CALL   1566
....................  
....................           TxD_Buff[19] = CRC_Hi ; 
31AA:  MOVFF  EA,84
....................           TxD_Buff[20] = CRC_Lo ; 
31AE:  MOVFF  E9,85
....................  
....................          
....................          output_bit(P485ctrl,1); 
31B2:  BSF    F8A.3
31B4:  BCF    F93.3
....................          restart_wdt(); 
31B6:  CLRWDT
....................          delay_ms(4); 
31B8:  MOVLW  04
31BA:  MOVLB  1
31BC:  MOVWF  xEF
31BE:  MOVLB  0
31C0:  CALL   05BE
....................          restart_wdt(); 
31C4:  CLRWDT
....................                 
....................          putc(TxD_Buff[0]) ;               //Address 
31C6:  MOVF   71,W
31C8:  CALL   15B6
....................          putc(TxD_Buff[1]) ;               //Function Code 
31CC:  MOVF   72,W
31CE:  CALL   15B6
....................          putc(TxD_Buff[2]) ;               //Byte Count 
31D2:  MOVF   73,W
31D4:  CALL   15B6
....................          putc(TxD_Buff[3]) ; 
31D8:  MOVF   74,W
31DA:  CALL   15B6
....................          putc(TxD_Buff[4]) ; 
31DE:  MOVF   75,W
31E0:  CALL   15B6
....................          putc(TxD_Buff[5]) ; 
31E4:  MOVF   76,W
31E6:  CALL   15B6
....................          putc(TxD_Buff[6]) ; 
31EA:  MOVF   77,W
31EC:  CALL   15B6
....................          putc(TxD_Buff[7]) ; 
31F0:  MOVF   78,W
31F2:  CALL   15B6
....................          putc(TxD_Buff[8]) ; 
31F6:  MOVF   79,W
31F8:  CALL   15B6
....................          putc(TxD_Buff[9]) ; 
31FC:  MOVF   7A,W
31FE:  CALL   15B6
....................          putc(TxD_Buff[10]) ; 
3202:  MOVF   7B,W
3204:  CALL   15B6
....................          putc(TxD_Buff[11]) ; 
3208:  MOVF   7C,W
320A:  CALL   15B6
....................          putc(TxD_Buff[12]) ; 
320E:  MOVF   7D,W
3210:  CALL   15B6
....................          putc(TxD_Buff[13]) ; 
3214:  MOVF   7E,W
3216:  CALL   15B6
....................          putc(TxD_Buff[14]) ; 
321A:  MOVF   7F,W
321C:  CALL   15B6
....................          putc(TxD_Buff[15]) ; 
3220:  MOVF   x80,W
3222:  CALL   15B6
....................          putc(TxD_Buff[16]) ; 
3226:  MOVF   x81,W
3228:  CALL   15B6
....................          putc(TxD_Buff[17]) ; 
322C:  MOVF   x82,W
322E:  CALL   15B6
....................          putc(TxD_Buff[18]) ; 
3232:  MOVF   x83,W
3234:  CALL   15B6
....................          putc(TxD_Buff[19]) ; 
3238:  MOVF   x84,W
323A:  CALL   15B6
....................          putc(TxD_Buff[20]) ; 
323E:  MOVF   x85,W
3240:  CALL   15B6
....................  
....................          restart_wdt(); 
3244:  CLRWDT
....................          delay_ms(3); 
3246:  MOVLW  03
3248:  MOVLB  1
324A:  MOVWF  xEF
324C:  MOVLB  0
324E:  CALL   05BE
....................          restart_wdt(); 
3252:  CLRWDT
....................          output_bit(P485ctrl,0); 
3254:  BCF    F8A.3
3256:  BCF    F93.3
....................             
....................          
....................          ///////////////////////////////////////// 
....................           
....................         enable_interrupts(INT_TIMER2);  
3258:  BSF    F9D.1
....................       
....................        } 
325A:  GOTO   3F62
....................       ///////////////////////////////////////////////////////////////// 
....................  
....................          /*-------------jack---- 
....................          //else if(RxD_Buff[1] == 0x02)/////////// READ Inputt ///////////////////// 
....................          if(RxD_Buff[1] == 0x02)///////////// READ Inputt ///////////////////// 
....................          { 
....................             //Do Read Inputt 
....................             Start_Address = RxD_Buff[2] ; 
....................             Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Start Address 16 bit 
....................             No_PointCount = RxD_Buff[4] ; 
....................             No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;      //No. of Point 16 bit 
....................  
....................             //if(Start_Address < 0x10 && (Start_Address + No_PointCount) < 0x11)  //Valid point 0-15 
....................             if(Start_Address == 0x00 && No_PointCount == 0x28)  //Valid point 0-40 
....................             { 
....................              
....................                //\* //----JACK Comment --------// 
....................                if(No_PointCount < 9) Data_ByteCount = 0x01 ; 
....................                else if(No_PointCount < 17) Data_ByteCount = 0x02 ; 
....................                else if(No_PointCount < 25) Data_ByteCount = 0x03 ; 
....................  
....................                if(Data_ByteCount == 0x01) 
....................                { 
....................                   if(Start_Address < 0x09) 
....................                   { 
....................                      Data_Buff[0] = Input1_8 >> Start_Address ; 
....................                      DataTemp = Input9_16 << (0x08 - Start_Address) ; 
....................                      Data_Buff[0] = (Input1_8 >> Start_Address) | DataTemp;   //Low Byte 
....................                   } 
....................                   else if(Start_Address > 0x08 && Start_Address < 0x10) 
....................                   { 
....................                      Data_Buff[0] = Input9_16 >> (Start_Address - 0x08) ; 
....................                   } 
....................  
....................  
....................                   if(No_PointCount == 0x08) 
....................                   { 
....................                      Data_Buff[0] = Data_Buff[0] & 0xFF ; //8 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x07) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x7F ; //7 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x06) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x3F ; //6 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x05) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x1F ; //5 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x04) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x0F ; //4 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x03) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x07 ; //3 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x02) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x03 ; //2 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x01) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x01 ; //1 Point High Byte 
....................                   } 
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
....................                   TxD_Buff[1] = 0x02 ;         //Function Code 
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
....................                   TxD_Buff[3] = Data_Buff[0] ;   //Data 
....................  
....................                   CRC(TxD_Buff,4)   ;            //Cal CRC 4 Byte 
....................  
....................                   TxD_Buff[4] = CRC_Hi ; 
....................                   TxD_Buff[5] = CRC_Lo ; 
....................  
....................                   TxD_DataLen = 0x06 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................         //*\///----JACK Comment --------// 
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
....................                   TxD_Buff[1] = 0x02 ;         //Function Code 
....................                   TxD_Buff[2] = 0x05 ;   //Byte Count 
....................                   TxD_Buff[3] = Input1_8 ;   //Data 
....................                   TxD_Buff[4] = Input9_16 ;   //Data 
....................                   TxD_Buff[5] = Input17_24 ;   //Data 
....................                   TxD_Buff[6] = Input25_32 ;   //Data 
....................                   TxD_Buff[7] = Input33_40 ;   //Data 
....................  
....................                   CRC(TxD_Buff,8);            //Cal CRC 4 Byte 
....................  
....................                   TxD_Buff[8] = CRC_Hi ; 
....................                   TxD_Buff[9] = CRC_Lo ; 
....................  
....................                   output_bit(P485ctrl,1); 
....................                   restart_wdt(); 
....................                   delay_ms(4); 
....................                   restart_wdt(); 
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
....................                   putc(TxD_Buff[1]) ;               //Function Code 
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
....................                   putc(TxD_Buff[3]) ; 
....................                   putc(TxD_Buff[4]) ; 
....................                   putc(TxD_Buff[5]) ; 
....................                   putc(TxD_Buff[6]) ; 
....................                   putc(TxD_Buff[7]) ; 
....................                   putc(TxD_Buff[8]) ; 
....................                   putc(TxD_Buff[9]) ; 
....................  
....................                   delay_ms(3); 
....................                   output_bit(P485ctrl,0); 
....................  
....................                /*} 
....................                else if(Data_ByteCount == 0x02) 
....................                { 
....................                   Data_Buff[1] = ~Inputt[1] >> Start_Address ; 
....................                   DataTemp = ~Inputt[1] << (0x08 - Start_Address) ; 
....................                   Data_Buff[0] = (~Inputt[0] >> Start_Address) | DataTemp;   //Low Byte 
....................  
....................                   if((No_PointCount - 0x08) == 0x08) 
....................                   { 
....................                      Data_Buff[1] = Data_Buff[1] & 0xFF ; //16 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x07) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x7F ; //15 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x06) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x3F ; //14 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x05) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x1F ; //13 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x04) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x0F ; //12 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x03) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x07 ; //11 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x02) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x03 ; //10 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x01) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x01 ; //9 Point High Byte 
....................                   } 
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
....................                   TxD_Buff[1] = 0x02 ;         //Function Code 
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
....................  
....................                   CRC(TxD_Buff,5)   ;            //Cal CRC 5 Byte 
....................  
....................                   TxD_Buff[5] = CRC_Hi ; 
....................                   TxD_Buff[6] = CRC_Lo ; 
....................  
....................                   TxD_DataLen = 0x07 ; 
....................                   rs485_ctrl = 1; 
....................                   dmsec(4); 
....................                   send = 1; 
....................                   TI=1; 
....................                }// 
....................             } 
....................             else 
....................             { 
....................                //Invalid function 
....................                TxD_Buff[0] = Address ;         //Address 
....................                TxD_Buff[1] = 0x81 ;         //Function Code 
....................                TxD_Buff[2] = 0x01 ;         //illegal function 
....................  
....................                CRC(TxD_Buff,3)   ;            //Cal CRC 3 Byte 
....................  
....................                TxD_Buff[3] = CRC_Hi ; 
....................                TxD_Buff[4] = CRC_Lo ; 
....................  
....................                output_bit(P485ctrl,1); 
....................                delay_ms(10); 
....................  
....................                putc(Txd_Buff[0]); 
....................                putc(Txd_Buff[1]); 
....................                putc(Txd_Buff[2]); 
....................                putc(Txd_Buff[3]); 
....................                putc(Txd_Buff[4]); 
....................  
....................                delay_ms(3); 
....................                output_bit(P485ctrl,0); 
....................             } 
....................  
....................          } 
....................       } 
....................        
....................       */ 
....................        else if(RxD_Buff[1] == 0x05)///////////// FORCE COIL ///////////////////// 
325E:  MOVF   xAE,W
3260:  SUBLW  05
3262:  BTFSS  FD8.2
3264:  BRA    372C
....................          { 
....................             //Do Force Coil 
....................             Start_Address = RxD_Buff[2] ; 
3266:  CLRF   xEE
3268:  MOVFF  AF,ED
....................             Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Coil Address 16 bit 
326C:  MOVFF  ED,EE
3270:  MOVLB  1
3272:  CLRF   xE7
3274:  MOVF   xE7,W
3276:  MOVLB  0
3278:  IORWF  xB0,W
327A:  MOVWF  xED
327C:  MOVLB  0
....................             No_PointCount = RxD_Buff[4] ; 
327E:  CLRF   xF0
3280:  MOVFF  B1,EF
....................             No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;   //Force Data 16 bit FF00 = ON, 00FF = OFF 
3284:  MOVFF  EF,F0
3288:  MOVLB  1
328A:  CLRF   xE7
328C:  MOVF   xE7,W
328E:  MOVLB  0
3290:  IORWF  xB2,W
3292:  MOVWF  xEF
3294:  MOVLB  0
....................  
....................             if(Start_Address == 0x00)   ////// Acknowlegde ////// 
3296:  MOVF   xED,F
3298:  BNZ   3334
329A:  MOVF   xEE,F
329C:  BNZ   3334
....................             { 
....................                if(No_PointCount == 0xFF00)   //ON 
329E:  MOVF   xEF,F
32A0:  BNZ   3332
32A2:  INCFSZ xF0,W
32A4:  BRA    3332
....................                { 
....................                   //Modbus_ACK = 1 ; 
....................                   AutoAckFlag = 1; 
32A6:  BSF    1A.2
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
32A8:  MOVFF  6F,71
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
32AC:  MOVLW  05
32AE:  MOVWF  72
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
32B0:  MOVFF  AF,73
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
32B4:  MOVFF  B0,74
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
32B8:  MOVFF  B1,75
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
32BC:  MOVFF  B2,76
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
32C0:  MOVLB  1
32C2:  CLRF   xE9
32C4:  MOVLW  71
32C6:  MOVWF  xE8
32C8:  MOVLW  06
32CA:  MOVWF  xEA
32CC:  MOVLB  0
32CE:  CALL   1566
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
32D2:  MOVFF  EA,77
....................                   TxD_Buff[7] = CRC_Lo ; 
32D6:  MOVFF  E9,78
....................  
....................                   //TxD_DataLen = 0x08 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................               output_bit(P485ctrl,1); 
32DA:  BSF    F8A.3
32DC:  BCF    F93.3
....................                   restart_wdt(); 
32DE:  CLRWDT
....................                   delay_ms(4); 
32E0:  MOVLW  04
32E2:  MOVLB  1
32E4:  MOVWF  xEF
32E6:  MOVLB  0
32E8:  CALL   05BE
....................                   restart_wdt(); 
32EC:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
32EE:  MOVF   71,W
32F0:  CALL   15B6
....................                   putc(TxD_Buff[1]) ;               //Function Code 
32F4:  MOVF   72,W
32F6:  CALL   15B6
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
32FA:  MOVF   73,W
32FC:  CALL   15B6
....................                   putc(TxD_Buff[3]) ; 
3300:  MOVF   74,W
3302:  CALL   15B6
....................                   putc(TxD_Buff[4]) ; 
3306:  MOVF   75,W
3308:  CALL   15B6
....................                   putc(TxD_Buff[5]) ; 
330C:  MOVF   76,W
330E:  CALL   15B6
....................                   putc(TxD_Buff[6]) ; 
3312:  MOVF   77,W
3314:  CALL   15B6
....................                   putc(TxD_Buff[7]) ; 
3318:  MOVF   78,W
331A:  CALL   15B6
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
331E:  CLRWDT
....................                   delay_ms(3); 
3320:  MOVLW  03
3322:  MOVLB  1
3324:  MOVWF  xEF
3326:  MOVLB  0
3328:  CALL   05BE
....................                   restart_wdt(); 
332C:  CLRWDT
....................                   output_bit(P485ctrl,0); 
332E:  BCF    F8A.3
3330:  BCF    F93.3
....................                
....................                } 
....................             } 
3332:  BRA    3728
....................             else if(Start_Address == 0x01)   ///// Reset ////// 
3334:  DECFSZ xED,W
3336:  BRA    33D2
3338:  MOVF   xEE,F
333A:  BNZ   33D2
....................             { 
....................                if(No_PointCount == 0xFF00)   //ON 
333C:  MOVF   xEF,F
333E:  BNZ   33D0
3340:  INCFSZ xF0,W
3342:  BRA    33D0
....................                { 
....................                   //Modbus_RET = 1 ; 
....................                   AutoResetFlag = 1; 
3344:  BSF    1A.3
....................                    
....................                   TxD_Buff[0] = Address ;         //Address 
3346:  MOVFF  6F,71
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
334A:  MOVLW  05
334C:  MOVWF  72
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
334E:  MOVFF  AF,73
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
3352:  MOVFF  B0,74
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
3356:  MOVFF  B1,75
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
335A:  MOVFF  B2,76
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
335E:  MOVLB  1
3360:  CLRF   xE9
3362:  MOVLW  71
3364:  MOVWF  xE8
3366:  MOVLW  06
3368:  MOVWF  xEA
336A:  MOVLB  0
336C:  CALL   1566
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
3370:  MOVFF  EA,77
....................                   TxD_Buff[7] = CRC_Lo ; 
3374:  MOVFF  E9,78
....................  
....................                   //TxD_DataLen = 0x08 ; 
....................                   //rs485_ctrl = 1; 
....................                  //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................               output_bit(P485ctrl,1); 
3378:  BSF    F8A.3
337A:  BCF    F93.3
....................                   restart_wdt(); 
337C:  CLRWDT
....................                   delay_ms(4); 
337E:  MOVLW  04
3380:  MOVLB  1
3382:  MOVWF  xEF
3384:  MOVLB  0
3386:  CALL   05BE
....................                   restart_wdt(); 
338A:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
338C:  MOVF   71,W
338E:  CALL   15B6
....................                   putc(TxD_Buff[1]) ;               //Function Code 
3392:  MOVF   72,W
3394:  CALL   15B6
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
3398:  MOVF   73,W
339A:  CALL   15B6
....................                   putc(TxD_Buff[3]) ; 
339E:  MOVF   74,W
33A0:  CALL   15B6
....................                   putc(TxD_Buff[4]) ; 
33A4:  MOVF   75,W
33A6:  CALL   15B6
....................                   putc(TxD_Buff[5]) ; 
33AA:  MOVF   76,W
33AC:  CALL   15B6
....................                   putc(TxD_Buff[6]) ; 
33B0:  MOVF   77,W
33B2:  CALL   15B6
....................                   putc(TxD_Buff[7]) ; 
33B6:  MOVF   78,W
33B8:  CALL   15B6
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
33BC:  CLRWDT
....................                   delay_ms(3); 
33BE:  MOVLW  03
33C0:  MOVLB  1
33C2:  MOVWF  xEF
33C4:  MOVLB  0
33C6:  CALL   05BE
....................                   restart_wdt(); 
33CA:  CLRWDT
....................                   output_bit(P485ctrl,0); 
33CC:  BCF    F8A.3
33CE:  BCF    F93.3
....................                
....................                } 
....................             } 
33D0:  BRA    3728
....................             else if(Start_Address == 0x02)   ///// Test ////// 
33D2:  MOVF   xED,W
33D4:  SUBLW  02
33D6:  BTFSS  FD8.2
33D8:  BRA    351C
33DA:  MOVF   xEE,F
33DC:  BTFSS  FD8.2
33DE:  BRA    351C
....................             { 
....................                if(No_PointCount == 0xFF00)   //ON 
33E0:  MOVF   xEF,F
33E2:  BNZ   3476
33E4:  INCFSZ xF0,W
33E6:  BRA    3476
....................                { 
....................                   //Modbus_Lamp_Test = 1 ; 
....................                   AutoTestFlag = 1; 
33E8:  BSF    1A.4
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
33EA:  MOVFF  6F,71
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
33EE:  MOVLW  05
33F0:  MOVWF  72
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
33F2:  MOVFF  AF,73
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
33F6:  MOVFF  B0,74
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
33FA:  MOVFF  B1,75
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
33FE:  MOVFF  B2,76
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
3402:  MOVLB  1
3404:  CLRF   xE9
3406:  MOVLW  71
3408:  MOVWF  xE8
340A:  MOVLW  06
340C:  MOVWF  xEA
340E:  MOVLB  0
3410:  CALL   1566
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
3414:  MOVFF  EA,77
....................                   TxD_Buff[7] = CRC_Lo ; 
3418:  MOVFF  E9,78
....................  
....................                  //TxD_DataLen = 0x08 ; 
....................                  //rs485_ctrl = 1; 
....................                  //dmsec(4); 
....................                  //send = 1; 
....................                  //TI=1; 
....................                   output_bit(P485ctrl,1); 
341C:  BSF    F8A.3
341E:  BCF    F93.3
....................                   restart_wdt(); 
3420:  CLRWDT
....................                   delay_ms(4); 
3422:  MOVLW  04
3424:  MOVLB  1
3426:  MOVWF  xEF
3428:  MOVLB  0
342A:  CALL   05BE
....................                   restart_wdt(); 
342E:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
3430:  MOVF   71,W
3432:  CALL   15B6
....................                   putc(TxD_Buff[1]) ;               //Function Code 
3436:  MOVF   72,W
3438:  CALL   15B6
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
343C:  MOVF   73,W
343E:  CALL   15B6
....................                   putc(TxD_Buff[3]) ; 
3442:  MOVF   74,W
3444:  CALL   15B6
....................                   putc(TxD_Buff[4]) ; 
3448:  MOVF   75,W
344A:  CALL   15B6
....................                   putc(TxD_Buff[5]) ; 
344E:  MOVF   76,W
3450:  CALL   15B6
....................                   putc(TxD_Buff[6]) ; 
3454:  MOVF   77,W
3456:  CALL   15B6
....................                   putc(TxD_Buff[7]) ; 
345A:  MOVF   78,W
345C:  CALL   15B6
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
3460:  CLRWDT
....................                   delay_ms(3); 
3462:  MOVLW  03
3464:  MOVLB  1
3466:  MOVWF  xEF
3468:  MOVLB  0
346A:  CALL   05BE
....................                   restart_wdt(); 
346E:  CLRWDT
....................                   output_bit(P485ctrl,0); 
3470:  BCF    F8A.3
3472:  BCF    F93.3
....................               
....................                } 
3474:  BRA    351A
....................                else if(No_PointCount == 0x00)   //OFF 
3476:  MOVF   xEF,F
3478:  BNZ   351A
347A:  MOVF   xF0,F
347C:  BNZ   351A
....................                { 
....................                   //Modbus_Lamp_Test = 0 ; 
....................                   AutoTestFlag = 0; 
347E:  BCF    1A.4
....................                   Read_input(); 
3480:  CALL   1AAA
....................                   AutoAckFlag = 1; 
3484:  BSF    1A.2
....................                   check_ack(); 
3486:  CALL   2516
....................                   AutoResetFlag = 1; 
348A:  BSF    1A.3
....................                   check_reset(); 
348C:  CALL   26A4
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
3490:  MOVFF  6F,71
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
3494:  MOVLW  05
3496:  MOVWF  72
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
3498:  MOVFF  AF,73
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
349C:  MOVFF  B0,74
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
34A0:  MOVFF  B1,75
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
34A4:  MOVFF  B2,76
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
34A8:  MOVLB  1
34AA:  CLRF   xE9
34AC:  MOVLW  71
34AE:  MOVWF  xE8
34B0:  MOVLW  06
34B2:  MOVWF  xEA
34B4:  MOVLB  0
34B6:  CALL   1566
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
34BA:  MOVFF  EA,77
....................                   TxD_Buff[7] = CRC_Lo ; 
34BE:  MOVFF  E9,78
....................  
....................                   //TxD_DataLen = 0x08 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
34C2:  BSF    F8A.3
34C4:  BCF    F93.3
....................                   restart_wdt(); 
34C6:  CLRWDT
....................                   delay_ms(4); 
34C8:  MOVLW  04
34CA:  MOVLB  1
34CC:  MOVWF  xEF
34CE:  MOVLB  0
34D0:  CALL   05BE
....................                   restart_wdt(); 
34D4:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
34D6:  MOVF   71,W
34D8:  CALL   15B6
....................                   putc(TxD_Buff[1]) ;               //Function Code 
34DC:  MOVF   72,W
34DE:  CALL   15B6
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
34E2:  MOVF   73,W
34E4:  CALL   15B6
....................                   putc(TxD_Buff[3]) ; 
34E8:  MOVF   74,W
34EA:  CALL   15B6
....................                   putc(TxD_Buff[4]) ; 
34EE:  MOVF   75,W
34F0:  CALL   15B6
....................                   putc(TxD_Buff[5]) ; 
34F4:  MOVF   76,W
34F6:  CALL   15B6
....................                   putc(TxD_Buff[6]) ; 
34FA:  MOVF   77,W
34FC:  CALL   15B6
....................                   putc(TxD_Buff[7]) ; 
3500:  MOVF   78,W
3502:  CALL   15B6
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
3506:  CLRWDT
....................                   delay_ms(3); 
3508:  MOVLW  03
350A:  MOVLB  1
350C:  MOVWF  xEF
350E:  MOVLB  0
3510:  CALL   05BE
....................                   restart_wdt(); 
3514:  CLRWDT
....................                   output_bit(P485ctrl,0); 
3516:  BCF    F8A.3
3518:  BCF    F93.3
....................                    
....................                } 
....................             } 
351A:  BRA    3728
....................             else if(Start_Address == 0x03)   ///// Function Test ////// 
351C:  MOVF   xED,W
351E:  SUBLW  03
3520:  BTFSS  FD8.2
3522:  BRA    3666
3524:  MOVF   xEE,F
3526:  BTFSS  FD8.2
3528:  BRA    3666
....................             { 
....................                if(No_PointCount == 0xFF00)   //ON 
352A:  MOVF   xEF,F
352C:  BNZ   35C0
352E:  INCFSZ xF0,W
3530:  BRA    35C0
....................                { 
....................                   //Modbus_Lamp_Test = 1 ; 
....................                   Test_fault = 1 ; 
3532:  BSF    1A.5
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
3534:  MOVFF  6F,71
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
3538:  MOVLW  05
353A:  MOVWF  72
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
353C:  MOVFF  AF,73
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
3540:  MOVFF  B0,74
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
3544:  MOVFF  B1,75
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
3548:  MOVFF  B2,76
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
354C:  MOVLB  1
354E:  CLRF   xE9
3550:  MOVLW  71
3552:  MOVWF  xE8
3554:  MOVLW  06
3556:  MOVWF  xEA
3558:  MOVLB  0
355A:  CALL   1566
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
355E:  MOVFF  EA,77
....................                   TxD_Buff[7] = CRC_Lo ; 
3562:  MOVFF  E9,78
....................  
....................                   output_bit(P485ctrl,1); 
3566:  BSF    F8A.3
3568:  BCF    F93.3
....................                   restart_wdt(); 
356A:  CLRWDT
....................                   delay_ms(8); 
356C:  MOVLW  08
356E:  MOVLB  1
3570:  MOVWF  xEF
3572:  MOVLB  0
3574:  CALL   05BE
....................                   restart_wdt(); 
3578:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
357A:  MOVF   71,W
357C:  CALL   15B6
....................                   putc(TxD_Buff[1]) ;               //Function Code 
3580:  MOVF   72,W
3582:  CALL   15B6
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
3586:  MOVF   73,W
3588:  CALL   15B6
....................                   putc(TxD_Buff[3]) ; 
358C:  MOVF   74,W
358E:  CALL   15B6
....................                   putc(TxD_Buff[4]) ; 
3592:  MOVF   75,W
3594:  CALL   15B6
....................                   putc(TxD_Buff[5]) ; 
3598:  MOVF   76,W
359A:  CALL   15B6
....................                   putc(TxD_Buff[6]) ; 
359E:  MOVF   77,W
35A0:  CALL   15B6
....................                   putc(TxD_Buff[7]) ; 
35A4:  MOVF   78,W
35A6:  CALL   15B6
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
35AA:  CLRWDT
....................                   delay_ms(8); 
35AC:  MOVLW  08
35AE:  MOVLB  1
35B0:  MOVWF  xEF
35B2:  MOVLB  0
35B4:  CALL   05BE
....................                   restart_wdt(); 
35B8:  CLRWDT
....................                   output_bit(P485ctrl,0); 
35BA:  BCF    F8A.3
35BC:  BCF    F93.3
....................                
....................                } 
35BE:  BRA    3664
....................                else if(No_PointCount == 0x00)   //OFF 
35C0:  MOVF   xEF,F
35C2:  BNZ   3664
35C4:  MOVF   xF0,F
35C6:  BNZ   3664
....................                { 
....................                   //Modbus_Lamp_Test = 0 ; 
....................                   Test_fault = 0; 
35C8:  BCF    1A.5
....................                   Read_input(); 
35CA:  CALL   1AAA
....................                   AutoAckFlag = 1; 
35CE:  BSF    1A.2
....................                   check_ack(); 
35D0:  CALL   2516
....................                   AutoResetFlag = 1; 
35D4:  BSF    1A.3
....................                   check_reset(); 
35D6:  CALL   26A4
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
35DA:  MOVFF  6F,71
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
35DE:  MOVLW  05
35E0:  MOVWF  72
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
35E2:  MOVFF  AF,73
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
35E6:  MOVFF  B0,74
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
35EA:  MOVFF  B1,75
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
35EE:  MOVFF  B2,76
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
35F2:  MOVLB  1
35F4:  CLRF   xE9
35F6:  MOVLW  71
35F8:  MOVWF  xE8
35FA:  MOVLW  06
35FC:  MOVWF  xEA
35FE:  MOVLB  0
3600:  CALL   1566
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
3604:  MOVFF  EA,77
....................                   TxD_Buff[7] = CRC_Lo ; 
3608:  MOVFF  E9,78
....................  
....................                   //TxD_DataLen = 0x08 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
360C:  BSF    F8A.3
360E:  BCF    F93.3
....................                   restart_wdt(); 
3610:  CLRWDT
....................                   delay_ms(4); 
3612:  MOVLW  04
3614:  MOVLB  1
3616:  MOVWF  xEF
3618:  MOVLB  0
361A:  CALL   05BE
....................                   restart_wdt(); 
361E:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
3620:  MOVF   71,W
3622:  CALL   15B6
....................                   putc(TxD_Buff[1]) ;               //Function Code 
3626:  MOVF   72,W
3628:  CALL   15B6
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
362C:  MOVF   73,W
362E:  CALL   15B6
....................                   putc(TxD_Buff[3]) ; 
3632:  MOVF   74,W
3634:  CALL   15B6
....................                   putc(TxD_Buff[4]) ; 
3638:  MOVF   75,W
363A:  CALL   15B6
....................                   putc(TxD_Buff[5]) ; 
363E:  MOVF   76,W
3640:  CALL   15B6
....................                   putc(TxD_Buff[6]) ; 
3644:  MOVF   77,W
3646:  CALL   15B6
....................                   putc(TxD_Buff[7]) ; 
364A:  MOVF   78,W
364C:  CALL   15B6
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
3650:  CLRWDT
....................                   delay_ms(3); 
3652:  MOVLW  03
3654:  MOVLB  1
3656:  MOVWF  xEF
3658:  MOVLB  0
365A:  CALL   05BE
....................                   restart_wdt(); 
365E:  CLRWDT
....................                   output_bit(P485ctrl,0); 
3660:  BCF    F8A.3
3662:  BCF    F93.3
....................                    
....................                } 
....................             } 
3664:  BRA    3728
....................             else if(Start_Address == 0x64)   ///// Change Modbus Addr ////// 
3666:  MOVF   xED,W
3668:  SUBLW  64
366A:  BNZ   3728
366C:  MOVF   xEE,F
366E:  BNZ   3728
....................             { 
....................                Address = No_PointCount; 
3670:  MOVFF  EF,6F
....................                write_eeprom(0x1D,Address);   //Communication Address 
3674:  MOVF   FF2,W
3676:  MOVWF  00
3678:  BCF    FF2.7
367A:  MOVLW  1D
367C:  MOVWF  FA9
367E:  MOVFF  6F,FA8
3682:  BCF    FA6.6
3684:  BCF    FA6.7
3686:  BSF    FA6.2
3688:  MOVLB  F
368A:  MOVLW  55
368C:  MOVWF  FA7
368E:  MOVLW  AA
3690:  MOVWF  FA7
3692:  BSF    FA6.1
3694:  BTFSC  FA6.1
3696:  BRA    3694
3698:  BCF    FA6.2
369A:  MOVF   00,W
369C:  IORWF  FF2,F
....................                 
....................                TxD_Buff[0] = Address ;         //Address 
369E:  MOVFF  6F,71
....................                TxD_Buff[1] = 0x05 ;         //Function Code 
36A2:  MOVLW  05
36A4:  MOVWF  72
....................                TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
36A6:  MOVFF  AF,73
....................                TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
36AA:  MOVFF  B0,74
....................                TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
36AE:  MOVFF  B1,75
....................                TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
36B2:  MOVFF  B2,76
....................  
....................                CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
36B6:  MOVLB  1
36B8:  CLRF   xE9
36BA:  MOVLW  71
36BC:  MOVWF  xE8
36BE:  MOVLW  06
36C0:  MOVWF  xEA
36C2:  MOVLB  0
36C4:  CALL   1566
....................  
....................                TxD_Buff[6] = CRC_Hi ; 
36C8:  MOVFF  EA,77
....................                TxD_Buff[7] = CRC_Lo ; 
36CC:  MOVFF  E9,78
....................  
....................                //TxD_DataLen = 0x08 ; 
....................                //rs485_ctrl = 1; 
....................                //dmsec(4); 
....................                //send = 1; 
....................                //TI=1; 
....................                output_bit(P485ctrl,1); 
36D0:  BSF    F8A.3
36D2:  BCF    F93.3
....................                restart_wdt(); 
36D4:  CLRWDT
....................                delay_ms(4); 
36D6:  MOVLW  04
36D8:  MOVLB  1
36DA:  MOVWF  xEF
36DC:  MOVLB  0
36DE:  CALL   05BE
....................                restart_wdt(); 
36E2:  CLRWDT
....................  
....................                putc(TxD_Buff[0]) ;               //Address 
36E4:  MOVF   71,W
36E6:  CALL   15B6
....................                putc(TxD_Buff[1]) ;               //Function Code 
36EA:  MOVF   72,W
36EC:  CALL   15B6
....................                putc(TxD_Buff[2]) ;               //Byte Count 
36F0:  MOVF   73,W
36F2:  CALL   15B6
....................                putc(TxD_Buff[3]) ; 
36F6:  MOVF   74,W
36F8:  CALL   15B6
....................                putc(TxD_Buff[4]) ; 
36FC:  MOVF   75,W
36FE:  CALL   15B6
....................                putc(TxD_Buff[5]) ; 
3702:  MOVF   76,W
3704:  CALL   15B6
....................                putc(TxD_Buff[6]) ; 
3708:  MOVF   77,W
370A:  CALL   15B6
....................                putc(TxD_Buff[7]) ; 
370E:  MOVF   78,W
3710:  CALL   15B6
....................                //putc(TxD_Buff[8]) ; 
....................                //putc(TxD_Buff[9]) ; 
....................  
....................                restart_wdt(); 
3714:  CLRWDT
....................                delay_ms(3); 
3716:  MOVLW  03
3718:  MOVLB  1
371A:  MOVWF  xEF
371C:  MOVLB  0
371E:  CALL   05BE
....................                restart_wdt(); 
3722:  CLRWDT
....................                output_bit(P485ctrl,0); 
3724:  BCF    F8A.3
3726:  BCF    F93.3
....................  
....................  
....................                //save_addr(); 
....................             } 
....................          } 
3728:  GOTO   3F62
....................          //--------------------------------------------------// 
....................           
....................          /* 
....................          else if(RxD_Buff[1] == 0x20)///////////// READ SETTING ///////////////////// 
....................          { 
....................             TxD_Buff[0] = Address ;         //Address 
....................             TxD_Buff[1] = 0x20 ;            //function code 
....................             TxD_Buff[2] = 0x30 ;            //0-48 Byte//Data Byte count 
....................              
....................             TxD_Buff[3] = InputType1_8 ; 
....................             TxD_Buff[4] = InputType9_16 ; 
....................             TxD_Buff[5] = InputType17_24 ; 
....................              
....................             TxD_Buff[6] = FaultType1_8 ; 
....................             TxD_Buff[7] = FaultType9_16 ; 
....................             TxD_Buff[8] = FaultType17_24 ; 
....................              
....................             TxD_Buff[9] = OutputType1_8 ; 
....................             TxD_Buff[10] = OutputType9_16 ; 
....................             TxD_Buff[11] = OutputType17_24 ; 
....................              
....................             TxD_Buff[12] = OutputBoth1_8 ; 
....................             TxD_Buff[13] = OutputBoth9_16 ; 
....................             TxD_Buff[14] = OutputBoth17_24 ; 
....................             
....................             TxD_Buff[15] = Alarm_Indicator1_8 ; 
....................             TxD_Buff[16] = Alarm_Indicator9_16 ; 
....................             TxD_Buff[17] = Alarm_Indicator17_24 ; 
....................             
....................             TxD_Buff[18] = Red1_8; 
....................             TxD_Buff[19] = Red9_10; 
....................             TxD_Buff[20] = Red11_18; 
....................             TxD_Buff[21] = Red19_20; 
....................             TxD_Buff[22] = Green1_8; 
....................             TxD_Buff[23] = Green9_10; 
....................             TxD_Buff[24] = Green11_18; 
....................             TxD_Buff[25] = Green19_20; 
....................           
....................           
....................             TxD_Buff[26] = AutoAck ; 
....................             TxD_Buff[27] = AutoAckTime ; 
....................             TxD_Buff[28] = FlashingRate ; 
....................             TxD_Buff[29] = NoOfPoint ; 
....................             TxD_Buff[30] = FaultDelayTime[0] ; 
....................             TxD_Buff[31] = Address ; 
....................              
....................             TxD_Buff[32] = FaultDelayTime[1] ; 
....................             TxD_Buff[33] = FaultDelayTime[2] ; 
....................             TxD_Buff[34] = FaultDelayTime[3] ; 
....................             TxD_Buff[35] = FaultDelayTime[4] ; 
....................             TxD_Buff[36] = FaultDelayTime[5] ; 
....................             TxD_Buff[37] = FaultDelayTime[6] ; 
....................             TxD_Buff[38] = FaultDelayTime[7] ; 
....................             TxD_Buff[39] = FaultDelayTime[8] ; 
....................             TxD_Buff[40] = FaultDelayTime[9] ; 
....................             TxD_Buff[41] = FaultDelayTime[10] ; 
....................             TxD_Buff[42] = FaultDelayTime[11] ; 
....................             TxD_Buff[43] = FaultDelayTime[12] ; 
....................             TxD_Buff[44] = FaultDelayTime[13] ; 
....................             TxD_Buff[45] = FaultDelayTime[14] ; 
....................             TxD_Buff[46] = FaultDelayTime[15] ; 
....................             TxD_Buff[47] = FaultDelayTime[16] ; 
....................             TxD_Buff[48] = FaultDelayTime[17] ; 
....................             TxD_Buff[49] = FaultDelayTime[18] ; 
....................             TxD_Buff[50] = FaultDelayTime[19] ; 
....................             TxD_Buff[51] = FaultDelayTime[20] ; 
....................              
....................              
....................             CRC(TxD_Buff,52)   ; //Cal CRC 49 byte 
....................  
....................             TxD_Buff[52] = CRC_Hi ; 
....................             TxD_Buff[53] = CRC_Lo ; 
....................  
....................             output_bit(P485ctrl,1); 
....................             delay_ms(10); 
....................  
....................             putc(Txd_Buff[0]); 
....................             putc(Txd_Buff[1]); 
....................             putc(Txd_Buff[2]); 
....................             putc(Txd_Buff[3]); 
....................             putc(Txd_Buff[4]); 
....................             putc(Txd_Buff[5]); 
....................             putc(Txd_Buff[6]); 
....................             putc(Txd_Buff[7]); 
....................             putc(Txd_Buff[8]); 
....................             putc(Txd_Buff[9]); 
....................             putc(Txd_Buff[10]); 
....................             putc(Txd_Buff[11]); 
....................             putc(Txd_Buff[12]); 
....................             putc(Txd_Buff[13]); 
....................             putc(Txd_Buff[14]); 
....................             putc(Txd_Buff[15]); 
....................             putc(Txd_Buff[16]); 
....................             putc(Txd_Buff[17]); 
....................             putc(Txd_Buff[18]); 
....................             putc(Txd_Buff[19]); 
....................             putc(Txd_Buff[20]); 
....................             putc(Txd_Buff[21]); 
....................             putc(Txd_Buff[22]); 
....................             putc(Txd_Buff[23]); 
....................             putc(Txd_Buff[24]); 
....................             putc(Txd_Buff[25]); 
....................             putc(Txd_Buff[26]); 
....................             putc(Txd_Buff[27]); 
....................             putc(Txd_Buff[28]); 
....................             putc(Txd_Buff[29]); 
....................             putc(Txd_Buff[30]); 
....................             putc(Txd_Buff[31]); 
....................              
....................             putc(Txd_Buff[32]); 
....................             putc(Txd_Buff[33]); 
....................             putc(Txd_Buff[34]); 
....................             putc(Txd_Buff[35]); 
....................             putc(Txd_Buff[36]); 
....................             putc(Txd_Buff[37]); 
....................             putc(Txd_Buff[38]); 
....................             putc(Txd_Buff[39]); 
....................             putc(Txd_Buff[40]); 
....................             putc(Txd_Buff[41]); 
....................              
....................             putc(Txd_Buff[42]); 
....................             putc(Txd_Buff[43]); 
....................             putc(Txd_Buff[44]); 
....................             putc(Txd_Buff[45]); 
....................             putc(Txd_Buff[46]); 
....................             putc(Txd_Buff[47]); 
....................             putc(Txd_Buff[48]); 
....................             putc(Txd_Buff[49]); 
....................             putc(Txd_Buff[50]); 
....................             putc(Txd_Buff[51]); 
....................              
....................             putc(Txd_Buff[52]); 
....................             putc(Txd_Buff[53]); 
....................            
....................             delay_ms(3); 
....................             output_bit(P485ctrl,0); 
....................          } 
....................          */ 
....................          else if(RxD_Buff[1] == 0x21)///////////// WRITE SETTING ///////////////////// 
372C:  MOVF   xAE,W
372E:  SUBLW  21
3730:  BTFSS  FD8.2
3732:  GOTO   3F62
....................          { 
....................  
....................             write_eeprom(0x00,0x0F); 
3736:  MOVF   FF2,W
3738:  MOVWF  00
373A:  BCF    FF2.7
373C:  CLRF   FA9
373E:  MOVLW  0F
3740:  MOVWF  FA8
3742:  BCF    FA6.6
3744:  BCF    FA6.7
3746:  BSF    FA6.2
3748:  MOVLB  F
374A:  MOVLW  55
374C:  MOVWF  FA7
374E:  MOVLW  AA
3750:  MOVWF  FA7
3752:  BSF    FA6.1
3754:  BTFSC  FA6.1
3756:  BRA    3754
3758:  BCF    FA6.2
375A:  MOVF   00,W
375C:  IORWF  FF2,F
....................  
....................             write_eeprom(0x01,RxD_Buff[3]);   //Inputt Type 
375E:  MOVFF  FF2,00
3762:  BCF    FF2.7
3764:  MOVLW  01
3766:  MOVWF  FA9
3768:  MOVFF  B0,FA8
376C:  BCF    FA6.6
376E:  BCF    FA6.7
3770:  BSF    FA6.2
3772:  MOVLW  55
3774:  MOVWF  FA7
3776:  MOVLW  AA
3778:  MOVWF  FA7
377A:  BSF    FA6.1
377C:  BTFSC  FA6.1
377E:  BRA    377C
3780:  BCF    FA6.2
3782:  MOVF   00,W
3784:  IORWF  FF2,F
....................             write_eeprom(0x02,RxD_Buff[4]); 
3786:  MOVFF  FF2,00
378A:  BCF    FF2.7
378C:  MOVLW  02
378E:  MOVWF  FA9
3790:  MOVFF  B1,FA8
3794:  BCF    FA6.6
3796:  BCF    FA6.7
3798:  BSF    FA6.2
379A:  MOVLW  55
379C:  MOVWF  FA7
379E:  MOVLW  AA
37A0:  MOVWF  FA7
37A2:  BSF    FA6.1
37A4:  BTFSC  FA6.1
37A6:  BRA    37A4
37A8:  BCF    FA6.2
37AA:  MOVF   00,W
37AC:  IORWF  FF2,F
....................             write_eeprom(0x03,RxD_Buff[5]); 
37AE:  MOVFF  FF2,00
37B2:  BCF    FF2.7
37B4:  MOVLW  03
37B6:  MOVWF  FA9
37B8:  MOVFF  B2,FA8
37BC:  BCF    FA6.6
37BE:  BCF    FA6.7
37C0:  BSF    FA6.2
37C2:  MOVLW  55
37C4:  MOVWF  FA7
37C6:  MOVLW  AA
37C8:  MOVWF  FA7
37CA:  BSF    FA6.1
37CC:  BTFSC  FA6.1
37CE:  BRA    37CC
37D0:  BCF    FA6.2
37D2:  MOVF   00,W
37D4:  IORWF  FF2,F
....................            // write_eeprom(0x04,RxD_Buff[6]); 
....................            // write_eeprom(0x05,RxD_Buff[7]); 
....................            // write_eeprom(0x06,RxD_Buff[8]); 
....................            // write_eeprom(0x07,RxD_Buff[9]); 
....................            // write_eeprom(0x08,RxD_Buff[10]); 
....................  
....................             write_eeprom(0x04,RxD_Buff[6]);   //Fault Type 
37D6:  MOVFF  FF2,00
37DA:  BCF    FF2.7
37DC:  MOVLW  04
37DE:  MOVWF  FA9
37E0:  MOVFF  B3,FA8
37E4:  BCF    FA6.6
37E6:  BCF    FA6.7
37E8:  BSF    FA6.2
37EA:  MOVLW  55
37EC:  MOVWF  FA7
37EE:  MOVLW  AA
37F0:  MOVWF  FA7
37F2:  BSF    FA6.1
37F4:  BTFSC  FA6.1
37F6:  BRA    37F4
37F8:  BCF    FA6.2
37FA:  MOVF   00,W
37FC:  IORWF  FF2,F
....................             write_eeprom(0x05,RxD_Buff[7]); 
37FE:  MOVFF  FF2,00
3802:  BCF    FF2.7
3804:  MOVLW  05
3806:  MOVWF  FA9
3808:  MOVFF  B4,FA8
380C:  BCF    FA6.6
380E:  BCF    FA6.7
3810:  BSF    FA6.2
3812:  MOVLW  55
3814:  MOVWF  FA7
3816:  MOVLW  AA
3818:  MOVWF  FA7
381A:  BSF    FA6.1
381C:  BTFSC  FA6.1
381E:  BRA    381C
3820:  BCF    FA6.2
3822:  MOVF   00,W
3824:  IORWF  FF2,F
....................             write_eeprom(0x06,RxD_Buff[8]); 
3826:  MOVFF  FF2,00
382A:  BCF    FF2.7
382C:  MOVLW  06
382E:  MOVWF  FA9
3830:  MOVFF  B5,FA8
3834:  BCF    FA6.6
3836:  BCF    FA6.7
3838:  BSF    FA6.2
383A:  MOVLW  55
383C:  MOVWF  FA7
383E:  MOVLW  AA
3840:  MOVWF  FA7
3842:  BSF    FA6.1
3844:  BTFSC  FA6.1
3846:  BRA    3844
3848:  BCF    FA6.2
384A:  MOVF   00,W
384C:  IORWF  FF2,F
....................             //write_eeprom(0x0C,RxD_Buff[14]); 
....................            // write_eeprom(0x0D,RxD_Buff[15]); 
....................             //write_eeprom(0x0E,RxD_Buff[16]); 
....................            // write_eeprom(0x0F,RxD_Buff[17]); 
....................            // write_eeprom(0x10,RxD_Buff[18]); 
....................  
....................             write_eeprom(0x07,RxD_Buff[9]);   //Output Type 
384E:  MOVFF  FF2,00
3852:  BCF    FF2.7
3854:  MOVLW  07
3856:  MOVWF  FA9
3858:  MOVFF  B6,FA8
385C:  BCF    FA6.6
385E:  BCF    FA6.7
3860:  BSF    FA6.2
3862:  MOVLW  55
3864:  MOVWF  FA7
3866:  MOVLW  AA
3868:  MOVWF  FA7
386A:  BSF    FA6.1
386C:  BTFSC  FA6.1
386E:  BRA    386C
3870:  BCF    FA6.2
3872:  MOVF   00,W
3874:  IORWF  FF2,F
....................             write_eeprom(0x08,RxD_Buff[10]); 
3876:  MOVFF  FF2,00
387A:  BCF    FF2.7
387C:  MOVLW  08
387E:  MOVWF  FA9
3880:  MOVFF  B7,FA8
3884:  BCF    FA6.6
3886:  BCF    FA6.7
3888:  BSF    FA6.2
388A:  MOVLW  55
388C:  MOVWF  FA7
388E:  MOVLW  AA
3890:  MOVWF  FA7
3892:  BSF    FA6.1
3894:  BTFSC  FA6.1
3896:  BRA    3894
3898:  BCF    FA6.2
389A:  MOVF   00,W
389C:  IORWF  FF2,F
....................             write_eeprom(0x09,RxD_Buff[11]); 
389E:  MOVFF  FF2,00
38A2:  BCF    FF2.7
38A4:  MOVLW  09
38A6:  MOVWF  FA9
38A8:  MOVFF  B8,FA8
38AC:  BCF    FA6.6
38AE:  BCF    FA6.7
38B0:  BSF    FA6.2
38B2:  MOVLW  55
38B4:  MOVWF  FA7
38B6:  MOVLW  AA
38B8:  MOVWF  FA7
38BA:  BSF    FA6.1
38BC:  BTFSC  FA6.1
38BE:  BRA    38BC
38C0:  BCF    FA6.2
38C2:  MOVF   00,W
38C4:  IORWF  FF2,F
....................            // write_eeprom(0x14,RxD_Buff[22]); 
....................            // write_eeprom(0x15,RxD_Buff[23]); 
....................           //  write_eeprom(0x16,RxD_Buff[24]); 
....................            // write_eeprom(0x17,RxD_Buff[25]); 
....................            // write_eeprom(0x18,RxD_Buff[26]); 
....................  
....................             write_eeprom(0x0A,RxD_Buff[12]);   //Output Both 
38C6:  MOVFF  FF2,00
38CA:  BCF    FF2.7
38CC:  MOVLW  0A
38CE:  MOVWF  FA9
38D0:  MOVFF  B9,FA8
38D4:  BCF    FA6.6
38D6:  BCF    FA6.7
38D8:  BSF    FA6.2
38DA:  MOVLW  55
38DC:  MOVWF  FA7
38DE:  MOVLW  AA
38E0:  MOVWF  FA7
38E2:  BSF    FA6.1
38E4:  BTFSC  FA6.1
38E6:  BRA    38E4
38E8:  BCF    FA6.2
38EA:  MOVF   00,W
38EC:  IORWF  FF2,F
....................             write_eeprom(0x0B,RxD_Buff[13]); 
38EE:  MOVFF  FF2,00
38F2:  BCF    FF2.7
38F4:  MOVLW  0B
38F6:  MOVWF  FA9
38F8:  MOVFF  BA,FA8
38FC:  BCF    FA6.6
38FE:  BCF    FA6.7
3900:  BSF    FA6.2
3902:  MOVLW  55
3904:  MOVWF  FA7
3906:  MOVLW  AA
3908:  MOVWF  FA7
390A:  BSF    FA6.1
390C:  BTFSC  FA6.1
390E:  BRA    390C
3910:  BCF    FA6.2
3912:  MOVF   00,W
3914:  IORWF  FF2,F
....................             write_eeprom(0x0C,RxD_Buff[14]); 
3916:  MOVFF  FF2,00
391A:  BCF    FF2.7
391C:  MOVLW  0C
391E:  MOVWF  FA9
3920:  MOVFF  BB,FA8
3924:  BCF    FA6.6
3926:  BCF    FA6.7
3928:  BSF    FA6.2
392A:  MOVLW  55
392C:  MOVWF  FA7
392E:  MOVLW  AA
3930:  MOVWF  FA7
3932:  BSF    FA6.1
3934:  BTFSC  FA6.1
3936:  BRA    3934
3938:  BCF    FA6.2
393A:  MOVF   00,W
393C:  IORWF  FF2,F
....................            // write_eeprom(0x1C,RxD_Buff[30]); 
....................            // write_eeprom(0x1D,RxD_Buff[31]); 
....................            // write_eeprom(0x1E,RxD_Buff[32]); 
....................            // write_eeprom(0x1F,RxD_Buff[33]); 
....................            // write_eeprom(0x20,RxD_Buff[34]); 
....................  
....................             write_eeprom(0x0D,RxD_Buff[15]);   //Alarm / Indicator 
393E:  MOVFF  FF2,00
3942:  BCF    FF2.7
3944:  MOVLW  0D
3946:  MOVWF  FA9
3948:  MOVFF  BC,FA8
394C:  BCF    FA6.6
394E:  BCF    FA6.7
3950:  BSF    FA6.2
3952:  MOVLW  55
3954:  MOVWF  FA7
3956:  MOVLW  AA
3958:  MOVWF  FA7
395A:  BSF    FA6.1
395C:  BTFSC  FA6.1
395E:  BRA    395C
3960:  BCF    FA6.2
3962:  MOVF   00,W
3964:  IORWF  FF2,F
....................             write_eeprom(0x0E,RxD_Buff[16]); 
3966:  MOVFF  FF2,00
396A:  BCF    FF2.7
396C:  MOVLW  0E
396E:  MOVWF  FA9
3970:  MOVFF  BD,FA8
3974:  BCF    FA6.6
3976:  BCF    FA6.7
3978:  BSF    FA6.2
397A:  MOVLW  55
397C:  MOVWF  FA7
397E:  MOVLW  AA
3980:  MOVWF  FA7
3982:  BSF    FA6.1
3984:  BTFSC  FA6.1
3986:  BRA    3984
3988:  BCF    FA6.2
398A:  MOVF   00,W
398C:  IORWF  FF2,F
....................             write_eeprom(0x0F,RxD_Buff[17]); 
398E:  MOVFF  FF2,00
3992:  BCF    FF2.7
3994:  MOVLW  0F
3996:  MOVWF  FA9
3998:  MOVFF  BE,FA8
399C:  BCF    FA6.6
399E:  BCF    FA6.7
39A0:  BSF    FA6.2
39A2:  MOVLW  55
39A4:  MOVWF  FA7
39A6:  MOVLW  AA
39A8:  MOVWF  FA7
39AA:  BSF    FA6.1
39AC:  BTFSC  FA6.1
39AE:  BRA    39AC
39B0:  BCF    FA6.2
39B2:  MOVF   00,W
39B4:  IORWF  FF2,F
....................            // write_eeprom(0x24,RxD_Buff[38]); 
....................            // write_eeprom(0x25,RxD_Buff[39]); 
....................            // write_eeprom(0x26,RxD_Buff[40]); 
....................            // write_eeprom(0x27,RxD_Buff[41]); 
....................            // write_eeprom(0x28,RxD_Buff[42]); 
....................           
....................             // LED Colour Config 
....................             write_eeprom(0x10,RxD_Buff[18]); //Red1_8 
39B6:  MOVFF  FF2,00
39BA:  BCF    FF2.7
39BC:  MOVLW  10
39BE:  MOVWF  FA9
39C0:  MOVFF  BF,FA8
39C4:  BCF    FA6.6
39C6:  BCF    FA6.7
39C8:  BSF    FA6.2
39CA:  MOVLW  55
39CC:  MOVWF  FA7
39CE:  MOVLW  AA
39D0:  MOVWF  FA7
39D2:  BSF    FA6.1
39D4:  BTFSC  FA6.1
39D6:  BRA    39D4
39D8:  BCF    FA6.2
39DA:  MOVF   00,W
39DC:  IORWF  FF2,F
....................             write_eeprom(0x11,RxD_Buff[19]); //Red9_10 
39DE:  MOVFF  FF2,00
39E2:  BCF    FF2.7
39E4:  MOVLW  11
39E6:  MOVWF  FA9
39E8:  MOVFF  C0,FA8
39EC:  BCF    FA6.6
39EE:  BCF    FA6.7
39F0:  BSF    FA6.2
39F2:  MOVLW  55
39F4:  MOVWF  FA7
39F6:  MOVLW  AA
39F8:  MOVWF  FA7
39FA:  BSF    FA6.1
39FC:  BTFSC  FA6.1
39FE:  BRA    39FC
3A00:  BCF    FA6.2
3A02:  MOVF   00,W
3A04:  IORWF  FF2,F
....................             write_eeprom(0x12,RxD_Buff[20]); //Red11_18 
3A06:  MOVFF  FF2,00
3A0A:  BCF    FF2.7
3A0C:  MOVLW  12
3A0E:  MOVWF  FA9
3A10:  MOVFF  C1,FA8
3A14:  BCF    FA6.6
3A16:  BCF    FA6.7
3A18:  BSF    FA6.2
3A1A:  MOVLW  55
3A1C:  MOVWF  FA7
3A1E:  MOVLW  AA
3A20:  MOVWF  FA7
3A22:  BSF    FA6.1
3A24:  BTFSC  FA6.1
3A26:  BRA    3A24
3A28:  BCF    FA6.2
3A2A:  MOVF   00,W
3A2C:  IORWF  FF2,F
....................             write_eeprom(0x13,RxD_Buff[21]); //Red19_20 
3A2E:  MOVFF  FF2,00
3A32:  BCF    FF2.7
3A34:  MOVLW  13
3A36:  MOVWF  FA9
3A38:  MOVFF  C2,FA8
3A3C:  BCF    FA6.6
3A3E:  BCF    FA6.7
3A40:  BSF    FA6.2
3A42:  MOVLW  55
3A44:  MOVWF  FA7
3A46:  MOVLW  AA
3A48:  MOVWF  FA7
3A4A:  BSF    FA6.1
3A4C:  BTFSC  FA6.1
3A4E:  BRA    3A4C
3A50:  BCF    FA6.2
3A52:  MOVF   00,W
3A54:  IORWF  FF2,F
....................             write_eeprom(0x14,RxD_Buff[22]); //Green1_8 
3A56:  MOVFF  FF2,00
3A5A:  BCF    FF2.7
3A5C:  MOVLW  14
3A5E:  MOVWF  FA9
3A60:  MOVFF  C3,FA8
3A64:  BCF    FA6.6
3A66:  BCF    FA6.7
3A68:  BSF    FA6.2
3A6A:  MOVLW  55
3A6C:  MOVWF  FA7
3A6E:  MOVLW  AA
3A70:  MOVWF  FA7
3A72:  BSF    FA6.1
3A74:  BTFSC  FA6.1
3A76:  BRA    3A74
3A78:  BCF    FA6.2
3A7A:  MOVF   00,W
3A7C:  IORWF  FF2,F
....................             write_eeprom(0x15,RxD_Buff[23]); //Green9_10 
3A7E:  MOVFF  FF2,00
3A82:  BCF    FF2.7
3A84:  MOVLW  15
3A86:  MOVWF  FA9
3A88:  MOVFF  C4,FA8
3A8C:  BCF    FA6.6
3A8E:  BCF    FA6.7
3A90:  BSF    FA6.2
3A92:  MOVLW  55
3A94:  MOVWF  FA7
3A96:  MOVLW  AA
3A98:  MOVWF  FA7
3A9A:  BSF    FA6.1
3A9C:  BTFSC  FA6.1
3A9E:  BRA    3A9C
3AA0:  BCF    FA6.2
3AA2:  MOVF   00,W
3AA4:  IORWF  FF2,F
....................             write_eeprom(0x16,RxD_Buff[24]); //Green11_18 
3AA6:  MOVFF  FF2,00
3AAA:  BCF    FF2.7
3AAC:  MOVLW  16
3AAE:  MOVWF  FA9
3AB0:  MOVFF  C5,FA8
3AB4:  BCF    FA6.6
3AB6:  BCF    FA6.7
3AB8:  BSF    FA6.2
3ABA:  MOVLW  55
3ABC:  MOVWF  FA7
3ABE:  MOVLW  AA
3AC0:  MOVWF  FA7
3AC2:  BSF    FA6.1
3AC4:  BTFSC  FA6.1
3AC6:  BRA    3AC4
3AC8:  BCF    FA6.2
3ACA:  MOVF   00,W
3ACC:  IORWF  FF2,F
....................             write_eeprom(0x17,RxD_Buff[25]); //Green19_20 
3ACE:  MOVFF  FF2,00
3AD2:  BCF    FF2.7
3AD4:  MOVLW  17
3AD6:  MOVWF  FA9
3AD8:  MOVFF  C6,FA8
3ADC:  BCF    FA6.6
3ADE:  BCF    FA6.7
3AE0:  BSF    FA6.2
3AE2:  MOVLW  55
3AE4:  MOVWF  FA7
3AE6:  MOVLW  AA
3AE8:  MOVWF  FA7
3AEA:  BSF    FA6.1
3AEC:  BTFSC  FA6.1
3AEE:  BRA    3AEC
3AF0:  BCF    FA6.2
3AF2:  MOVF   00,W
3AF4:  IORWF  FF2,F
....................                 
....................             write_eeprom(0x18,RxD_Buff[26]);   //Auto acknowledge 
3AF6:  MOVFF  FF2,00
3AFA:  BCF    FF2.7
3AFC:  MOVLW  18
3AFE:  MOVWF  FA9
3B00:  MOVFF  C7,FA8
3B04:  BCF    FA6.6
3B06:  BCF    FA6.7
3B08:  BSF    FA6.2
3B0A:  MOVLW  55
3B0C:  MOVWF  FA7
3B0E:  MOVLW  AA
3B10:  MOVWF  FA7
3B12:  BSF    FA6.1
3B14:  BTFSC  FA6.1
3B16:  BRA    3B14
3B18:  BCF    FA6.2
3B1A:  MOVF   00,W
3B1C:  IORWF  FF2,F
....................             write_eeprom(0x19,RxD_Buff[27]);   //Auto acknowledge Time 
3B1E:  MOVFF  FF2,00
3B22:  BCF    FF2.7
3B24:  MOVLW  19
3B26:  MOVWF  FA9
3B28:  MOVFF  C8,FA8
3B2C:  BCF    FA6.6
3B2E:  BCF    FA6.7
3B30:  BSF    FA6.2
3B32:  MOVLW  55
3B34:  MOVWF  FA7
3B36:  MOVLW  AA
3B38:  MOVWF  FA7
3B3A:  BSF    FA6.1
3B3C:  BTFSC  FA6.1
3B3E:  BRA    3B3C
3B40:  BCF    FA6.2
3B42:  MOVF   00,W
3B44:  IORWF  FF2,F
....................             write_eeprom(0x1A,RxD_Buff[28]);   //Flashing Rate 
3B46:  MOVFF  FF2,00
3B4A:  BCF    FF2.7
3B4C:  MOVLW  1A
3B4E:  MOVWF  FA9
3B50:  MOVFF  C9,FA8
3B54:  BCF    FA6.6
3B56:  BCF    FA6.7
3B58:  BSF    FA6.2
3B5A:  MOVLW  55
3B5C:  MOVWF  FA7
3B5E:  MOVLW  AA
3B60:  MOVWF  FA7
3B62:  BSF    FA6.1
3B64:  BTFSC  FA6.1
3B66:  BRA    3B64
3B68:  BCF    FA6.2
3B6A:  MOVF   00,W
3B6C:  IORWF  FF2,F
....................             write_eeprom(0x1B,RxD_Buff[29]);   //No of point 
3B6E:  MOVFF  FF2,00
3B72:  BCF    FF2.7
3B74:  MOVLW  1B
3B76:  MOVWF  FA9
3B78:  MOVFF  CA,FA8
3B7C:  BCF    FA6.6
3B7E:  BCF    FA6.7
3B80:  BSF    FA6.2
3B82:  MOVLW  55
3B84:  MOVWF  FA7
3B86:  MOVLW  AA
3B88:  MOVWF  FA7
3B8A:  BSF    FA6.1
3B8C:  BTFSC  FA6.1
3B8E:  BRA    3B8C
3B90:  BCF    FA6.2
3B92:  MOVF   00,W
3B94:  IORWF  FF2,F
....................             write_eeprom(0x1C,RxD_Buff[30]);   //FaultDelayTime 
3B96:  MOVFF  FF2,00
3B9A:  BCF    FF2.7
3B9C:  MOVLW  1C
3B9E:  MOVWF  FA9
3BA0:  MOVFF  CB,FA8
3BA4:  BCF    FA6.6
3BA6:  BCF    FA6.7
3BA8:  BSF    FA6.2
3BAA:  MOVLW  55
3BAC:  MOVWF  FA7
3BAE:  MOVLW  AA
3BB0:  MOVWF  FA7
3BB2:  BSF    FA6.1
3BB4:  BTFSC  FA6.1
3BB6:  BRA    3BB4
3BB8:  BCF    FA6.2
3BBA:  MOVF   00,W
3BBC:  IORWF  FF2,F
....................             write_eeprom(0x1D,RxD_Buff[31]);   //Communication Address 
3BBE:  MOVFF  FF2,00
3BC2:  BCF    FF2.7
3BC4:  MOVLW  1D
3BC6:  MOVWF  FA9
3BC8:  MOVFF  CC,FA8
3BCC:  BCF    FA6.6
3BCE:  BCF    FA6.7
3BD0:  BSF    FA6.2
3BD2:  MOVLW  55
3BD4:  MOVWF  FA7
3BD6:  MOVLW  AA
3BD8:  MOVWF  FA7
3BDA:  BSF    FA6.1
3BDC:  BTFSC  FA6.1
3BDE:  BRA    3BDC
3BE0:  BCF    FA6.2
3BE2:  MOVF   00,W
3BE4:  IORWF  FF2,F
....................              
....................             write_eeprom(0x1E,RxD_Buff[32]);   //Communication Address 
3BE6:  MOVFF  FF2,00
3BEA:  BCF    FF2.7
3BEC:  MOVLW  1E
3BEE:  MOVWF  FA9
3BF0:  MOVFF  CD,FA8
3BF4:  BCF    FA6.6
3BF6:  BCF    FA6.7
3BF8:  BSF    FA6.2
3BFA:  MOVLW  55
3BFC:  MOVWF  FA7
3BFE:  MOVLW  AA
3C00:  MOVWF  FA7
3C02:  BSF    FA6.1
3C04:  BTFSC  FA6.1
3C06:  BRA    3C04
3C08:  BCF    FA6.2
3C0A:  MOVF   00,W
3C0C:  IORWF  FF2,F
....................             write_eeprom(0x1F,RxD_Buff[33]);   //Communication Address 
3C0E:  MOVFF  FF2,00
3C12:  BCF    FF2.7
3C14:  MOVLW  1F
3C16:  MOVWF  FA9
3C18:  MOVFF  CE,FA8
3C1C:  BCF    FA6.6
3C1E:  BCF    FA6.7
3C20:  BSF    FA6.2
3C22:  MOVLW  55
3C24:  MOVWF  FA7
3C26:  MOVLW  AA
3C28:  MOVWF  FA7
3C2A:  BSF    FA6.1
3C2C:  BTFSC  FA6.1
3C2E:  BRA    3C2C
3C30:  BCF    FA6.2
3C32:  MOVF   00,W
3C34:  IORWF  FF2,F
....................             write_eeprom(0x20,RxD_Buff[34]);   //Communication Address 
3C36:  MOVFF  FF2,00
3C3A:  BCF    FF2.7
3C3C:  MOVLW  20
3C3E:  MOVWF  FA9
3C40:  MOVFF  CF,FA8
3C44:  BCF    FA6.6
3C46:  BCF    FA6.7
3C48:  BSF    FA6.2
3C4A:  MOVLW  55
3C4C:  MOVWF  FA7
3C4E:  MOVLW  AA
3C50:  MOVWF  FA7
3C52:  BSF    FA6.1
3C54:  BTFSC  FA6.1
3C56:  BRA    3C54
3C58:  BCF    FA6.2
3C5A:  MOVF   00,W
3C5C:  IORWF  FF2,F
....................             write_eeprom(0x21,RxD_Buff[35]);   //Communication Address 
3C5E:  MOVFF  FF2,00
3C62:  BCF    FF2.7
3C64:  MOVLW  21
3C66:  MOVWF  FA9
3C68:  MOVFF  D0,FA8
3C6C:  BCF    FA6.6
3C6E:  BCF    FA6.7
3C70:  BSF    FA6.2
3C72:  MOVLW  55
3C74:  MOVWF  FA7
3C76:  MOVLW  AA
3C78:  MOVWF  FA7
3C7A:  BSF    FA6.1
3C7C:  BTFSC  FA6.1
3C7E:  BRA    3C7C
3C80:  BCF    FA6.2
3C82:  MOVF   00,W
3C84:  IORWF  FF2,F
....................             write_eeprom(0x22,RxD_Buff[36]);   //Communication Address 
3C86:  MOVFF  FF2,00
3C8A:  BCF    FF2.7
3C8C:  MOVLW  22
3C8E:  MOVWF  FA9
3C90:  MOVFF  D1,FA8
3C94:  BCF    FA6.6
3C96:  BCF    FA6.7
3C98:  BSF    FA6.2
3C9A:  MOVLW  55
3C9C:  MOVWF  FA7
3C9E:  MOVLW  AA
3CA0:  MOVWF  FA7
3CA2:  BSF    FA6.1
3CA4:  BTFSC  FA6.1
3CA6:  BRA    3CA4
3CA8:  BCF    FA6.2
3CAA:  MOVF   00,W
3CAC:  IORWF  FF2,F
....................             write_eeprom(0x23,RxD_Buff[37]);   //Communication Address 
3CAE:  MOVFF  FF2,00
3CB2:  BCF    FF2.7
3CB4:  MOVLW  23
3CB6:  MOVWF  FA9
3CB8:  MOVFF  D2,FA8
3CBC:  BCF    FA6.6
3CBE:  BCF    FA6.7
3CC0:  BSF    FA6.2
3CC2:  MOVLW  55
3CC4:  MOVWF  FA7
3CC6:  MOVLW  AA
3CC8:  MOVWF  FA7
3CCA:  BSF    FA6.1
3CCC:  BTFSC  FA6.1
3CCE:  BRA    3CCC
3CD0:  BCF    FA6.2
3CD2:  MOVF   00,W
3CD4:  IORWF  FF2,F
....................             write_eeprom(0x24,RxD_Buff[38]);   //Communication Address 
3CD6:  MOVFF  FF2,00
3CDA:  BCF    FF2.7
3CDC:  MOVLW  24
3CDE:  MOVWF  FA9
3CE0:  MOVFF  D3,FA8
3CE4:  BCF    FA6.6
3CE6:  BCF    FA6.7
3CE8:  BSF    FA6.2
3CEA:  MOVLW  55
3CEC:  MOVWF  FA7
3CEE:  MOVLW  AA
3CF0:  MOVWF  FA7
3CF2:  BSF    FA6.1
3CF4:  BTFSC  FA6.1
3CF6:  BRA    3CF4
3CF8:  BCF    FA6.2
3CFA:  MOVF   00,W
3CFC:  IORWF  FF2,F
....................             write_eeprom(0x25,RxD_Buff[39]);   //Communication Address 
3CFE:  MOVFF  FF2,00
3D02:  BCF    FF2.7
3D04:  MOVLW  25
3D06:  MOVWF  FA9
3D08:  MOVFF  D4,FA8
3D0C:  BCF    FA6.6
3D0E:  BCF    FA6.7
3D10:  BSF    FA6.2
3D12:  MOVLW  55
3D14:  MOVWF  FA7
3D16:  MOVLW  AA
3D18:  MOVWF  FA7
3D1A:  BSF    FA6.1
3D1C:  BTFSC  FA6.1
3D1E:  BRA    3D1C
3D20:  BCF    FA6.2
3D22:  MOVF   00,W
3D24:  IORWF  FF2,F
....................             write_eeprom(0x26,RxD_Buff[40]);   //Communication Address 
3D26:  MOVFF  FF2,00
3D2A:  BCF    FF2.7
3D2C:  MOVLW  26
3D2E:  MOVWF  FA9
3D30:  MOVFF  D5,FA8
3D34:  BCF    FA6.6
3D36:  BCF    FA6.7
3D38:  BSF    FA6.2
3D3A:  MOVLW  55
3D3C:  MOVWF  FA7
3D3E:  MOVLW  AA
3D40:  MOVWF  FA7
3D42:  BSF    FA6.1
3D44:  BTFSC  FA6.1
3D46:  BRA    3D44
3D48:  BCF    FA6.2
3D4A:  MOVF   00,W
3D4C:  IORWF  FF2,F
....................             write_eeprom(0x27,RxD_Buff[41]);   //Communication Address 
3D4E:  MOVFF  FF2,00
3D52:  BCF    FF2.7
3D54:  MOVLW  27
3D56:  MOVWF  FA9
3D58:  MOVFF  D6,FA8
3D5C:  BCF    FA6.6
3D5E:  BCF    FA6.7
3D60:  BSF    FA6.2
3D62:  MOVLW  55
3D64:  MOVWF  FA7
3D66:  MOVLW  AA
3D68:  MOVWF  FA7
3D6A:  BSF    FA6.1
3D6C:  BTFSC  FA6.1
3D6E:  BRA    3D6C
3D70:  BCF    FA6.2
3D72:  MOVF   00,W
3D74:  IORWF  FF2,F
....................             write_eeprom(0x28,RxD_Buff[42]);   //Communication Address 
3D76:  MOVFF  FF2,00
3D7A:  BCF    FF2.7
3D7C:  MOVLW  28
3D7E:  MOVWF  FA9
3D80:  MOVFF  D7,FA8
3D84:  BCF    FA6.6
3D86:  BCF    FA6.7
3D88:  BSF    FA6.2
3D8A:  MOVLW  55
3D8C:  MOVWF  FA7
3D8E:  MOVLW  AA
3D90:  MOVWF  FA7
3D92:  BSF    FA6.1
3D94:  BTFSC  FA6.1
3D96:  BRA    3D94
3D98:  BCF    FA6.2
3D9A:  MOVF   00,W
3D9C:  IORWF  FF2,F
....................             write_eeprom(0x29,RxD_Buff[43]);   //Communication Address 
3D9E:  MOVFF  FF2,00
3DA2:  BCF    FF2.7
3DA4:  MOVLW  29
3DA6:  MOVWF  FA9
3DA8:  MOVFF  D8,FA8
3DAC:  BCF    FA6.6
3DAE:  BCF    FA6.7
3DB0:  BSF    FA6.2
3DB2:  MOVLW  55
3DB4:  MOVWF  FA7
3DB6:  MOVLW  AA
3DB8:  MOVWF  FA7
3DBA:  BSF    FA6.1
3DBC:  BTFSC  FA6.1
3DBE:  BRA    3DBC
3DC0:  BCF    FA6.2
3DC2:  MOVF   00,W
3DC4:  IORWF  FF2,F
....................             write_eeprom(0x2A,RxD_Buff[44]);   //Communication Address 
3DC6:  MOVFF  FF2,00
3DCA:  BCF    FF2.7
3DCC:  MOVLW  2A
3DCE:  MOVWF  FA9
3DD0:  MOVFF  D9,FA8
3DD4:  BCF    FA6.6
3DD6:  BCF    FA6.7
3DD8:  BSF    FA6.2
3DDA:  MOVLW  55
3DDC:  MOVWF  FA7
3DDE:  MOVLW  AA
3DE0:  MOVWF  FA7
3DE2:  BSF    FA6.1
3DE4:  BTFSC  FA6.1
3DE6:  BRA    3DE4
3DE8:  BCF    FA6.2
3DEA:  MOVF   00,W
3DEC:  IORWF  FF2,F
....................             write_eeprom(0x2B,RxD_Buff[45]);   //Communication Address 
3DEE:  MOVFF  FF2,00
3DF2:  BCF    FF2.7
3DF4:  MOVLW  2B
3DF6:  MOVWF  FA9
3DF8:  MOVFF  DA,FA8
3DFC:  BCF    FA6.6
3DFE:  BCF    FA6.7
3E00:  BSF    FA6.2
3E02:  MOVLW  55
3E04:  MOVWF  FA7
3E06:  MOVLW  AA
3E08:  MOVWF  FA7
3E0A:  BSF    FA6.1
3E0C:  BTFSC  FA6.1
3E0E:  BRA    3E0C
3E10:  BCF    FA6.2
3E12:  MOVF   00,W
3E14:  IORWF  FF2,F
....................             write_eeprom(0x2C,RxD_Buff[46]);   //Communication Address 
3E16:  MOVFF  FF2,00
3E1A:  BCF    FF2.7
3E1C:  MOVLW  2C
3E1E:  MOVWF  FA9
3E20:  MOVFF  DB,FA8
3E24:  BCF    FA6.6
3E26:  BCF    FA6.7
3E28:  BSF    FA6.2
3E2A:  MOVLW  55
3E2C:  MOVWF  FA7
3E2E:  MOVLW  AA
3E30:  MOVWF  FA7
3E32:  BSF    FA6.1
3E34:  BTFSC  FA6.1
3E36:  BRA    3E34
3E38:  BCF    FA6.2
3E3A:  MOVF   00,W
3E3C:  IORWF  FF2,F
....................             write_eeprom(0x2D,RxD_Buff[47]);   //Communication Address 
3E3E:  MOVFF  FF2,00
3E42:  BCF    FF2.7
3E44:  MOVLW  2D
3E46:  MOVWF  FA9
3E48:  MOVFF  DC,FA8
3E4C:  BCF    FA6.6
3E4E:  BCF    FA6.7
3E50:  BSF    FA6.2
3E52:  MOVLW  55
3E54:  MOVWF  FA7
3E56:  MOVLW  AA
3E58:  MOVWF  FA7
3E5A:  BSF    FA6.1
3E5C:  BTFSC  FA6.1
3E5E:  BRA    3E5C
3E60:  BCF    FA6.2
3E62:  MOVF   00,W
3E64:  IORWF  FF2,F
....................             write_eeprom(0x2E,RxD_Buff[48]);   //Communication Address 
3E66:  MOVFF  FF2,00
3E6A:  BCF    FF2.7
3E6C:  MOVLW  2E
3E6E:  MOVWF  FA9
3E70:  MOVFF  DD,FA8
3E74:  BCF    FA6.6
3E76:  BCF    FA6.7
3E78:  BSF    FA6.2
3E7A:  MOVLW  55
3E7C:  MOVWF  FA7
3E7E:  MOVLW  AA
3E80:  MOVWF  FA7
3E82:  BSF    FA6.1
3E84:  BTFSC  FA6.1
3E86:  BRA    3E84
3E88:  BCF    FA6.2
3E8A:  MOVF   00,W
3E8C:  IORWF  FF2,F
....................             write_eeprom(0x2F,RxD_Buff[49]);   //Communication Address 
3E8E:  MOVFF  FF2,00
3E92:  BCF    FF2.7
3E94:  MOVLW  2F
3E96:  MOVWF  FA9
3E98:  MOVFF  DE,FA8
3E9C:  BCF    FA6.6
3E9E:  BCF    FA6.7
3EA0:  BSF    FA6.2
3EA2:  MOVLW  55
3EA4:  MOVWF  FA7
3EA6:  MOVLW  AA
3EA8:  MOVWF  FA7
3EAA:  BSF    FA6.1
3EAC:  BTFSC  FA6.1
3EAE:  BRA    3EAC
3EB0:  BCF    FA6.2
3EB2:  MOVF   00,W
3EB4:  IORWF  FF2,F
....................             write_eeprom(0x30,RxD_Buff[50]);   //Communication Address 
3EB6:  MOVFF  FF2,00
3EBA:  BCF    FF2.7
3EBC:  MOVLW  30
3EBE:  MOVWF  FA9
3EC0:  MOVFF  DF,FA8
3EC4:  BCF    FA6.6
3EC6:  BCF    FA6.7
3EC8:  BSF    FA6.2
3ECA:  MOVLW  55
3ECC:  MOVWF  FA7
3ECE:  MOVLW  AA
3ED0:  MOVWF  FA7
3ED2:  BSF    FA6.1
3ED4:  BTFSC  FA6.1
3ED6:  BRA    3ED4
3ED8:  BCF    FA6.2
3EDA:  MOVF   00,W
3EDC:  IORWF  FF2,F
....................             write_eeprom(0x31,RxD_Buff[51]);   //Communication Address 
3EDE:  MOVFF  FF2,00
3EE2:  BCF    FF2.7
3EE4:  MOVLW  31
3EE6:  MOVWF  FA9
3EE8:  MOVFF  E0,FA8
3EEC:  BCF    FA6.6
3EEE:  BCF    FA6.7
3EF0:  BSF    FA6.2
3EF2:  MOVLW  55
3EF4:  MOVWF  FA7
3EF6:  MOVLW  AA
3EF8:  MOVWF  FA7
3EFA:  BSF    FA6.1
3EFC:  BTFSC  FA6.1
3EFE:  BRA    3EFC
3F00:  BCF    FA6.2
3F02:  MOVF   00,W
3F04:  IORWF  FF2,F
....................           
....................           
....................             TxD_Buff[0] = Address ;         //Address 
3F06:  MOVFF  6F,71
....................             TxD_Buff[1] = 0x21 ;            //return function code 
3F0A:  MOVLW  21
3F0C:  MOVWF  72
....................  
....................             CRC(TxD_Buff,2)   ;            //Cal CRC 2 byte 
3F0E:  MOVLB  1
3F10:  CLRF   xE9
3F12:  MOVLW  71
3F14:  MOVWF  xE8
3F16:  MOVLW  02
3F18:  MOVWF  xEA
3F1A:  MOVLB  0
3F1C:  CALL   1566
....................  
....................             TxD_Buff[2] = CRC_Hi ; 
3F20:  MOVFF  EA,73
....................             TxD_Buff[3] = CRC_Lo ; 
3F24:  MOVFF  E9,74
....................  
....................             output_bit(P485ctrl,1); 
3F28:  BSF    F8A.3
3F2A:  BCF    F93.3
....................             delay_ms(10); 
3F2C:  MOVLW  0A
3F2E:  MOVLB  1
3F30:  MOVWF  xEF
3F32:  MOVLB  0
3F34:  CALL   05BE
....................  
....................             putc(Txd_Buff[0]); 
3F38:  MOVF   71,W
3F3A:  CALL   15B6
....................             putc(Txd_Buff[1]); 
3F3E:  MOVF   72,W
3F40:  CALL   15B6
....................             putc(Txd_Buff[2]); 
3F44:  MOVF   73,W
3F46:  CALL   15B6
....................             putc(Txd_Buff[3]); 
3F4A:  MOVF   74,W
3F4C:  CALL   15B6
....................  
....................             delay_ms(3); 
3F50:  MOVLW  03
3F52:  MOVLB  1
3F54:  MOVWF  xEF
3F56:  MOVLB  0
3F58:  CALL   05BE
....................             output_bit(P485ctrl,0); 
3F5C:  BCF    F8A.3
3F5E:  BCF    F93.3
....................              
....................             reset_cpu(); 
3F60:  RESET
....................             //Read_Config(); //jj 
....................          } 
....................  
....................           
....................                   if(RxD_Buff[1] == 0x03)///////////// READ HOLDING REGGISTER ///////////////////// 
3F62:  MOVF   xAE,W
3F64:  SUBLW  03
3F66:  BNZ   400C
....................          { 
....................             Data_Buff[0] = Input9_16; //>> Start_Address ; 
3F68:  MOVFF  4D,F2
....................             Data_Buff[1] = Input1_8;// >> Start_Address ; 
3F6C:  MOVFF  49,F3
....................             Data_Buff[2] = Input25_32; 
3F70:  MOVFF  4F,F4
....................             Data_Buff[3] = Input17_24;// >> Start_Address ; 
3F74:  MOVFF  4E,F5
....................              
....................             TxD_Buff[0] = Address ;         //Address 
3F78:  MOVFF  6F,71
....................             TxD_Buff[1] = 0x03 ;           //Function Code 
3F7C:  MOVLW  03
3F7E:  MOVWF  72
....................             TxD_Buff[2] = 0x04 ;          //Byte Count 
3F80:  MOVLW  04
3F82:  MOVWF  73
....................             TxD_Buff[3] = Data_Buff[0];   //first byte Data 
3F84:  MOVFF  F2,74
....................             TxD_Buff[4] = Data_Buff[1];  //second byte Data 
3F88:  MOVFF  F3,75
....................             TxD_Buff[5] = Data_Buff[2];  
3F8C:  MOVFF  F4,76
....................             TxD_Buff[6] = Data_Buff[3];  
3F90:  MOVFF  F5,77
....................  
....................             CRC(TxD_Buff,7)   ;            //Cal CRC 5 Byte 
3F94:  MOVLB  1
3F96:  CLRF   xE9
3F98:  MOVLW  71
3F9A:  MOVWF  xE8
3F9C:  MOVLW  07
3F9E:  MOVWF  xEA
3FA0:  MOVLB  0
3FA2:  CALL   1566
....................  
....................             TxD_Buff[7] = CRC_Hi ; 
3FA6:  MOVFF  EA,78
....................             TxD_Buff[8] = CRC_Lo ; 
3FAA:  MOVFF  E9,79
....................  
....................             //TxD_DataLen = 0x07 ; 
....................             //rs485_ctrl = 1; 
....................             //dmsec(4); 
....................             //send = 1; 
....................             //TI=1; 
....................             output_bit(P485ctrl,1); 
3FAE:  BSF    F8A.3
3FB0:  BCF    F93.3
....................             restart_wdt(); 
3FB2:  CLRWDT
....................             delay_ms(4); 
3FB4:  MOVLW  04
3FB6:  MOVLB  1
3FB8:  MOVWF  xEF
3FBA:  MOVLB  0
3FBC:  CALL   05BE
....................             restart_wdt(); 
3FC0:  CLRWDT
....................  
....................             putc(TxD_Buff[0]) ;               //Address 
3FC2:  MOVF   71,W
3FC4:  CALL   15B6
....................             putc(TxD_Buff[1]) ;               //Function Code 
3FC8:  MOVF   72,W
3FCA:  CALL   15B6
....................             putc(TxD_Buff[2]) ;               //Byte Count 
3FCE:  MOVF   73,W
3FD0:  CALL   15B6
....................             putc(TxD_Buff[3]) ; 
3FD4:  MOVF   74,W
3FD6:  CALL   15B6
....................             putc(TxD_Buff[4]) ; 
3FDA:  MOVF   75,W
3FDC:  CALL   15B6
....................             putc(TxD_Buff[5]) ; 
3FE0:  MOVF   76,W
3FE2:  CALL   15B6
....................             putc(TxD_Buff[6]) ; 
3FE6:  MOVF   77,W
3FE8:  CALL   15B6
....................             putc(TxD_Buff[7]) ; 
3FEC:  MOVF   78,W
3FEE:  CALL   15B6
....................             putc(TxD_Buff[8]) ; 
3FF2:  MOVF   79,W
3FF4:  CALL   15B6
....................             //putc(TxD_Buff[9]) ; 
....................  
....................             restart_wdt(); 
3FF8:  CLRWDT
....................             delay_ms(3); 
3FFA:  MOVLW  03
3FFC:  MOVLB  1
3FFE:  MOVWF  xEF
4000:  MOVLB  0
4002:  CALL   05BE
....................             restart_wdt(); 
4006:  CLRWDT
....................             output_bit(P485ctrl,0); 
4008:  BCF    F8A.3
400A:  BCF    F93.3
....................          /* 
....................             //Do Read Holding Register 
....................             Start_Address = RxD_Buff[2] ; 
....................             Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Start Address 16 bit 
....................             No_PointCount = RxD_Buff[4] ; 
....................             No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;      //No. of Point 16 bit 
....................  
....................             if(Start_Address < 0x02 && (Start_Address + No_PointCount) <= 0x03)  //Valid point 0-1 
....................             { 
....................                if(No_PointCount == 1) Data_ByteCount = 0x01 ;         // 1 point 
....................                else if(No_PointCount == 2) Data_ByteCount = 0x02 ;    // 2 point 
....................  
....................                if(Data_ByteCount == 0x01) 
....................                { 
....................                   if(Start_Address == 0x00) 
....................                   { 
....................                       TxD_Buff[0] = Address ;         //Address 
....................                   TxD_Buff[1] = 0x03 ;         //Function Code 
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
....................                   TxD_Buff[5] = Data_Buff[2] ;   
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 5 Byte 
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
....................                   TxD_Buff[7] = CRC_Lo ; 
....................  
....................                   //TxD_DataLen = 0x07 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
....................                   restart_wdt(); 
....................                   delay_ms(4); 
....................                   restart_wdt(); 
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
....................                   putc(TxD_Buff[1]) ;               //Function Code 
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
....................                   putc(TxD_Buff[3]) ; 
....................                   putc(TxD_Buff[4]) ; 
....................                   putc(TxD_Buff[5]) ; 
....................                   putc(TxD_Buff[6]) ; 
....................                   putc(TxD_Buff[7]) ; 
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
....................                   delay_ms(3); 
....................                   restart_wdt(); 
....................                   output_bit(P485ctrl,0); 
....................                   } 
....................                   else if(Start_Address == 0x01) 
....................                   { 
....................                       TxD_Buff[0] = Address ;         //Address 
....................                   TxD_Buff[1] = 0x01 ;         //Function Code 
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
....................                   TxD_Buff[5] = Data_Buff[2] ;   
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 5 Byte 
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
....................                   TxD_Buff[7] = CRC_Lo ; 
....................  
....................                   //TxD_DataLen = 0x07 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
....................                   restart_wdt(); 
....................                   delay_ms(4); 
....................                   restart_wdt(); 
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
....................                   putc(TxD_Buff[1]) ;               //Function Code 
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
....................                   putc(TxD_Buff[3]) ; 
....................                   putc(TxD_Buff[4]) ; 
....................                   putc(TxD_Buff[5]) ; 
....................                   putc(TxD_Buff[6]) ; 
....................                   putc(TxD_Buff[7]) ; 
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
....................                   delay_ms(3); 
....................                   restart_wdt(); 
....................                   output_bit(P485ctrl,0); 
....................                   } 
....................                } 
....................                else if(Data_ByteCount == 0x02) 
....................                { 
....................                   if(Start_Address == 0x00) 
....................                   { 
....................                       TxD_Buff[0] = Address ;         //Address 
....................                   TxD_Buff[1] = 0x03 ;         //Function Code 
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
....................                   TxD_Buff[5] = Data_Buff[2] ;   
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 5 Byte 
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
....................                   TxD_Buff[7] = CRC_Lo ; 
....................  
....................                   //TxD_DataLen = 0x07 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
....................                   restart_wdt(); 
....................                   delay_ms(4); 
....................                   restart_wdt(); 
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
....................                   putc(TxD_Buff[1]) ;               //Function Code 
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
....................                   putc(TxD_Buff[3]) ; 
....................                   putc(TxD_Buff[4]) ; 
....................                   putc(TxD_Buff[5]) ; 
....................                   putc(TxD_Buff[6]) ; 
....................                   putc(TxD_Buff[7]) ; 
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
....................                   delay_ms(3); 
....................                   restart_wdt(); 
....................                   output_bit(P485ctrl,0); 
....................                   } 
....................                } 
....................             } 
....................             else 
....................             { 
....................                //invalid parameter 
....................                TxD_Buff[0] = Address ;         //Address 
....................                TxD_Buff[1] = 0x81 ;         //Function Code 
....................                TxD_Buff[2] = 0x02 ;         //illegal data address 
....................  
....................                CRC(TxD_Buff,3)   ;            //Cal CRC 3 Byte 
....................  
....................                TxD_Buff[3] = CRC_Hi ; 
....................                TxD_Buff[4] = CRC_Lo ; 
....................  
....................                output_bit(P485ctrl,1); 
....................                delay_ms(10); 
....................  
....................                putc(Txd_Buff[0]); 
....................                putc(Txd_Buff[1]); 
....................                putc(Txd_Buff[2]); 
....................                putc(Txd_Buff[3]); 
....................                putc(Txd_Buff[4]); 
....................  
....................                delay_ms(3); 
....................                output_bit(P485ctrl,0); 
....................             } 
....................             */ 
....................          } 
....................         
....................        /*-----JACK Comment 18/6/58----------// 
....................          else 
....................          { 
....................             //Invalid function 
....................             TxD_Buff[0] = Address ;         //Address 
....................             TxD_Buff[1] = 0x81 ;         //Function Code 
....................             TxD_Buff[2] = 0x01 ;         //illegal function 
....................  
....................             CRC(TxD_Buff,3)   ;            //Cal CRC 3 Byte 
....................  
....................             TxD_Buff[3] = CRC_Hi ; 
....................             TxD_Buff[4] = CRC_Lo ; 
....................  
....................             output_bit(P485ctrl,1); 
....................             delay_ms(10); 
....................  
....................             putc(Txd_Buff[0]); 
....................             putc(Txd_Buff[1]); 
....................             putc(Txd_Buff[2]); 
....................             putc(Txd_Buff[3]); 
....................             putc(Txd_Buff[4]); 
....................  
....................             delay_ms(3); 
....................             output_bit(P485ctrl,0); 
....................          } 
....................        *///-----JACK Comment----------// 
....................       }   
....................  
....................       Send_check_Time = 500; //5 Second 
400C:  MOVLW  01
400E:  MOVWF  xEC
4010:  MOVLW  F4
4012:  MOVWF  xEB
....................    } 
....................  
....................    recieve_completed = 0 ; 
4014:  BCF    30.5
....................    sequence = end_sq ; 
4016:  MOVFF  66,6E
....................    T_timeout = 0x00; 
401A:  MOVLB  1
401C:  CLRF   x12
....................    RxD_DataLen = 0x00 ; 
401E:  CLRF   70
....................    output_bit(P485ctrl,0); 
4020:  BCF    F8A.3
4022:  BCF    F93.3
4024:  MOVLB  0
4026:  GOTO   7D0A (RETURN)
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////// 
....................  
.................... void Read_Input(void) 
.................... { 
....................  
....................     ///////////////////////--Edit--/////////////////// 
....................     //unsigned char MCP23s17_dat1=0; 
....................     //unsigned char MCP23s17_dat2=0; 
....................     //unsigned char MCP23s17_dat3=0; 
....................     //unsigned char MCP23s17_dat4=0; 
....................      
....................     /* 
....................     MCP23s17_dat1 = IO_INPUT_A(IO_DEVICE_0); 
....................     MCP23s17_dat2 = IO_INPUT_B(IO_DEVICE_0); 
....................     MCP23s17_dat3 = IO_INPUT_A(IO_DEVICE_1); 
....................     MCP23s17_dat4 = IO_INPUT_B(IO_DEVICE_1); 
....................     if((MCP23s17_dat1==0)&&(MCP23s17_dat2==0)&&(MCP23s17_dat3==0)&&(MCP23s17_dat4==0)) 
....................      return; 
....................      */ 
....................     /* 
....................     do 
....................     { 
....................       MCP23s17_dat1 = IO_INPUT_A(IO_DEVICE_0); 
....................       //MCP23s17_dat2 = IO_INPUT_B(IO_DEVICE_0); 
....................       MCP23s17_dat3 = IO_INPUT_A(IO_DEVICE_1); 
....................       //MCP23s17_dat4 = IO_INPUT_B(IO_DEVICE_1); 
....................       restart_wdt(); 
....................     }while((MCP23s17_dat1==0)&&(MCP23s17_dat3==0)); 
....................     */ 
....................       
....................       MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_0); 
*
1AAA:  MOVLB  1
1AAC:  CLRF   xE8
1AAE:  MOVLB  0
1AB0:  RCALL  19F4
1AB2:  MOVFF  01,110
....................          
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
1AB6:  BTFSS  1A.4
1AB8:  BRA    1AC0
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat;          
1ABA:  MOVLB  1
1ABC:  COMF   x10,F
1ABE:  MOVLB  0
....................       } 
....................        
....................       FaultNow[11] = MCP23s17_Ip_dat; 
1AC0:  MOVLB  1
1AC2:  BCF    x52.3
1AC4:  BTFSC  x10.0
1AC6:  BSF    x52.3
....................       FaultNow[12] = MCP23s17_Ip_dat >> 1; 
1AC8:  BCF    FD8.0
1ACA:  RRCF   x10,W
1ACC:  BCF    x52.4
1ACE:  BTFSC  FE8.0
1AD0:  BSF    x52.4
....................       FaultNow[13] = MCP23s17_Ip_dat >> 2; 
1AD2:  RRCF   x10,W
1AD4:  MOVWF  00
1AD6:  RRCF   00,F
1AD8:  MOVLW  3F
1ADA:  ANDWF  00,F
1ADC:  BCF    x52.5
1ADE:  BTFSC  00.0
1AE0:  BSF    x52.5
....................       FaultNow[14] = MCP23s17_Ip_dat >> 3; 
1AE2:  RRCF   x10,W
1AE4:  MOVWF  00
1AE6:  RRCF   00,F
1AE8:  RRCF   00,F
1AEA:  MOVLW  1F
1AEC:  ANDWF  00,F
1AEE:  BCF    x52.6
1AF0:  BTFSC  00.0
1AF2:  BSF    x52.6
....................       FaultNow[15] = MCP23s17_Ip_dat >> 4; 
1AF4:  SWAPF  x10,W
1AF6:  MOVWF  00
1AF8:  MOVLW  0F
1AFA:  ANDWF  00,F
1AFC:  BCF    x52.7
1AFE:  BTFSC  00.0
1B00:  BSF    x52.7
....................       FaultNow[16] = MCP23s17_Ip_dat >> 5; 
1B02:  SWAPF  x10,W
1B04:  MOVWF  00
1B06:  RRCF   00,F
1B08:  MOVLW  07
1B0A:  ANDWF  00,F
1B0C:  BCF    x53.0
1B0E:  BTFSC  00.0
1B10:  BSF    x53.0
....................       FaultNow[17] = MCP23s17_Ip_dat >> 6; 
1B12:  SWAPF  x10,W
1B14:  MOVWF  00
1B16:  RRCF   00,F
1B18:  RRCF   00,F
1B1A:  MOVLW  03
1B1C:  ANDWF  00,F
1B1E:  BCF    x53.1
1B20:  BTFSC  00.0
1B22:  BSF    x53.1
....................       FaultNow[18] = MCP23s17_Ip_dat >> 7; 
1B24:  CLRF   00
1B26:  BTFSC  x10.7
1B28:  BSF    00.0
1B2A:  BCF    x53.2
1B2C:  BTFSC  00.0
1B2E:  BSF    x53.2
....................        
....................       MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_0); 
1B30:  CLRF   xE8
1B32:  MOVLB  0
1B34:  RCALL  1A10
1B36:  MOVFF  01,110
....................        
....................        
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
1B3A:  BTFSS  1A.4
1B3C:  BRA    1B44
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
1B3E:  MOVLB  1
1B40:  COMF   x10,F
1B42:  MOVLB  0
....................       } 
....................        
....................       FaultNow[19] = MCP23s17_Ip_dat; 
1B44:  MOVLB  1
1B46:  BCF    x53.3
1B48:  BTFSC  x10.0
1B4A:  BSF    x53.3
....................       FaultNow[20] = MCP23s17_Ip_dat >> 1; 
1B4C:  BCF    FD8.0
1B4E:  RRCF   x10,W
1B50:  BCF    x53.4
1B52:  BTFSC  FE8.0
1B54:  BSF    x53.4
....................        
....................        
....................       MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_1); 
1B56:  MOVLW  02
1B58:  MOVWF  xE8
1B5A:  MOVLB  0
1B5C:  RCALL  19F4
1B5E:  MOVFF  01,110
....................        
....................            
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
1B62:  BTFSS  1A.4
1B64:  BRA    1B6C
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
1B66:  MOVLB  1
1B68:  COMF   x10,F
1B6A:  MOVLB  0
....................           
....................       } 
....................        
....................       FaultNow[1] = MCP23s17_Ip_dat; 
1B6C:  MOVLB  1
1B6E:  BCF    x51.1
1B70:  BTFSC  x10.0
1B72:  BSF    x51.1
....................       FaultNow[2] = MCP23s17_Ip_dat >> 1; 
1B74:  BCF    FD8.0
1B76:  RRCF   x10,W
1B78:  BCF    x51.2
1B7A:  BTFSC  FE8.0
1B7C:  BSF    x51.2
....................       FaultNow[3] = MCP23s17_Ip_dat >> 2; 
1B7E:  RRCF   x10,W
1B80:  MOVWF  00
1B82:  RRCF   00,F
1B84:  MOVLW  3F
1B86:  ANDWF  00,F
1B88:  BCF    x51.3
1B8A:  BTFSC  00.0
1B8C:  BSF    x51.3
....................       FaultNow[4] = MCP23s17_Ip_dat >> 3; 
1B8E:  RRCF   x10,W
1B90:  MOVWF  00
1B92:  RRCF   00,F
1B94:  RRCF   00,F
1B96:  MOVLW  1F
1B98:  ANDWF  00,F
1B9A:  BCF    x51.4
1B9C:  BTFSC  00.0
1B9E:  BSF    x51.4
....................       FaultNow[5] = MCP23s17_Ip_dat >> 4; 
1BA0:  SWAPF  x10,W
1BA2:  MOVWF  00
1BA4:  MOVLW  0F
1BA6:  ANDWF  00,F
1BA8:  BCF    x51.5
1BAA:  BTFSC  00.0
1BAC:  BSF    x51.5
....................       FaultNow[6] = MCP23s17_Ip_dat >> 5; 
1BAE:  SWAPF  x10,W
1BB0:  MOVWF  00
1BB2:  RRCF   00,F
1BB4:  MOVLW  07
1BB6:  ANDWF  00,F
1BB8:  BCF    x51.6
1BBA:  BTFSC  00.0
1BBC:  BSF    x51.6
....................       FaultNow[7] = MCP23s17_Ip_dat >> 6; 
1BBE:  SWAPF  x10,W
1BC0:  MOVWF  00
1BC2:  RRCF   00,F
1BC4:  RRCF   00,F
1BC6:  MOVLW  03
1BC8:  ANDWF  00,F
1BCA:  BCF    x51.7
1BCC:  BTFSC  00.0
1BCE:  BSF    x51.7
....................       FaultNow[8] = MCP23s17_Ip_dat >> 7; 
1BD0:  CLRF   00
1BD2:  BTFSC  x10.7
1BD4:  BSF    00.0
1BD6:  BCF    x52.0
1BD8:  BTFSC  00.0
1BDA:  BSF    x52.0
....................        
....................       MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_1); 
1BDC:  MOVLW  02
1BDE:  MOVWF  xE8
1BE0:  MOVLB  0
1BE2:  RCALL  1A10
1BE4:  MOVFF  01,110
....................        
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
1BE8:  BTFSS  1A.4
1BEA:  BRA    1BF2
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
1BEC:  MOVLB  1
1BEE:  COMF   x10,F
1BF0:  MOVLB  0
....................       } 
....................        
....................       FaultNow[9] = MCP23s17_Ip_dat; 
1BF2:  MOVLB  1
1BF4:  BCF    x52.1
1BF6:  BTFSC  x10.0
1BF8:  BSF    x52.1
....................       FaultNow[10] = MCP23s17_Ip_dat >> 1; 
1BFA:  BCF    FD8.0
1BFC:  RRCF   x10,W
1BFE:  BCF    x52.2
1C00:  BTFSC  FE8.0
1C02:  BSF    x52.2
....................        
....................       ///////////////---Anal Fault---////////////////// 
....................       unsigned char i; 
....................       for( i=1; i<=20; i++) 
1C04:  MOVLW  01
1C06:  MOVWF  xE7
1C08:  MOVF   xE7,W
1C0A:  SUBLW  14
1C0C:  BTFSS  FD8.0
1C0E:  BRA    21E2
....................       { 
....................          if(FaultNCNO[i] ==NO) 
1C10:  MOVFF  1E7,1EB
1C14:  MOVLW  01
1C16:  MOVWF  xED
1C18:  MOVLW  CD
1C1A:  MOVWF  xEC
1C1C:  MOVLB  0
1C1E:  RCALL  1530
1C20:  MOVF   01,W
1C22:  ANDLW  01
1C24:  SUBLW  01
1C26:  BTFSS  FD8.2
1C28:  BRA    1EF2
....................          { 
....................              if(FaultNow[i]==0) 
1C2A:  MOVFF  1E7,1EB
1C2E:  MOVLW  01
1C30:  MOVLB  1
1C32:  MOVWF  xED
1C34:  MOVLW  51
1C36:  MOVWF  xEC
1C38:  MOVLB  0
1C3A:  RCALL  1530
1C3C:  MOVF   01,W
1C3E:  ANDLW  01
1C40:  BTFSS  FD8.2
1C42:  BRA    1D9A
....................              {    
....................                if(FaultAgo[i]==0) 
1C44:  MOVFF  1E7,1EB
1C48:  MOVLW  01
1C4A:  MOVLB  1
1C4C:  MOVWF  xED
1C4E:  MOVLW  4D
1C50:  MOVWF  xEC
1C52:  MOVLB  0
1C54:  RCALL  1530
1C56:  MOVF   01,W
1C58:  ANDLW  01
1C5A:  BTFSS  FD8.2
1C5C:  BRA    1D7E
....................                { 
....................                    ReleaseTime[i]++; 
1C5E:  BCF    FD8.0
1C60:  MOVLB  1
1C62:  RLCF   xE7,W
1C64:  CLRF   03
1C66:  ADDLW  55
1C68:  MOVWF  FE9
1C6A:  MOVLW  01
1C6C:  ADDWFC 03,W
1C6E:  MOVWF  FEA
1C70:  MOVLW  01
1C72:  ADDWF  FEE,F
1C74:  BNC   1C78
1C76:  INCF   FEF,F
....................                    
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms) 
1C78:  BCF    FD8.0
1C7A:  RLCF   xE7,W
1C7C:  CLRF   03
1C7E:  ADDLW  55
1C80:  MOVWF  FE9
1C82:  MOVLW  01
1C84:  ADDWFC 03,W
1C86:  MOVWF  FEA
1C88:  MOVFF  FEC,1E9
1C8C:  MOVF   FED,F
1C8E:  MOVFF  FEF,1E8
1C92:  BCF    FD8.0
1C94:  RLCF   xE7,W
1C96:  CLRF   03
1C98:  ADDLW  91
1C9A:  MOVWF  FE9
1C9C:  MOVLW  01
1C9E:  ADDWFC 03,W
1CA0:  MOVWF  FEA
1CA2:  MOVFF  FEC,1ED
1CA6:  MOVF   FED,F
1CA8:  MOVFF  FEF,1EC
1CAC:  CLRF   xEF
1CAE:  MOVLW  4B
1CB0:  MOVWF  xEE
1CB2:  MOVLB  0
1CB4:  RCALL  1A2C
1CB6:  MOVFF  02,1EB
1CBA:  MOVFF  01,1EA
1CBE:  MOVLW  0F
1CC0:  MOVLB  1
1CC2:  ADDWF  01,W
1CC4:  MOVWF  01
1CC6:  MOVLW  00
1CC8:  ADDWFC 02,W
1CCA:  MOVWF  03
1CCC:  MOVF   03,W
1CCE:  SUBWF  xE9,W
1CD0:  BNC   1D7A
1CD2:  BNZ   1CDA
1CD4:  MOVF   01,W
1CD6:  SUBWF  xE8,W
1CD8:  BNC   1D7A
....................                    {    
....................                      ReleaseTime[i] = 0; 
1CDA:  BCF    FD8.0
1CDC:  RLCF   xE7,W
1CDE:  CLRF   03
1CE0:  ADDLW  55
1CE2:  MOVWF  FE9
1CE4:  MOVLW  01
1CE6:  ADDWFC 03,W
1CE8:  MOVWF  FEA
1CEA:  CLRF   FEC
1CEC:  MOVF   FED,F
1CEE:  CLRF   FEF
....................                      switch(i) 
1CF0:  MOVLW  01
1CF2:  SUBWF  xE7,W
1CF4:  ADDLW  EC
1CF6:  BC    1D7A
1CF8:  ADDLW  14
1CFA:  MOVLB  0
1CFC:  GOTO   240E
....................                      { 
....................                         case 1: 
....................                            Inputt.B1 = 0;  
1D00:  MOVLB  1
1D02:  BCF    x15.0
....................                         break; 
1D04:  BRA    1D7A
....................                         case 2: 
....................                            Inputt.B2 = 0;  
1D06:  MOVLB  1
1D08:  BCF    x15.1
....................                         break; 
1D0A:  BRA    1D7A
....................                         case 3: 
....................                            Inputt.B3 = 0;  
1D0C:  MOVLB  1
1D0E:  BCF    x15.2
....................                         break; 
1D10:  BRA    1D7A
....................                         case 4: 
....................                            Inputt.B4 = 0;  
1D12:  MOVLB  1
1D14:  BCF    x15.3
....................                         break; 
1D16:  BRA    1D7A
....................                         case 5: 
....................                            Inputt.B5 = 0;  
1D18:  MOVLB  1
1D1A:  BCF    x15.4
....................                         break; 
1D1C:  BRA    1D7A
....................                         case 6: 
....................                            Inputt.B6 = 0;  
1D1E:  MOVLB  1
1D20:  BCF    x15.5
....................                         break; 
1D22:  BRA    1D7A
....................                         case 7: 
....................                            Inputt.B7 = 0;  
1D24:  MOVLB  1
1D26:  BCF    x15.6
....................                          break; 
1D28:  BRA    1D7A
....................                          case 8: 
....................                            Inputt.B8 = 0;  
1D2A:  MOVLB  1
1D2C:  BCF    x15.7
....................                         break; 
1D2E:  BRA    1D7A
....................                         case 9: 
....................                            Inputt.B9 = 0;  
1D30:  MOVLB  1
1D32:  BCF    x16.0
....................                         break; 
1D34:  BRA    1D7A
....................                         case 10: 
....................                            Inputt.B10 = 0;  
1D36:  MOVLB  1
1D38:  BCF    x16.1
....................                         break; 
1D3A:  BRA    1D7A
....................                         case 11: 
....................                            Inputt.B11 = 0;  
1D3C:  MOVLB  1
1D3E:  BCF    x16.2
....................                         break; 
1D40:  BRA    1D7A
....................                         case 12: 
....................                            Inputt.B12 = 0;  
1D42:  MOVLB  1
1D44:  BCF    x16.3
....................                         break; 
1D46:  BRA    1D7A
....................                         case 13: 
....................                            Inputt.B13 = 0;  
1D48:  MOVLB  1
1D4A:  BCF    x16.4
....................                         break; 
1D4C:  BRA    1D7A
....................                         case 14: 
....................                            Inputt.B14 = 0;  
1D4E:  MOVLB  1
1D50:  BCF    x16.5
....................                         break; 
1D52:  BRA    1D7A
....................                         case 15: 
....................                            Inputt.B15 = 0;  
1D54:  MOVLB  1
1D56:  BCF    x16.6
....................                         break; 
1D58:  BRA    1D7A
....................                         case 16: 
....................                             Inputt.B16 = 0;  
1D5A:  MOVLB  1
1D5C:  BCF    x16.7
....................                          break;  
1D5E:  BRA    1D7A
....................                         case 17: 
....................                            Inputt.B17 = 0;  
1D60:  MOVLB  1
1D62:  BCF    x17.0
....................                          break; 
1D64:  BRA    1D7A
....................                          case 18: 
....................                            Inputt.B18 = 0;  
1D66:  MOVLB  1
1D68:  BCF    x17.1
....................                         break; 
1D6A:  BRA    1D7A
....................                         case 19: 
....................                            Inputt.B19 = 0;  
1D6C:  MOVLB  1
1D6E:  BCF    x17.2
....................                         break; 
1D70:  BRA    1D7A
....................                         case 20: 
....................                            Inputt.B20 = 0;  
1D72:  MOVLB  1
1D74:  BCF    x17.3
....................                         break; 
1D76:  BRA    1D7A
1D78:  MOVLB  1
....................                                     
....................                      }                  
....................                    } 
....................                } 
1D7A:  BRA    1D96
1D7C:  MOVLB  0
....................                else 
....................                { 
....................                   ReleaseTime[i] = 0; 
1D7E:  BCF    FD8.0
1D80:  MOVLB  1
1D82:  RLCF   xE7,W
1D84:  CLRF   03
1D86:  ADDLW  55
1D88:  MOVWF  FE9
1D8A:  MOVLW  01
1D8C:  ADDWFC 03,W
1D8E:  MOVWF  FEA
1D90:  CLRF   FEC
1D92:  MOVF   FED,F
1D94:  CLRF   FEF
....................                } 
....................              } 
1D96:  BRA    1EF0
1D98:  MOVLB  0
....................              else //if(FaultNow[i]==1 
....................              { 
....................                if(FaultAgo[i]==1) 
1D9A:  MOVFF  1E7,1EB
1D9E:  MOVLW  01
1DA0:  MOVLB  1
1DA2:  MOVWF  xED
1DA4:  MOVLW  4D
1DA6:  MOVWF  xEC
1DA8:  MOVLB  0
1DAA:  CALL   1530
1DAE:  MOVF   01,W
1DB0:  ANDLW  01
1DB2:  SUBLW  01
1DB4:  BTFSS  FD8.2
1DB6:  BRA    1ED8
....................                { 
....................                    ReleaseTime[i]++; 
1DB8:  BCF    FD8.0
1DBA:  MOVLB  1
1DBC:  RLCF   xE7,W
1DBE:  CLRF   03
1DC0:  ADDLW  55
1DC2:  MOVWF  FE9
1DC4:  MOVLW  01
1DC6:  ADDWFC 03,W
1DC8:  MOVWF  FEA
1DCA:  MOVLW  01
1DCC:  ADDWF  FEE,F
1DCE:  BNC   1DD2
1DD0:  INCF   FEF,F
....................                    
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms) 
1DD2:  BCF    FD8.0
1DD4:  RLCF   xE7,W
1DD6:  CLRF   03
1DD8:  ADDLW  55
1DDA:  MOVWF  FE9
1DDC:  MOVLW  01
1DDE:  ADDWFC 03,W
1DE0:  MOVWF  FEA
1DE2:  MOVFF  FEC,1E9
1DE6:  MOVF   FED,F
1DE8:  MOVFF  FEF,1E8
1DEC:  BCF    FD8.0
1DEE:  RLCF   xE7,W
1DF0:  CLRF   03
1DF2:  ADDLW  91
1DF4:  MOVWF  FE9
1DF6:  MOVLW  01
1DF8:  ADDWFC 03,W
1DFA:  MOVWF  FEA
1DFC:  MOVFF  FEC,1ED
1E00:  MOVF   FED,F
1E02:  MOVFF  FEF,1EC
1E06:  CLRF   xEF
1E08:  MOVLW  4B
1E0A:  MOVWF  xEE
1E0C:  MOVLB  0
1E0E:  RCALL  1A2C
1E10:  MOVFF  02,1EB
1E14:  MOVFF  01,1EA
1E18:  MOVLW  0F
1E1A:  MOVLB  1
1E1C:  ADDWF  01,W
1E1E:  MOVWF  01
1E20:  MOVLW  00
1E22:  ADDWFC 02,W
1E24:  MOVWF  03
1E26:  MOVF   03,W
1E28:  SUBWF  xE9,W
1E2A:  BNC   1ED4
1E2C:  BNZ   1E34
1E2E:  MOVF   01,W
1E30:  SUBWF  xE8,W
1E32:  BNC   1ED4
....................                    {    
....................                      ReleaseTime[i] = 1; 
1E34:  BCF    FD8.0
1E36:  RLCF   xE7,W
1E38:  CLRF   03
1E3A:  ADDLW  55
1E3C:  MOVWF  FE9
1E3E:  MOVLW  01
1E40:  ADDWFC 03,W
1E42:  MOVWF  FEA
1E44:  CLRF   FEC
1E46:  MOVF   FED,F
1E48:  MOVLW  01
1E4A:  MOVWF  FEF
....................                      switch(i) 
1E4C:  SUBWF  xE7,W
1E4E:  ADDLW  EC
1E50:  BC    1ED4
1E52:  ADDLW  14
1E54:  MOVLB  0
1E56:  GOTO   2450
....................                      { 
....................                         case 1: 
....................                            Inputt.B1 = 1;  
1E5A:  MOVLB  1
1E5C:  BSF    x15.0
....................                         break; 
1E5E:  BRA    1ED4
....................                         case 2: 
....................                            Inputt.B2 = 1;  
1E60:  MOVLB  1
1E62:  BSF    x15.1
....................                         break; 
1E64:  BRA    1ED4
....................                         case 3: 
....................                            Inputt.B3 = 1;  
1E66:  MOVLB  1
1E68:  BSF    x15.2
....................                         break; 
1E6A:  BRA    1ED4
....................                         case 4: 
....................                            Inputt.B4 = 1;  
1E6C:  MOVLB  1
1E6E:  BSF    x15.3
....................                         break; 
1E70:  BRA    1ED4
....................                         case 5: 
....................                            Inputt.B5 = 1;  
1E72:  MOVLB  1
1E74:  BSF    x15.4
....................                         break; 
1E76:  BRA    1ED4
....................                         case 6: 
....................                            Inputt.B6 = 1;  
1E78:  MOVLB  1
1E7A:  BSF    x15.5
....................                         break; 
1E7C:  BRA    1ED4
....................                         case 7: 
....................                            Inputt.B7 = 1;  
1E7E:  MOVLB  1
1E80:  BSF    x15.6
....................                          break; 
1E82:  BRA    1ED4
....................                          case 8: 
....................                            Inputt.B8 = 1;  
1E84:  MOVLB  1
1E86:  BSF    x15.7
....................                         break; 
1E88:  BRA    1ED4
....................                         case 9: 
....................                            Inputt.B9 = 1;  
1E8A:  MOVLB  1
1E8C:  BSF    x16.0
....................                         break; 
1E8E:  BRA    1ED4
....................                         case 10: 
....................                            Inputt.B10 = 1;  
1E90:  MOVLB  1
1E92:  BSF    x16.1
....................                         break; 
1E94:  BRA    1ED4
....................                         case 11: 
....................                            Inputt.B11 = 1;  
1E96:  MOVLB  1
1E98:  BSF    x16.2
....................                         break; 
1E9A:  BRA    1ED4
....................                         case 12: 
....................                            Inputt.B12 = 1;  
1E9C:  MOVLB  1
1E9E:  BSF    x16.3
....................                         break; 
1EA0:  BRA    1ED4
....................                         case 13: 
....................                            Inputt.B13 = 1;  
1EA2:  MOVLB  1
1EA4:  BSF    x16.4
....................                         break; 
1EA6:  BRA    1ED4
....................                         case 14: 
....................                            Inputt.B14 = 1;  
1EA8:  MOVLB  1
1EAA:  BSF    x16.5
....................                         break; 
1EAC:  BRA    1ED4
....................                         case 15: 
....................                            Inputt.B15 = 1;  
1EAE:  MOVLB  1
1EB0:  BSF    x16.6
....................                         break; 
1EB2:  BRA    1ED4
....................                         case 16: 
....................                             Inputt.B16 = 1; 
1EB4:  MOVLB  1
1EB6:  BSF    x16.7
....................                          break; 
1EB8:  BRA    1ED4
....................                           
....................                          case 17: 
....................                            Inputt.B17 = 1;  
1EBA:  MOVLB  1
1EBC:  BSF    x17.0
....................                          break; 
1EBE:  BRA    1ED4
....................                          case 18: 
....................                            Inputt.B18 = 1;  
1EC0:  MOVLB  1
1EC2:  BSF    x17.1
....................                         break; 
1EC4:  BRA    1ED4
....................                         case 19: 
....................                            Inputt.B19 = 1;  
1EC6:  MOVLB  1
1EC8:  BSF    x17.2
....................                         break; 
1ECA:  BRA    1ED4
....................                         case 20: 
....................                            Inputt.B20 = 1;  
1ECC:  MOVLB  1
1ECE:  BSF    x17.3
....................                         break; 
1ED0:  BRA    1ED4
1ED2:  MOVLB  1
....................                                     
....................                      }                  
....................                    } 
....................                } 
1ED4:  BRA    1EF0
1ED6:  MOVLB  0
....................                else 
....................                { 
....................                   ReleaseTime[i] = 0; 
1ED8:  BCF    FD8.0
1EDA:  MOVLB  1
1EDC:  RLCF   xE7,W
1EDE:  CLRF   03
1EE0:  ADDLW  55
1EE2:  MOVWF  FE9
1EE4:  MOVLW  01
1EE6:  ADDWFC 03,W
1EE8:  MOVWF  FEA
1EEA:  CLRF   FEC
1EEC:  MOVF   FED,F
1EEE:  CLRF   FEF
....................                } 
....................               
....................              /* 
....................                   ReleaseTime[i] = 0; 
....................                   switch(i) 
....................                   { 
....................                       case 1: 
....................                          Input.B1 = 1;  
....................                       break; 
....................                       case 2: 
....................                          Input.B2 = 1;  
....................                       break; 
....................                       case 3: 
....................                          Input.B3 = 1;  
....................                       break; 
....................                       case 4: 
....................                          Input.B4 = 1;  
....................                       break; 
....................                       case 5: 
....................                          Input.B5 = 1;  
....................                       break; 
....................                       case 6: 
....................                          Input.B6 = 1;  
....................                       break; 
....................                       case 7: 
....................                          Input.B7 = 1;  
....................                       break; 
....................                       case 8: 
....................                          Input.B8 = 1;  
....................                       break; 
....................                       case 9: 
....................                          Input.B9 = 1;  
....................                       break; 
....................                       case 10: 
....................                          Input.B10 = 1;  
....................                       break; 
....................                       case 11: 
....................                          Input.B11 = 1;  
....................                       break; 
....................                       case 12: 
....................                          Input.B12 = 1;  
....................                       break; 
....................                       case 13: 
....................                          Input.B13 = 1;  
....................                       break; 
....................                       case 14: 
....................                          Input.B14 = 1;  
....................                       break; 
....................                       case 15: 
....................                          Input.B15 = 1;  
....................                       break; 
....................                       case 16: 
....................                          Input.B16 = 1;  
....................                       break; 
....................                           
....................                   } 
....................                   */ 
....................              } 
....................           } 
1EF0:  BRA    21DA
....................           else if(FaultNCNO[i] ==NC) 
1EF2:  MOVFF  1E7,1EB
1EF6:  MOVLW  01
1EF8:  MOVLB  1
1EFA:  MOVWF  xED
1EFC:  MOVLW  CD
1EFE:  MOVWF  xEC
1F00:  MOVLB  0
1F02:  CALL   1530
1F06:  MOVF   01,W
1F08:  ANDLW  01
1F0A:  BTFSS  FD8.2
1F0C:  BRA    21DC
....................           { 
....................              if(FaultNow[i]==1) 
1F0E:  MOVFF  1E7,1EB
1F12:  MOVLW  01
1F14:  MOVLB  1
1F16:  MOVWF  xED
1F18:  MOVLW  51
1F1A:  MOVWF  xEC
1F1C:  MOVLB  0
1F1E:  CALL   1530
1F22:  MOVF   01,W
1F24:  ANDLW  01
1F26:  SUBLW  01
1F28:  BTFSS  FD8.2
1F2A:  BRA    2086
....................              { 
....................                if(FaultAgo[i]==1) 
1F2C:  MOVFF  1E7,1EB
1F30:  MOVLW  01
1F32:  MOVLB  1
1F34:  MOVWF  xED
1F36:  MOVLW  4D
1F38:  MOVWF  xEC
1F3A:  MOVLB  0
1F3C:  CALL   1530
1F40:  MOVF   01,W
1F42:  ANDLW  01
1F44:  SUBLW  01
1F46:  BTFSS  FD8.2
1F48:  BRA    206A
....................                { 
....................                    ReleaseTime[i]++; 
1F4A:  BCF    FD8.0
1F4C:  MOVLB  1
1F4E:  RLCF   xE7,W
1F50:  CLRF   03
1F52:  ADDLW  55
1F54:  MOVWF  FE9
1F56:  MOVLW  01
1F58:  ADDWFC 03,W
1F5A:  MOVWF  FEA
1F5C:  MOVLW  01
1F5E:  ADDWF  FEE,F
1F60:  BNC   1F64
1F62:  INCF   FEF,F
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms) 
1F64:  BCF    FD8.0
1F66:  RLCF   xE7,W
1F68:  CLRF   03
1F6A:  ADDLW  55
1F6C:  MOVWF  FE9
1F6E:  MOVLW  01
1F70:  ADDWFC 03,W
1F72:  MOVWF  FEA
1F74:  MOVFF  FEC,1E9
1F78:  MOVF   FED,F
1F7A:  MOVFF  FEF,1E8
1F7E:  BCF    FD8.0
1F80:  RLCF   xE7,W
1F82:  CLRF   03
1F84:  ADDLW  91
1F86:  MOVWF  FE9
1F88:  MOVLW  01
1F8A:  ADDWFC 03,W
1F8C:  MOVWF  FEA
1F8E:  MOVFF  FEC,1ED
1F92:  MOVF   FED,F
1F94:  MOVFF  FEF,1EC
1F98:  CLRF   xEF
1F9A:  MOVLW  4B
1F9C:  MOVWF  xEE
1F9E:  MOVLB  0
1FA0:  RCALL  1A2C
1FA2:  MOVFF  02,1EB
1FA6:  MOVFF  01,1EA
1FAA:  MOVLW  0F
1FAC:  MOVLB  1
1FAE:  ADDWF  01,W
1FB0:  MOVWF  01
1FB2:  MOVLW  00
1FB4:  ADDWFC 02,W
1FB6:  MOVWF  03
1FB8:  MOVF   03,W
1FBA:  SUBWF  xE9,W
1FBC:  BNC   2066
1FBE:  BNZ   1FC6
1FC0:  MOVF   01,W
1FC2:  SUBWF  xE8,W
1FC4:  BNC   2066
....................                    {    
....................                      ReleaseTime[i] = 0; 
1FC6:  BCF    FD8.0
1FC8:  RLCF   xE7,W
1FCA:  CLRF   03
1FCC:  ADDLW  55
1FCE:  MOVWF  FE9
1FD0:  MOVLW  01
1FD2:  ADDWFC 03,W
1FD4:  MOVWF  FEA
1FD6:  CLRF   FEC
1FD8:  MOVF   FED,F
1FDA:  CLRF   FEF
....................                      switch(i) 
1FDC:  MOVLW  01
1FDE:  SUBWF  xE7,W
1FE0:  ADDLW  EC
1FE2:  BC    2066
1FE4:  ADDLW  14
1FE6:  MOVLB  0
1FE8:  GOTO   2492
....................                      { 
....................                         case 1: 
....................                            Inputt.B1 = 1;  
1FEC:  MOVLB  1
1FEE:  BSF    x15.0
....................                         break; 
1FF0:  BRA    2066
....................                         case 2: 
....................                            Inputt.B2 = 1;  
1FF2:  MOVLB  1
1FF4:  BSF    x15.1
....................                         break; 
1FF6:  BRA    2066
....................                         case 3: 
....................                            Inputt.B3 = 1;  
1FF8:  MOVLB  1
1FFA:  BSF    x15.2
....................                         break; 
1FFC:  BRA    2066
....................                         case 4: 
....................                            Inputt.B4 = 1;  
1FFE:  MOVLB  1
2000:  BSF    x15.3
....................                         break; 
2002:  BRA    2066
....................                         case 5: 
....................                            Inputt.B5 = 1;  
2004:  MOVLB  1
2006:  BSF    x15.4
....................                         break; 
2008:  BRA    2066
....................                         case 6: 
....................                            Inputt.B6 = 1;  
200A:  MOVLB  1
200C:  BSF    x15.5
....................                         break; 
200E:  BRA    2066
....................                         case 7: 
....................                            Inputt.B7 = 1;  
2010:  MOVLB  1
2012:  BSF    x15.6
....................                          break; 
2014:  BRA    2066
....................                          case 8: 
....................                            Inputt.B8 = 1;  
2016:  MOVLB  1
2018:  BSF    x15.7
....................                         break; 
201A:  BRA    2066
....................                         case 9: 
....................                            Inputt.B9 = 1;  
201C:  MOVLB  1
201E:  BSF    x16.0
....................                         break; 
2020:  BRA    2066
....................                         case 10: 
....................                            Inputt.B10 = 1;  
2022:  MOVLB  1
2024:  BSF    x16.1
....................                         break; 
2026:  BRA    2066
....................                         case 11: 
....................                            Inputt.B11 = 1;  
2028:  MOVLB  1
202A:  BSF    x16.2
....................                         break; 
202C:  BRA    2066
....................                         case 12: 
....................                            Inputt.B12 = 1;  
202E:  MOVLB  1
2030:  BSF    x16.3
....................                         break; 
2032:  BRA    2066
....................                         case 13: 
....................                            Inputt.B13 = 1;  
2034:  MOVLB  1
2036:  BSF    x16.4
....................                         break; 
2038:  BRA    2066
....................                         case 14: 
....................                            Inputt.B14 = 1;  
203A:  MOVLB  1
203C:  BSF    x16.5
....................                         break; 
203E:  BRA    2066
....................                         case 15: 
....................                            Inputt.B15 = 1;  
2040:  MOVLB  1
2042:  BSF    x16.6
....................                         break; 
2044:  BRA    2066
....................                         case 16: 
....................                             Inputt.B16 = 1;  
2046:  MOVLB  1
2048:  BSF    x16.7
....................                          break; 
204A:  BRA    2066
....................                           
....................                          case 17: 
....................                            Inputt.B17 = 1;  
204C:  MOVLB  1
204E:  BSF    x17.0
....................                          break; 
2050:  BRA    2066
....................                          case 18: 
....................                            Inputt.B18 = 1;  
2052:  MOVLB  1
2054:  BSF    x17.1
....................                         break; 
2056:  BRA    2066
....................                         case 19: 
....................                            Inputt.B19 = 1;  
2058:  MOVLB  1
205A:  BSF    x17.2
....................                         break; 
205C:  BRA    2066
....................                         case 20: 
....................                            Inputt.B20 = 1;  
205E:  MOVLB  1
2060:  BSF    x17.3
....................                         break; 
2062:  BRA    2066
2064:  MOVLB  1
....................                                                                     
....................                      }                  
....................                   } 
....................                } 
2066:  BRA    2082
2068:  MOVLB  0
....................                else 
....................                { 
....................                   ReleaseTime[i] = 0; 
206A:  BCF    FD8.0
206C:  MOVLB  1
206E:  RLCF   xE7,W
2070:  CLRF   03
2072:  ADDLW  55
2074:  MOVWF  FE9
2076:  MOVLW  01
2078:  ADDWFC 03,W
207A:  MOVWF  FEA
207C:  CLRF   FEC
207E:  MOVF   FED,F
2080:  CLRF   FEF
....................                } 
....................              } 
2082:  BRA    21DA
2084:  MOVLB  0
....................              else //if(FaultNow[i]==0 
....................              { 
....................                if(FaultAgo[i]==0) 
2086:  MOVFF  1E7,1EB
208A:  MOVLW  01
208C:  MOVLB  1
208E:  MOVWF  xED
2090:  MOVLW  4D
2092:  MOVWF  xEC
2094:  MOVLB  0
2096:  CALL   1530
209A:  MOVF   01,W
209C:  ANDLW  01
209E:  BTFSS  FD8.2
20A0:  BRA    21C2
....................                { 
....................                    ReleaseTime[i]++; 
20A2:  BCF    FD8.0
20A4:  MOVLB  1
20A6:  RLCF   xE7,W
20A8:  CLRF   03
20AA:  ADDLW  55
20AC:  MOVWF  FE9
20AE:  MOVLW  01
20B0:  ADDWFC 03,W
20B2:  MOVWF  FEA
20B4:  MOVLW  01
20B6:  ADDWF  FEE,F
20B8:  BNC   20BC
20BA:  INCF   FEF,F
....................                    
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms) 
20BC:  BCF    FD8.0
20BE:  RLCF   xE7,W
20C0:  CLRF   03
20C2:  ADDLW  55
20C4:  MOVWF  FE9
20C6:  MOVLW  01
20C8:  ADDWFC 03,W
20CA:  MOVWF  FEA
20CC:  MOVFF  FEC,1E9
20D0:  MOVF   FED,F
20D2:  MOVFF  FEF,1E8
20D6:  BCF    FD8.0
20D8:  RLCF   xE7,W
20DA:  CLRF   03
20DC:  ADDLW  91
20DE:  MOVWF  FE9
20E0:  MOVLW  01
20E2:  ADDWFC 03,W
20E4:  MOVWF  FEA
20E6:  MOVFF  FEC,1ED
20EA:  MOVF   FED,F
20EC:  MOVFF  FEF,1EC
20F0:  CLRF   xEF
20F2:  MOVLW  4B
20F4:  MOVWF  xEE
20F6:  MOVLB  0
20F8:  RCALL  1A2C
20FA:  MOVFF  02,1EB
20FE:  MOVFF  01,1EA
2102:  MOVLW  0F
2104:  MOVLB  1
2106:  ADDWF  01,W
2108:  MOVWF  01
210A:  MOVLW  00
210C:  ADDWFC 02,W
210E:  MOVWF  03
2110:  MOVF   03,W
2112:  SUBWF  xE9,W
2114:  BNC   21BE
2116:  BNZ   211E
2118:  MOVF   01,W
211A:  SUBWF  xE8,W
211C:  BNC   21BE
....................                    {    
....................                      ReleaseTime[i] = 0; 
211E:  BCF    FD8.0
2120:  RLCF   xE7,W
2122:  CLRF   03
2124:  ADDLW  55
2126:  MOVWF  FE9
2128:  MOVLW  01
212A:  ADDWFC 03,W
212C:  MOVWF  FEA
212E:  CLRF   FEC
2130:  MOVF   FED,F
2132:  CLRF   FEF
....................                      switch(i) 
2134:  MOVLW  01
2136:  SUBWF  xE7,W
2138:  ADDLW  EC
213A:  BC    21BE
213C:  ADDLW  14
213E:  MOVLB  0
2140:  GOTO   24D4
....................                      { 
....................                         case 1: 
....................                            Inputt.B1 = 0;  
2144:  MOVLB  1
2146:  BCF    x15.0
....................                         break; 
2148:  BRA    21BE
....................                         case 2: 
....................                            Inputt.B2 = 0;  
214A:  MOVLB  1
214C:  BCF    x15.1
....................                         break; 
214E:  BRA    21BE
....................                         case 3: 
....................                            Inputt.B3 = 0;  
2150:  MOVLB  1
2152:  BCF    x15.2
....................                         break; 
2154:  BRA    21BE
....................                         case 4: 
....................                            Inputt.B4 = 0;  
2156:  MOVLB  1
2158:  BCF    x15.3
....................                         break; 
215A:  BRA    21BE
....................                         case 5: 
....................                            Inputt.B5 = 0;  
215C:  MOVLB  1
215E:  BCF    x15.4
....................                         break; 
2160:  BRA    21BE
....................                         case 6: 
....................                            Inputt.B6 = 0;  
2162:  MOVLB  1
2164:  BCF    x15.5
....................                         break; 
2166:  BRA    21BE
....................                         case 7: 
....................                            Inputt.B7 = 0;  
2168:  MOVLB  1
216A:  BCF    x15.6
....................                          break; 
216C:  BRA    21BE
....................                          case 8: 
....................                            Inputt.B8 = 0;  
216E:  MOVLB  1
2170:  BCF    x15.7
....................                         break; 
2172:  BRA    21BE
....................                         case 9: 
....................                            Inputt.B9 = 0;  
2174:  MOVLB  1
2176:  BCF    x16.0
....................                         break; 
2178:  BRA    21BE
....................                         case 10: 
....................                            Inputt.B10 = 0;  
217A:  MOVLB  1
217C:  BCF    x16.1
....................                         break; 
217E:  BRA    21BE
....................                         case 11: 
....................                            Inputt.B11 = 0;  
2180:  MOVLB  1
2182:  BCF    x16.2
....................                         break; 
2184:  BRA    21BE
....................                         case 12: 
....................                            Inputt.B12 = 0;  
2186:  MOVLB  1
2188:  BCF    x16.3
....................                         break; 
218A:  BRA    21BE
....................                         case 13: 
....................                            Inputt.B13 = 0;  
218C:  MOVLB  1
218E:  BCF    x16.4
....................                         break; 
2190:  BRA    21BE
....................                         case 14: 
....................                            Inputt.B14 = 0;  
2192:  MOVLB  1
2194:  BCF    x16.5
....................                         break; 
2196:  BRA    21BE
....................                         case 15: 
....................                            Inputt.B15 = 0;  
2198:  MOVLB  1
219A:  BCF    x16.6
....................                         break; 
219C:  BRA    21BE
....................                         case 16: 
....................                             Inputt.B16 = 0; 
219E:  MOVLB  1
21A0:  BCF    x16.7
....................                          break; 
21A2:  BRA    21BE
....................                           
....................                          case 17: 
....................                            Inputt.B17 = 0;  
21A4:  MOVLB  1
21A6:  BCF    x17.0
....................                          break; 
21A8:  BRA    21BE
....................                          case 18: 
....................                            Inputt.B18 = 0;  
21AA:  MOVLB  1
21AC:  BCF    x17.1
....................                         break; 
21AE:  BRA    21BE
....................                         case 19: 
....................                            Inputt.B19 = 0;  
21B0:  MOVLB  1
21B2:  BCF    x17.2
....................                         break; 
21B4:  BRA    21BE
....................                         case 20: 
....................                            Inputt.B20 = 0;  
21B6:  MOVLB  1
21B8:  BCF    x17.3
....................                         break; 
21BA:  BRA    21BE
21BC:  MOVLB  1
....................                                     
....................                      }                  
....................                    } 
....................                } 
21BE:  BRA    21DA
21C0:  MOVLB  0
....................                else 
....................                { 
....................                   ReleaseTime[i] = 0; 
21C2:  BCF    FD8.0
21C4:  MOVLB  1
21C6:  RLCF   xE7,W
21C8:  CLRF   03
21CA:  ADDLW  55
21CC:  MOVWF  FE9
21CE:  MOVLW  01
21D0:  ADDWFC 03,W
21D2:  MOVWF  FEA
21D4:  CLRF   FEC
21D6:  MOVF   FED,F
21D8:  CLRF   FEF
21DA:  MOVLB  0
....................                } 
....................                   /* 
....................                   ReleaseTime[i] = 0; 
....................                   switch(i) 
....................                   { 
....................                       case 1: 
....................                          Input.B1 = 0;  
....................                       break; 
....................                       case 2: 
....................                          Input.B2 = 0;  
....................                       break; 
....................                       case 3: 
....................                          Input.B3 = 0;  
....................                       break; 
....................                       case 4: 
....................                          Input.B4 = 0;  
....................                       break; 
....................                       case 5: 
....................                          Input.B5 = 0;  
....................                       break; 
....................                       case 6: 
....................                          Input.B6 = 0;  
....................                       break; 
....................                       case 7: 
....................                          Input.B7 = 0;  
....................                       break; 
....................                       case 8: 
....................                          Input.B8 = 0;  
....................                       break; 
....................                       case 9: 
....................                          Input.B9 = 0;  
....................                       break; 
....................                       case 10: 
....................                          Input.B10 = 0;  
....................                       break; 
....................                       case 11: 
....................                          Input.B11 = 0;  
....................                       break; 
....................                       case 12: 
....................                          Input.B12 = 0;  
....................                       break; 
....................                       case 13: 
....................                          Input.B13 = 0;  
....................                       break; 
....................                       case 14: 
....................                          Input.B14 = 0;  
....................                       break; 
....................                       case 15: 
....................                          Input.B15 = 0;  
....................                       break; 
....................                       case 16: 
....................                          Input.B16 = 0;  
....................                       break; 
....................                               
....................                   } 
....................                   */ 
....................              } 
....................           } 
21DC:  MOVLB  1
21DE:  INCF   xE7,F
21E0:  BRA    1C08
....................       } 
....................        
....................        
....................       StoreReleaseFault(); 
21E2:  MOVLB  0
21E4:  BRA    1A4E
....................        
....................       ///////////////---Anal Fault---////////////////// 
....................        
....................       ///////////////////////--Edit--/////////////////// 
....................             
....................       Input11_18 = 0x00; 
21E6:  CLRF   4B
....................       Input11_18 = Input11_18 | ~Inputt.B18; 
21E8:  MOVLW  00
21EA:  MOVLB  1
21EC:  BTFSS  x17.1
21EE:  MOVLW  01
21F0:  IORWF  4B,F
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B17; 
21F2:  BCF    FD8.0
21F4:  RLCF   4B,W
21F6:  MOVWF  xE8
21F8:  MOVLW  00
21FA:  BTFSS  x17.0
21FC:  MOVLW  01
21FE:  IORWF  xE8,W
2200:  MOVWF  4B
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B16; 
2202:  BCF    FD8.0
2204:  RLCF   4B,W
2206:  MOVWF  xE8
2208:  MOVLW  00
220A:  BTFSS  x16.7
220C:  MOVLW  01
220E:  IORWF  xE8,W
2210:  MOVWF  4B
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B15; 
2212:  BCF    FD8.0
2214:  RLCF   4B,W
2216:  MOVWF  xE8
2218:  MOVLW  00
221A:  BTFSS  x16.6
221C:  MOVLW  01
221E:  IORWF  xE8,W
2220:  MOVWF  4B
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B14; 
2222:  BCF    FD8.0
2224:  RLCF   4B,W
2226:  MOVWF  xE8
2228:  MOVLW  00
222A:  BTFSS  x16.5
222C:  MOVLW  01
222E:  IORWF  xE8,W
2230:  MOVWF  4B
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B13; 
2232:  BCF    FD8.0
2234:  RLCF   4B,W
2236:  MOVWF  xE8
2238:  MOVLW  00
223A:  BTFSS  x16.4
223C:  MOVLW  01
223E:  IORWF  xE8,W
2240:  MOVWF  4B
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B12; 
2242:  BCF    FD8.0
2244:  RLCF   4B,W
2246:  MOVWF  xE8
2248:  MOVLW  00
224A:  BTFSS  x16.3
224C:  MOVLW  01
224E:  IORWF  xE8,W
2250:  MOVWF  4B
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B11; 
2252:  BCF    FD8.0
2254:  RLCF   4B,W
2256:  MOVWF  xE8
2258:  MOVLW  00
225A:  BTFSS  x16.2
225C:  MOVLW  01
225E:  IORWF  xE8,W
2260:  MOVWF  4B
....................        
....................       
....................     
....................       Input19_20 = 0x00; 
2262:  CLRF   4C
....................       Input19_20 = Input19_20 | ~Inputt.B20; 
2264:  MOVLW  00
2266:  BTFSS  x17.3
2268:  MOVLW  01
226A:  IORWF  4C,F
....................       Input19_20 = (Input19_20 << 1) | ~Inputt.B19; 
226C:  BCF    FD8.0
226E:  RLCF   4C,W
2270:  MOVWF  xE8
2272:  MOVLW  00
2274:  BTFSS  x17.2
2276:  MOVLW  01
2278:  IORWF  xE8,W
227A:  MOVWF  4C
....................       //} 
....................     
....................       Input1_8 = 0x00; 
227C:  CLRF   49
....................       Input1_8 = Input1_8 | ~Inputt.B8; 
227E:  MOVLW  00
2280:  BTFSS  x15.7
2282:  MOVLW  01
2284:  IORWF  49,F
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B7; 
2286:  BCF    FD8.0
2288:  RLCF   49,W
228A:  MOVWF  xE8
228C:  MOVLW  00
228E:  BTFSS  x15.6
2290:  MOVLW  01
2292:  IORWF  xE8,W
2294:  MOVWF  49
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B6; 
2296:  BCF    FD8.0
2298:  RLCF   49,W
229A:  MOVWF  xE8
229C:  MOVLW  00
229E:  BTFSS  x15.5
22A0:  MOVLW  01
22A2:  IORWF  xE8,W
22A4:  MOVWF  49
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B5; 
22A6:  BCF    FD8.0
22A8:  RLCF   49,W
22AA:  MOVWF  xE8
22AC:  MOVLW  00
22AE:  BTFSS  x15.4
22B0:  MOVLW  01
22B2:  IORWF  xE8,W
22B4:  MOVWF  49
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B4; 
22B6:  BCF    FD8.0
22B8:  RLCF   49,W
22BA:  MOVWF  xE8
22BC:  MOVLW  00
22BE:  BTFSS  x15.3
22C0:  MOVLW  01
22C2:  IORWF  xE8,W
22C4:  MOVWF  49
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B3; 
22C6:  BCF    FD8.0
22C8:  RLCF   49,W
22CA:  MOVWF  xE8
22CC:  MOVLW  00
22CE:  BTFSS  x15.2
22D0:  MOVLW  01
22D2:  IORWF  xE8,W
22D4:  MOVWF  49
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B2; 
22D6:  BCF    FD8.0
22D8:  RLCF   49,W
22DA:  MOVWF  xE8
22DC:  MOVLW  00
22DE:  BTFSS  x15.1
22E0:  MOVLW  01
22E2:  IORWF  xE8,W
22E4:  MOVWF  49
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B1; 
22E6:  BCF    FD8.0
22E8:  RLCF   49,W
22EA:  MOVWF  xE8
22EC:  MOVLW  00
22EE:  BTFSS  x15.0
22F0:  MOVLW  01
22F2:  IORWF  xE8,W
22F4:  MOVWF  49
....................        
....................       Input9_16 = 0x00; 
22F6:  CLRF   4D
....................       Input9_16 = Input9_16 | ~Inputt.B16; 
22F8:  MOVLW  00
22FA:  BTFSS  x16.7
22FC:  MOVLW  01
22FE:  IORWF  4D,F
....................       Input9_16 = (Input9_16 << 1) | ~Inputt.B15; 
2300:  BCF    FD8.0
2302:  RLCF   4D,W
2304:  MOVWF  xE8
2306:  MOVLW  00
2308:  BTFSS  x16.6
230A:  MOVLW  01
230C:  IORWF  xE8,W
230E:  MOVWF  4D
....................       Input9_16 = (Input9_16 << 1) | ~Inputt.B14; 
2310:  BCF    FD8.0
2312:  RLCF   4D,W
2314:  MOVWF  xE8
2316:  MOVLW  00
2318:  BTFSS  x16.5
231A:  MOVLW  01
231C:  IORWF  xE8,W
231E:  MOVWF  4D
....................       Input9_16 = (Input9_16 << 1) | ~Inputt.B13; 
2320:  BCF    FD8.0
2322:  RLCF   4D,W
2324:  MOVWF  xE8
2326:  MOVLW  00
2328:  BTFSS  x16.4
232A:  MOVLW  01
232C:  IORWF  xE8,W
232E:  MOVWF  4D
....................       Input9_16 = (Input9_16 << 1) | ~Inputt.B12; 
2330:  BCF    FD8.0
2332:  RLCF   4D,W
2334:  MOVWF  xE8
2336:  MOVLW  00
2338:  BTFSS  x16.3
233A:  MOVLW  01
233C:  IORWF  xE8,W
233E:  MOVWF  4D
....................       Input9_16 = (Input9_16 << 1) | ~Inputt.B11; 
2340:  BCF    FD8.0
2342:  RLCF   4D,W
2344:  MOVWF  xE8
2346:  MOVLW  00
2348:  BTFSS  x16.2
234A:  MOVLW  01
234C:  IORWF  xE8,W
234E:  MOVWF  4D
....................       Input9_16 = (Input9_16 << 1) | ~Inputt.B10; 
2350:  BCF    FD8.0
2352:  RLCF   4D,W
2354:  MOVWF  xE8
2356:  MOVLW  00
2358:  BTFSS  x16.1
235A:  MOVLW  01
235C:  IORWF  xE8,W
235E:  MOVWF  4D
....................       Input9_16 = (Input9_16 << 1) | ~Inputt.B9; 
2360:  BCF    FD8.0
2362:  RLCF   4D,W
2364:  MOVWF  xE8
2366:  MOVLW  00
2368:  BTFSS  x16.0
236A:  MOVLW  01
236C:  IORWF  xE8,W
236E:  MOVWF  4D
....................        
....................       Input17_24 = 0x00; 
2370:  CLRF   4E
....................       Input17_24 = Input17_24 | ~Inputt.B24; 
2372:  MOVLW  00
2374:  BTFSS  x17.7
2376:  MOVLW  01
2378:  IORWF  4E,F
....................       Input17_24 = (Input17_24 << 1) | ~Inputt.B23; 
237A:  BCF    FD8.0
237C:  RLCF   4E,W
237E:  MOVWF  xE8
2380:  MOVLW  00
2382:  BTFSS  x17.6
2384:  MOVLW  01
2386:  IORWF  xE8,W
2388:  MOVWF  4E
....................       Input17_24 = (Input17_24 << 1) | ~Inputt.B22; 
238A:  BCF    FD8.0
238C:  RLCF   4E,W
238E:  MOVWF  xE8
2390:  MOVLW  00
2392:  BTFSS  x17.5
2394:  MOVLW  01
2396:  IORWF  xE8,W
2398:  MOVWF  4E
....................       Input17_24 = (Input17_24 << 1) | ~Inputt.B21; 
239A:  BCF    FD8.0
239C:  RLCF   4E,W
239E:  MOVWF  xE8
23A0:  MOVLW  00
23A2:  BTFSS  x17.4
23A4:  MOVLW  01
23A6:  IORWF  xE8,W
23A8:  MOVWF  4E
....................       Input17_24 = (Input17_24 << 1) | ~Inputt.B20; 
23AA:  BCF    FD8.0
23AC:  RLCF   4E,W
23AE:  MOVWF  xE8
23B0:  MOVLW  00
23B2:  BTFSS  x17.3
23B4:  MOVLW  01
23B6:  IORWF  xE8,W
23B8:  MOVWF  4E
....................       Input17_24 = (Input17_24 << 1) | ~Inputt.B19; 
23BA:  BCF    FD8.0
23BC:  RLCF   4E,W
23BE:  MOVWF  xE8
23C0:  MOVLW  00
23C2:  BTFSS  x17.2
23C4:  MOVLW  01
23C6:  IORWF  xE8,W
23C8:  MOVWF  4E
....................       Input17_24 = (Input17_24 << 1) | ~Inputt.B18; 
23CA:  BCF    FD8.0
23CC:  RLCF   4E,W
23CE:  MOVWF  xE8
23D0:  MOVLW  00
23D2:  BTFSS  x17.1
23D4:  MOVLW  01
23D6:  IORWF  xE8,W
23D8:  MOVWF  4E
....................       Input17_24 = (Input17_24 << 1) | ~Inputt.B17; 
23DA:  BCF    FD8.0
23DC:  RLCF   4E,W
23DE:  MOVWF  xE8
23E0:  MOVLW  00
23E2:  BTFSS  x17.0
23E4:  MOVLW  01
23E6:  IORWF  xE8,W
23E8:  MOVWF  4E
....................      
....................     
....................  
....................       Input9_10 = 0x00; 
23EA:  CLRF   4A
....................       Input9_10 = Input9_10 | ~Inputt.B10; 
23EC:  MOVLW  00
23EE:  BTFSS  x16.1
23F0:  MOVLW  01
23F2:  IORWF  4A,F
....................       Input9_10 = (Input9_10 << 1) | ~Inputt.B9; 
23F4:  BCF    FD8.0
23F6:  RLCF   4A,W
23F8:  MOVWF  xE8
23FA:  MOVLW  00
23FC:  BTFSS  x16.0
23FE:  MOVLW  01
2400:  IORWF  xE8,W
2402:  MOVWF  4A
....................        
....................       Input17_24 &= 0x0F; 
2404:  MOVLW  0F
2406:  ANDWF  4E,F
....................       Input25_32 = 0x00; 
2408:  CLRF   4F
240A:  MOVLB  0
240C:  RETURN 0
....................       //+++++++++++++++++++++++++++++++++++++++++++ 
....................    //} 
....................   
....................  
.................... /* 
....................  //////////////////////////////////////////////////////////////// 
....................  ////////////////////////////////////////////////////////////////// 
....................  /////////////////////////////////////////////////////////////////// 
....................  ////////////////////////////////////////////////////////////////////// 
....................  //////////////////////////////////////////////////////////////////////// 
....................    //if(NoOfPoint >= 10) 
....................    //{ 
....................       // if(NoOfPoint >= 20) 
....................    //{    
....................       MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_0); 
....................            
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat;          
....................       } 
....................        
....................       Inputt.B11 = MCP23s17_Ip_dat; 
....................       Inputt.B12 = MCP23s17_Ip_dat >> 1; 
....................       Inputt.B13 = MCP23s17_Ip_dat >> 2; 
....................       Inputt.B14 = MCP23s17_Ip_dat >> 3; 
....................       Inputt.B15 = MCP23s17_Ip_dat >> 4; 
....................       Inputt.B16 = MCP23s17_Ip_dat >> 5; 
....................       Inputt.B17 = MCP23s17_Ip_dat >> 6; 
....................       Inputt.B18 = MCP23s17_Ip_dat >> 7; 
....................  
....................       Input11_18 = 0x00; 
....................       Input11_18 = Input1_8 | ~Inputt.B18; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B17; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B16; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B15; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B14; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B13; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B12; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B11; 
....................      
....................       MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_0); 
....................        
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
....................       } 
....................        
....................       Inputt.B19 = MCP23s17_Ip_dat; 
....................       Inputt.B20 = MCP23s17_Ip_dat >> 1; 
....................        
....................  
....................       Input19_20 = 0x00; 
....................       Input19_20 = Input9_10 | ~Inputt.B20; 
....................       Input19_20 = (Input9_10 << 1) | ~Inputt.B19; 
....................    //} 
....................     
....................       MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_1); 
....................            
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
....................           
....................       } 
....................        
....................       Inputt.B1 = MCP23s17_Ip_dat; 
....................       Inputt.B2 = MCP23s17_Ip_dat >> 1; 
....................       Inputt.B3 = MCP23s17_Ip_dat >> 2; 
....................       Inputt.B4 = MCP23s17_Ip_dat >> 3; 
....................       Inputt.B5 = MCP23s17_Ip_dat >> 4; 
....................       Inputt.B6 = MCP23s17_Ip_dat >> 5; 
....................       Inputt.B7 = MCP23s17_Ip_dat >> 6; 
....................       Inputt.B8 = MCP23s17_Ip_dat >> 7; 
....................  
....................       Input1_8 = 0x00; 
....................       Input1_8 = Input1_8 | ~Inputt.B8; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B7; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B6; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B5; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B4; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B3; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B2; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B1; 
....................      
....................       MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_1); 
....................        
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
....................       } 
....................        
....................       Inputt.B9 = MCP23s17_Ip_dat; 
....................       Inputt.B10 = MCP23s17_Ip_dat >> 1; 
....................        
....................  
....................       Input9_10 = 0x00; 
....................       Input9_10 = Input9_10 | ~Inputt.B10; 
....................       Input9_10 = (Input9_10 << 1) | ~Inputt.B9; 
....................       //+++++++++++++++++++++++++++++++++++++++++++ 
....................    //} 
....................     
.................... */   
.................... } 
.................... /*----------------------------------------------------------------------------*/ 
....................  
....................  
.................... void Read_Config(void) 
.................... { 
....................     
....................  
....................    EEpDat = read_eeprom(0x01);   // Inputt type 1-8 
*
06DC:  MOVFF  FF2,1E7
06E0:  BCF    FF2.7
06E2:  MOVLW  01
06E4:  MOVWF  FA9
06E6:  BCF    FA6.6
06E8:  BCF    FA6.7
06EA:  BSF    FA6.0
06EC:  MOVF   FA8,W
06EE:  MOVLB  1
06F0:  BTFSC  xE7.7
06F2:  BSF    FF2.7
06F4:  MOVWF  39
....................    InputType1_8 = EEpDat; 
06F6:  MOVFF  39,3A
....................  
....................    InputType.B1 = EEpDat; 
06FA:  BCF    x1D.0
06FC:  BTFSC  39.0
06FE:  BSF    x1D.0
....................    InputType.B2 = EEpDat >> 1; 
0700:  BCF    FD8.0
0702:  RRCF   39,W
0704:  BCF    x1D.1
0706:  BTFSC  FE8.0
0708:  BSF    x1D.1
....................    InputType.B3 = EEpDat >> 2; 
070A:  RRCF   39,W
070C:  MOVWF  00
070E:  RRCF   00,F
0710:  MOVLW  3F
0712:  ANDWF  00,F
0714:  BCF    x1D.2
0716:  BTFSC  00.0
0718:  BSF    x1D.2
....................    InputType.B4 = EEpDat >> 3; 
071A:  RRCF   39,W
071C:  MOVWF  00
071E:  RRCF   00,F
0720:  RRCF   00,F
0722:  MOVLW  1F
0724:  ANDWF  00,F
0726:  BCF    x1D.3
0728:  BTFSC  00.0
072A:  BSF    x1D.3
....................    InputType.B5 = EEpDat >> 4; 
072C:  SWAPF  39,W
072E:  MOVWF  00
0730:  MOVLW  0F
0732:  ANDWF  00,F
0734:  BCF    x1D.4
0736:  BTFSC  00.0
0738:  BSF    x1D.4
....................    InputType.B6 = EEpDat >> 5; 
073A:  SWAPF  39,W
073C:  MOVWF  00
073E:  RRCF   00,F
0740:  MOVLW  07
0742:  ANDWF  00,F
0744:  BCF    x1D.5
0746:  BTFSC  00.0
0748:  BSF    x1D.5
....................    InputType.B7 = EEpDat >> 6; 
074A:  SWAPF  39,W
074C:  MOVWF  00
074E:  RRCF   00,F
0750:  RRCF   00,F
0752:  MOVLW  03
0754:  ANDWF  00,F
0756:  BCF    x1D.6
0758:  BTFSC  00.0
075A:  BSF    x1D.6
....................    InputType.B8 = EEpDat >> 7; 
075C:  CLRF   00
075E:  BTFSC  39.7
0760:  BSF    00.0
0762:  BCF    x1D.7
0764:  BTFSC  00.0
0766:  BSF    x1D.7
....................  
....................    EEpDat = read_eeprom(0x02);   // Inputt type 9-16 
0768:  MOVFF  FF2,1E7
076C:  BCF    FF2.7
076E:  MOVLW  02
0770:  MOVWF  FA9
0772:  BCF    FA6.6
0774:  BCF    FA6.7
0776:  BSF    FA6.0
0778:  MOVF   FA8,W
077A:  BTFSC  xE7.7
077C:  BSF    FF2.7
077E:  MOVWF  39
....................    InputType9_16 = EEpDat; 
0780:  MOVFF  39,3B
....................  
....................    InputType.B9 = EEpDat; 
0784:  BCF    x1E.0
0786:  BTFSC  39.0
0788:  BSF    x1E.0
....................    InputType.B10 = EEpDat >> 1; 
078A:  BCF    FD8.0
078C:  RRCF   39,W
078E:  BCF    x1E.1
0790:  BTFSC  FE8.0
0792:  BSF    x1E.1
....................    InputType.B11 = EEpDat >> 2; 
0794:  RRCF   39,W
0796:  MOVWF  00
0798:  RRCF   00,F
079A:  MOVLW  3F
079C:  ANDWF  00,F
079E:  BCF    x1E.2
07A0:  BTFSC  00.0
07A2:  BSF    x1E.2
....................    InputType.B12 = EEpDat >> 3; 
07A4:  RRCF   39,W
07A6:  MOVWF  00
07A8:  RRCF   00,F
07AA:  RRCF   00,F
07AC:  MOVLW  1F
07AE:  ANDWF  00,F
07B0:  BCF    x1E.3
07B2:  BTFSC  00.0
07B4:  BSF    x1E.3
....................    InputType.B13 = EEpDat >> 4; 
07B6:  SWAPF  39,W
07B8:  MOVWF  00
07BA:  MOVLW  0F
07BC:  ANDWF  00,F
07BE:  BCF    x1E.4
07C0:  BTFSC  00.0
07C2:  BSF    x1E.4
....................    InputType.B14 = EEpDat >> 5; 
07C4:  SWAPF  39,W
07C6:  MOVWF  00
07C8:  RRCF   00,F
07CA:  MOVLW  07
07CC:  ANDWF  00,F
07CE:  BCF    x1E.5
07D0:  BTFSC  00.0
07D2:  BSF    x1E.5
....................    InputType.B15 = EEpDat >> 6; 
07D4:  SWAPF  39,W
07D6:  MOVWF  00
07D8:  RRCF   00,F
07DA:  RRCF   00,F
07DC:  MOVLW  03
07DE:  ANDWF  00,F
07E0:  BCF    x1E.6
07E2:  BTFSC  00.0
07E4:  BSF    x1E.6
....................    InputType.B16 = EEpDat >> 7; 
07E6:  CLRF   00
07E8:  BTFSC  39.7
07EA:  BSF    00.0
07EC:  BCF    x1E.7
07EE:  BTFSC  00.0
07F0:  BSF    x1E.7
....................     
....................    EEpDat = read_eeprom(0x03);   // Inputt type 9-16 
07F2:  MOVFF  FF2,1E7
07F6:  BCF    FF2.7
07F8:  MOVLW  03
07FA:  MOVWF  FA9
07FC:  BCF    FA6.6
07FE:  BCF    FA6.7
0800:  BSF    FA6.0
0802:  MOVF   FA8,W
0804:  BTFSC  xE7.7
0806:  BSF    FF2.7
0808:  MOVWF  39
....................    InputType17_24 = EEpDat; 
080A:  MOVFF  39,3C
....................  
....................    InputType.B17 = EEpDat; 
080E:  BCF    x1F.0
0810:  BTFSC  39.0
0812:  BSF    x1F.0
....................    InputType.B18 = EEpDat >> 1; 
0814:  BCF    FD8.0
0816:  RRCF   39,W
0818:  BCF    x1F.1
081A:  BTFSC  FE8.0
081C:  BSF    x1F.1
....................    InputType.B19 = EEpDat >> 2; 
081E:  RRCF   39,W
0820:  MOVWF  00
0822:  RRCF   00,F
0824:  MOVLW  3F
0826:  ANDWF  00,F
0828:  BCF    x1F.2
082A:  BTFSC  00.0
082C:  BSF    x1F.2
....................    InputType.B20 = EEpDat >> 3; 
082E:  RRCF   39,W
0830:  MOVWF  00
0832:  RRCF   00,F
0834:  RRCF   00,F
0836:  MOVLW  1F
0838:  ANDWF  00,F
083A:  BCF    x1F.3
083C:  BTFSC  00.0
083E:  BSF    x1F.3
....................    InputType.B21 = EEpDat >> 4; 
0840:  SWAPF  39,W
0842:  MOVWF  00
0844:  MOVLW  0F
0846:  ANDWF  00,F
0848:  BCF    x1F.4
084A:  BTFSC  00.0
084C:  BSF    x1F.4
....................    InputType.B22 = EEpDat >> 5; 
084E:  SWAPF  39,W
0850:  MOVWF  00
0852:  RRCF   00,F
0854:  MOVLW  07
0856:  ANDWF  00,F
0858:  BCF    x1F.5
085A:  BTFSC  00.0
085C:  BSF    x1F.5
....................    InputType.B23 = EEpDat >> 6; 
085E:  SWAPF  39,W
0860:  MOVWF  00
0862:  RRCF   00,F
0864:  RRCF   00,F
0866:  MOVLW  03
0868:  ANDWF  00,F
086A:  BCF    x1F.6
086C:  BTFSC  00.0
086E:  BSF    x1F.6
....................    InputType.B24 = EEpDat >> 7; 
0870:  CLRF   00
0872:  BTFSC  39.7
0874:  BSF    00.0
0876:  BCF    x1F.7
0878:  BTFSC  00.0
087A:  BSF    x1F.7
....................     
....................    FaultNCNO[1] = InputType.B1; 
087C:  BCF    xCD.1
087E:  BTFSC  x1D.0
0880:  BSF    xCD.1
....................    FaultNCNO[2] = InputType.B2; 
0882:  BCF    xCD.2
0884:  BTFSC  x1D.1
0886:  BSF    xCD.2
....................    FaultNCNO[3] = InputType.B3; 
0888:  BCF    xCD.3
088A:  BTFSC  x1D.2
088C:  BSF    xCD.3
....................    FaultNCNO[4] = InputType.B4; 
088E:  BCF    xCD.4
0890:  BTFSC  x1D.3
0892:  BSF    xCD.4
....................    FaultNCNO[5] = InputType.B5; 
0894:  BCF    xCD.5
0896:  BTFSC  x1D.4
0898:  BSF    xCD.5
....................    FaultNCNO[6] = InputType.B6; 
089A:  BCF    xCD.6
089C:  BTFSC  x1D.5
089E:  BSF    xCD.6
....................    FaultNCNO[7] = InputType.B7; 
08A0:  BCF    xCD.7
08A2:  BTFSC  x1D.6
08A4:  BSF    xCD.7
....................    FaultNCNO[8] = InputType.B8; 
08A6:  BCF    xCE.0
08A8:  BTFSC  x1D.7
08AA:  BSF    xCE.0
....................    FaultNCNO[9] = InputType.B9; 
08AC:  BCF    xCE.1
08AE:  BTFSC  x1E.0
08B0:  BSF    xCE.1
....................    FaultNCNO[10] = InputType.B10; 
08B2:  BCF    xCE.2
08B4:  BTFSC  x1E.1
08B6:  BSF    xCE.2
....................    FaultNCNO[11] = InputType.B11; 
08B8:  BCF    xCE.3
08BA:  BTFSC  x1E.2
08BC:  BSF    xCE.3
....................    FaultNCNO[12] = InputType.B12; 
08BE:  BCF    xCE.4
08C0:  BTFSC  x1E.3
08C2:  BSF    xCE.4
....................    FaultNCNO[13] = InputType.B13; 
08C4:  BCF    xCE.5
08C6:  BTFSC  x1E.4
08C8:  BSF    xCE.5
....................    FaultNCNO[14] = InputType.B14; 
08CA:  BCF    xCE.6
08CC:  BTFSC  x1E.5
08CE:  BSF    xCE.6
....................    FaultNCNO[15] = InputType.B15; 
08D0:  BCF    xCE.7
08D2:  BTFSC  x1E.6
08D4:  BSF    xCE.7
....................    FaultNCNO[16] = InputType.B16; 
08D6:  BCF    xCF.0
08D8:  BTFSC  x1E.7
08DA:  BSF    xCF.0
....................    FaultNCNO[17] = InputType.B17; 
08DC:  BCF    xCF.1
08DE:  BTFSC  x1F.0
08E0:  BSF    xCF.1
....................    FaultNCNO[18] = InputType.B18; 
08E2:  BCF    xCF.2
08E4:  BTFSC  x1F.1
08E6:  BSF    xCF.2
....................    FaultNCNO[19] = InputType.B19; 
08E8:  BCF    xCF.3
08EA:  BTFSC  x1F.2
08EC:  BSF    xCF.3
....................    FaultNCNO[20] = InputType.B20; 
08EE:  BCF    xCF.4
08F0:  BTFSC  x1F.3
08F2:  BSF    xCF.4
....................  
....................    //////////////////////////////////////// 
....................  
....................    EEpDat = read_eeprom(0x04);   // Fault type 1-8 
08F4:  MOVFF  FF2,1E7
08F8:  BCF    FF2.7
08FA:  MOVLW  04
08FC:  MOVWF  FA9
08FE:  BCF    FA6.6
0900:  BCF    FA6.7
0902:  BSF    FA6.0
0904:  MOVF   FA8,W
0906:  BTFSC  xE7.7
0908:  BSF    FF2.7
090A:  MOVWF  39
....................    FaultType1_8 = EEpDat; 
090C:  MOVFF  39,3D
....................  
....................    FaultType.B1 = EEpDat; 
0910:  BCF    x21.0
0912:  BTFSC  39.0
0914:  BSF    x21.0
....................    FaultType.B2 = EEpDat >> 1; 
0916:  BCF    FD8.0
0918:  RRCF   39,W
091A:  BCF    x21.1
091C:  BTFSC  FE8.0
091E:  BSF    x21.1
....................    FaultType.B3 = EEpDat >> 2; 
0920:  RRCF   39,W
0922:  MOVWF  00
0924:  RRCF   00,F
0926:  MOVLW  3F
0928:  ANDWF  00,F
092A:  BCF    x21.2
092C:  BTFSC  00.0
092E:  BSF    x21.2
....................    FaultType.B4 = EEpDat >> 3; 
0930:  RRCF   39,W
0932:  MOVWF  00
0934:  RRCF   00,F
0936:  RRCF   00,F
0938:  MOVLW  1F
093A:  ANDWF  00,F
093C:  BCF    x21.3
093E:  BTFSC  00.0
0940:  BSF    x21.3
....................    FaultType.B5 = EEpDat >> 4; 
0942:  SWAPF  39,W
0944:  MOVWF  00
0946:  MOVLW  0F
0948:  ANDWF  00,F
094A:  BCF    x21.4
094C:  BTFSC  00.0
094E:  BSF    x21.4
....................    FaultType.B6 = EEpDat >> 5; 
0950:  SWAPF  39,W
0952:  MOVWF  00
0954:  RRCF   00,F
0956:  MOVLW  07
0958:  ANDWF  00,F
095A:  BCF    x21.5
095C:  BTFSC  00.0
095E:  BSF    x21.5
....................    FaultType.B7 = EEpDat >> 6; 
0960:  SWAPF  39,W
0962:  MOVWF  00
0964:  RRCF   00,F
0966:  RRCF   00,F
0968:  MOVLW  03
096A:  ANDWF  00,F
096C:  BCF    x21.6
096E:  BTFSC  00.0
0970:  BSF    x21.6
....................    FaultType.B8 = EEpDat >> 7; 
0972:  CLRF   00
0974:  BTFSC  39.7
0976:  BSF    00.0
0978:  BCF    x21.7
097A:  BTFSC  00.0
097C:  BSF    x21.7
....................  
....................    EEpDat = read_eeprom(0x05);   // Fault type 9-16 
097E:  MOVFF  FF2,1E7
0982:  BCF    FF2.7
0984:  MOVLW  05
0986:  MOVWF  FA9
0988:  BCF    FA6.6
098A:  BCF    FA6.7
098C:  BSF    FA6.0
098E:  MOVF   FA8,W
0990:  BTFSC  xE7.7
0992:  BSF    FF2.7
0994:  MOVWF  39
....................    FaultType9_16 = EEpDat; 
0996:  MOVFF  39,3E
....................  
....................    FaultType.B9 = EEpDat; 
099A:  BCF    x22.0
099C:  BTFSC  39.0
099E:  BSF    x22.0
....................    FaultType.B10 = EEpDat >> 1; 
09A0:  BCF    FD8.0
09A2:  RRCF   39,W
09A4:  BCF    x22.1
09A6:  BTFSC  FE8.0
09A8:  BSF    x22.1
....................    FaultType.B11 = EEpDat >> 2; 
09AA:  RRCF   39,W
09AC:  MOVWF  00
09AE:  RRCF   00,F
09B0:  MOVLW  3F
09B2:  ANDWF  00,F
09B4:  BCF    x22.2
09B6:  BTFSC  00.0
09B8:  BSF    x22.2
....................    FaultType.B12 = EEpDat >> 3; 
09BA:  RRCF   39,W
09BC:  MOVWF  00
09BE:  RRCF   00,F
09C0:  RRCF   00,F
09C2:  MOVLW  1F
09C4:  ANDWF  00,F
09C6:  BCF    x22.3
09C8:  BTFSC  00.0
09CA:  BSF    x22.3
....................    FaultType.B13 = EEpDat >> 4; 
09CC:  SWAPF  39,W
09CE:  MOVWF  00
09D0:  MOVLW  0F
09D2:  ANDWF  00,F
09D4:  BCF    x22.4
09D6:  BTFSC  00.0
09D8:  BSF    x22.4
....................    FaultType.B14 = EEpDat >> 5; 
09DA:  SWAPF  39,W
09DC:  MOVWF  00
09DE:  RRCF   00,F
09E0:  MOVLW  07
09E2:  ANDWF  00,F
09E4:  BCF    x22.5
09E6:  BTFSC  00.0
09E8:  BSF    x22.5
....................    FaultType.B15 = EEpDat >> 6; 
09EA:  SWAPF  39,W
09EC:  MOVWF  00
09EE:  RRCF   00,F
09F0:  RRCF   00,F
09F2:  MOVLW  03
09F4:  ANDWF  00,F
09F6:  BCF    x22.6
09F8:  BTFSC  00.0
09FA:  BSF    x22.6
....................    FaultType.B16 = EEpDat >> 7; 
09FC:  CLRF   00
09FE:  BTFSC  39.7
0A00:  BSF    00.0
0A02:  BCF    x22.7
0A04:  BTFSC  00.0
0A06:  BSF    x22.7
....................     
....................    EEpDat = read_eeprom(0x06);   // Fault type 9-16 
0A08:  MOVFF  FF2,1E7
0A0C:  BCF    FF2.7
0A0E:  MOVLW  06
0A10:  MOVWF  FA9
0A12:  BCF    FA6.6
0A14:  BCF    FA6.7
0A16:  BSF    FA6.0
0A18:  MOVF   FA8,W
0A1A:  BTFSC  xE7.7
0A1C:  BSF    FF2.7
0A1E:  MOVWF  39
....................    FaultType17_24 = EEpDat; 
0A20:  MOVFF  39,3F
....................  
....................    FaultType.B17 = EEpDat; 
0A24:  BCF    x23.0
0A26:  BTFSC  39.0
0A28:  BSF    x23.0
....................    FaultType.B18 = EEpDat >> 1; 
0A2A:  BCF    FD8.0
0A2C:  RRCF   39,W
0A2E:  BCF    x23.1
0A30:  BTFSC  FE8.0
0A32:  BSF    x23.1
....................    FaultType.B19 = EEpDat >> 2; 
0A34:  RRCF   39,W
0A36:  MOVWF  00
0A38:  RRCF   00,F
0A3A:  MOVLW  3F
0A3C:  ANDWF  00,F
0A3E:  BCF    x23.2
0A40:  BTFSC  00.0
0A42:  BSF    x23.2
....................    FaultType.B20 = EEpDat >> 3; 
0A44:  RRCF   39,W
0A46:  MOVWF  00
0A48:  RRCF   00,F
0A4A:  RRCF   00,F
0A4C:  MOVLW  1F
0A4E:  ANDWF  00,F
0A50:  BCF    x23.3
0A52:  BTFSC  00.0
0A54:  BSF    x23.3
....................    FaultType.B21 = EEpDat >> 4; 
0A56:  SWAPF  39,W
0A58:  MOVWF  00
0A5A:  MOVLW  0F
0A5C:  ANDWF  00,F
0A5E:  BCF    x23.4
0A60:  BTFSC  00.0
0A62:  BSF    x23.4
....................    FaultType.B22 = EEpDat >> 5; 
0A64:  SWAPF  39,W
0A66:  MOVWF  00
0A68:  RRCF   00,F
0A6A:  MOVLW  07
0A6C:  ANDWF  00,F
0A6E:  BCF    x23.5
0A70:  BTFSC  00.0
0A72:  BSF    x23.5
....................    FaultType.B23 = EEpDat >> 6; 
0A74:  SWAPF  39,W
0A76:  MOVWF  00
0A78:  RRCF   00,F
0A7A:  RRCF   00,F
0A7C:  MOVLW  03
0A7E:  ANDWF  00,F
0A80:  BCF    x23.6
0A82:  BTFSC  00.0
0A84:  BSF    x23.6
....................    FaultType.B24 = EEpDat >> 7; 
0A86:  CLRF   00
0A88:  BTFSC  39.7
0A8A:  BSF    00.0
0A8C:  BCF    x23.7
0A8E:  BTFSC  00.0
0A90:  BSF    x23.7
....................  
....................  
....................    //////////////////////////////////////////////// 
....................  
....................    EEpDat = read_eeprom(0x07);   // Output type 1-8 
0A92:  MOVFF  FF2,1E7
0A96:  BCF    FF2.7
0A98:  MOVLW  07
0A9A:  MOVWF  FA9
0A9C:  BCF    FA6.6
0A9E:  BCF    FA6.7
0AA0:  BSF    FA6.0
0AA2:  MOVF   FA8,W
0AA4:  BTFSC  xE7.7
0AA6:  BSF    FF2.7
0AA8:  MOVWF  39
....................    OutputType1_8 = EEpDat; 
0AAA:  MOVFF  39,40
....................  
....................    OutputType.B1 = EEpDat; 
0AAE:  BCF    x25.0
0AB0:  BTFSC  39.0
0AB2:  BSF    x25.0
....................    OutputType.B2 = EEpDat >> 1; 
0AB4:  BCF    FD8.0
0AB6:  RRCF   39,W
0AB8:  BCF    x25.1
0ABA:  BTFSC  FE8.0
0ABC:  BSF    x25.1
....................    OutputType.B3 = EEpDat >> 2; 
0ABE:  RRCF   39,W
0AC0:  MOVWF  00
0AC2:  RRCF   00,F
0AC4:  MOVLW  3F
0AC6:  ANDWF  00,F
0AC8:  BCF    x25.2
0ACA:  BTFSC  00.0
0ACC:  BSF    x25.2
....................    OutputType.B4 = EEpDat >> 3; 
0ACE:  RRCF   39,W
0AD0:  MOVWF  00
0AD2:  RRCF   00,F
0AD4:  RRCF   00,F
0AD6:  MOVLW  1F
0AD8:  ANDWF  00,F
0ADA:  BCF    x25.3
0ADC:  BTFSC  00.0
0ADE:  BSF    x25.3
....................    OutputType.B5 = EEpDat >> 4; 
0AE0:  SWAPF  39,W
0AE2:  MOVWF  00
0AE4:  MOVLW  0F
0AE6:  ANDWF  00,F
0AE8:  BCF    x25.4
0AEA:  BTFSC  00.0
0AEC:  BSF    x25.4
....................    OutputType.B6 = EEpDat >> 5; 
0AEE:  SWAPF  39,W
0AF0:  MOVWF  00
0AF2:  RRCF   00,F
0AF4:  MOVLW  07
0AF6:  ANDWF  00,F
0AF8:  BCF    x25.5
0AFA:  BTFSC  00.0
0AFC:  BSF    x25.5
....................    OutputType.B7 = EEpDat >> 6; 
0AFE:  SWAPF  39,W
0B00:  MOVWF  00
0B02:  RRCF   00,F
0B04:  RRCF   00,F
0B06:  MOVLW  03
0B08:  ANDWF  00,F
0B0A:  BCF    x25.6
0B0C:  BTFSC  00.0
0B0E:  BSF    x25.6
....................    OutputType.B8 = EEpDat >> 7; 
0B10:  CLRF   00
0B12:  BTFSC  39.7
0B14:  BSF    00.0
0B16:  BCF    x25.7
0B18:  BTFSC  00.0
0B1A:  BSF    x25.7
....................  
....................    EEpDat = read_eeprom(0x08);   // Output type 9-16 
0B1C:  MOVFF  FF2,1E7
0B20:  BCF    FF2.7
0B22:  MOVLW  08
0B24:  MOVWF  FA9
0B26:  BCF    FA6.6
0B28:  BCF    FA6.7
0B2A:  BSF    FA6.0
0B2C:  MOVF   FA8,W
0B2E:  BTFSC  xE7.7
0B30:  BSF    FF2.7
0B32:  MOVWF  39
....................    OutputType9_16 = EEpDat; 
0B34:  MOVFF  39,41
....................  
....................    OutputType.B9 = EEpDat; 
0B38:  BCF    x26.0
0B3A:  BTFSC  39.0
0B3C:  BSF    x26.0
....................    OutputType.B10 = EEpDat >> 1; 
0B3E:  BCF    FD8.0
0B40:  RRCF   39,W
0B42:  BCF    x26.1
0B44:  BTFSC  FE8.0
0B46:  BSF    x26.1
....................    OutputType.B11 = EEpDat >> 2; 
0B48:  RRCF   39,W
0B4A:  MOVWF  00
0B4C:  RRCF   00,F
0B4E:  MOVLW  3F
0B50:  ANDWF  00,F
0B52:  BCF    x26.2
0B54:  BTFSC  00.0
0B56:  BSF    x26.2
....................    OutputType.B12 = EEpDat >> 3; 
0B58:  RRCF   39,W
0B5A:  MOVWF  00
0B5C:  RRCF   00,F
0B5E:  RRCF   00,F
0B60:  MOVLW  1F
0B62:  ANDWF  00,F
0B64:  BCF    x26.3
0B66:  BTFSC  00.0
0B68:  BSF    x26.3
....................    OutputType.B13 = EEpDat >> 4; 
0B6A:  SWAPF  39,W
0B6C:  MOVWF  00
0B6E:  MOVLW  0F
0B70:  ANDWF  00,F
0B72:  BCF    x26.4
0B74:  BTFSC  00.0
0B76:  BSF    x26.4
....................    OutputType.B14 = EEpDat >> 5; 
0B78:  SWAPF  39,W
0B7A:  MOVWF  00
0B7C:  RRCF   00,F
0B7E:  MOVLW  07
0B80:  ANDWF  00,F
0B82:  BCF    x26.5
0B84:  BTFSC  00.0
0B86:  BSF    x26.5
....................    OutputType.B15 = EEpDat >> 6; 
0B88:  SWAPF  39,W
0B8A:  MOVWF  00
0B8C:  RRCF   00,F
0B8E:  RRCF   00,F
0B90:  MOVLW  03
0B92:  ANDWF  00,F
0B94:  BCF    x26.6
0B96:  BTFSC  00.0
0B98:  BSF    x26.6
....................    OutputType.B16 = EEpDat >> 7; 
0B9A:  CLRF   00
0B9C:  BTFSC  39.7
0B9E:  BSF    00.0
0BA0:  BCF    x26.7
0BA2:  BTFSC  00.0
0BA4:  BSF    x26.7
....................     
....................    EEpDat = read_eeprom(0x09);   // Output type 9-16 
0BA6:  MOVFF  FF2,1E7
0BAA:  BCF    FF2.7
0BAC:  MOVLW  09
0BAE:  MOVWF  FA9
0BB0:  BCF    FA6.6
0BB2:  BCF    FA6.7
0BB4:  BSF    FA6.0
0BB6:  MOVF   FA8,W
0BB8:  BTFSC  xE7.7
0BBA:  BSF    FF2.7
0BBC:  MOVWF  39
....................    OutputType17_24 = EEpDat; 
0BBE:  MOVFF  39,42
....................  
....................    OutputType.B17 = EEpDat; 
0BC2:  BCF    x27.0
0BC4:  BTFSC  39.0
0BC6:  BSF    x27.0
....................    OutputType.B18 = EEpDat >> 1; 
0BC8:  BCF    FD8.0
0BCA:  RRCF   39,W
0BCC:  BCF    x27.1
0BCE:  BTFSC  FE8.0
0BD0:  BSF    x27.1
....................    OutputType.B19 = EEpDat >> 2; 
0BD2:  RRCF   39,W
0BD4:  MOVWF  00
0BD6:  RRCF   00,F
0BD8:  MOVLW  3F
0BDA:  ANDWF  00,F
0BDC:  BCF    x27.2
0BDE:  BTFSC  00.0
0BE0:  BSF    x27.2
....................    OutputType.B20 = EEpDat >> 3; 
0BE2:  RRCF   39,W
0BE4:  MOVWF  00
0BE6:  RRCF   00,F
0BE8:  RRCF   00,F
0BEA:  MOVLW  1F
0BEC:  ANDWF  00,F
0BEE:  BCF    x27.3
0BF0:  BTFSC  00.0
0BF2:  BSF    x27.3
....................    OutputType.B21 = EEpDat >> 4; 
0BF4:  SWAPF  39,W
0BF6:  MOVWF  00
0BF8:  MOVLW  0F
0BFA:  ANDWF  00,F
0BFC:  BCF    x27.4
0BFE:  BTFSC  00.0
0C00:  BSF    x27.4
....................    OutputType.B22 = EEpDat >> 5; 
0C02:  SWAPF  39,W
0C04:  MOVWF  00
0C06:  RRCF   00,F
0C08:  MOVLW  07
0C0A:  ANDWF  00,F
0C0C:  BCF    x27.5
0C0E:  BTFSC  00.0
0C10:  BSF    x27.5
....................    OutputType.B23 = EEpDat >> 6; 
0C12:  SWAPF  39,W
0C14:  MOVWF  00
0C16:  RRCF   00,F
0C18:  RRCF   00,F
0C1A:  MOVLW  03
0C1C:  ANDWF  00,F
0C1E:  BCF    x27.6
0C20:  BTFSC  00.0
0C22:  BSF    x27.6
....................    OutputType.B24 = EEpDat >> 7; 
0C24:  CLRF   00
0C26:  BTFSC  39.7
0C28:  BSF    00.0
0C2A:  BCF    x27.7
0C2C:  BTFSC  00.0
0C2E:  BSF    x27.7
....................  
....................  
....................    //////////////////////////////////////// 
....................  
....................    EEpDat = read_eeprom(0x0A);   // Output Both 1-8 
0C30:  MOVFF  FF2,1E7
0C34:  BCF    FF2.7
0C36:  MOVLW  0A
0C38:  MOVWF  FA9
0C3A:  BCF    FA6.6
0C3C:  BCF    FA6.7
0C3E:  BSF    FA6.0
0C40:  MOVF   FA8,W
0C42:  BTFSC  xE7.7
0C44:  BSF    FF2.7
0C46:  MOVWF  39
....................    OutputBoth1_8 = EEpDat; 
0C48:  MOVFF  39,43
....................  
....................    OutputBoth.B1 = EEpDat; 
0C4C:  BCF    x29.0
0C4E:  BTFSC  39.0
0C50:  BSF    x29.0
....................    OutputBoth.B2 = EEpDat >> 1; 
0C52:  BCF    FD8.0
0C54:  RRCF   39,W
0C56:  BCF    x29.1
0C58:  BTFSC  FE8.0
0C5A:  BSF    x29.1
....................    OutputBoth.B3 = EEpDat >> 2; 
0C5C:  RRCF   39,W
0C5E:  MOVWF  00
0C60:  RRCF   00,F
0C62:  MOVLW  3F
0C64:  ANDWF  00,F
0C66:  BCF    x29.2
0C68:  BTFSC  00.0
0C6A:  BSF    x29.2
....................    OutputBoth.B4 = EEpDat >> 3; 
0C6C:  RRCF   39,W
0C6E:  MOVWF  00
0C70:  RRCF   00,F
0C72:  RRCF   00,F
0C74:  MOVLW  1F
0C76:  ANDWF  00,F
0C78:  BCF    x29.3
0C7A:  BTFSC  00.0
0C7C:  BSF    x29.3
....................    OutputBoth.B5 = EEpDat >> 4; 
0C7E:  SWAPF  39,W
0C80:  MOVWF  00
0C82:  MOVLW  0F
0C84:  ANDWF  00,F
0C86:  BCF    x29.4
0C88:  BTFSC  00.0
0C8A:  BSF    x29.4
....................    OutputBoth.B6 = EEpDat >> 5; 
0C8C:  SWAPF  39,W
0C8E:  MOVWF  00
0C90:  RRCF   00,F
0C92:  MOVLW  07
0C94:  ANDWF  00,F
0C96:  BCF    x29.5
0C98:  BTFSC  00.0
0C9A:  BSF    x29.5
....................    OutputBoth.B7 = EEpDat >> 6; 
0C9C:  SWAPF  39,W
0C9E:  MOVWF  00
0CA0:  RRCF   00,F
0CA2:  RRCF   00,F
0CA4:  MOVLW  03
0CA6:  ANDWF  00,F
0CA8:  BCF    x29.6
0CAA:  BTFSC  00.0
0CAC:  BSF    x29.6
....................    OutputBoth.B8 = EEpDat >> 7; 
0CAE:  CLRF   00
0CB0:  BTFSC  39.7
0CB2:  BSF    00.0
0CB4:  BCF    x29.7
0CB6:  BTFSC  00.0
0CB8:  BSF    x29.7
....................  
....................    EEpDat = read_eeprom(0x0B);   // Output Both 9-16 
0CBA:  MOVFF  FF2,1E7
0CBE:  BCF    FF2.7
0CC0:  MOVLW  0B
0CC2:  MOVWF  FA9
0CC4:  BCF    FA6.6
0CC6:  BCF    FA6.7
0CC8:  BSF    FA6.0
0CCA:  MOVF   FA8,W
0CCC:  BTFSC  xE7.7
0CCE:  BSF    FF2.7
0CD0:  MOVWF  39
....................    OutputBoth9_16 = EEpDat; 
0CD2:  MOVFF  39,44
....................  
....................    OutputBoth.B9 = EEpDat; 
0CD6:  BCF    x2A.0
0CD8:  BTFSC  39.0
0CDA:  BSF    x2A.0
....................    OutputBoth.B10 = EEpDat >> 1; 
0CDC:  BCF    FD8.0
0CDE:  RRCF   39,W
0CE0:  BCF    x2A.1
0CE2:  BTFSC  FE8.0
0CE4:  BSF    x2A.1
....................    OutputBoth.B11 = EEpDat >> 2; 
0CE6:  RRCF   39,W
0CE8:  MOVWF  00
0CEA:  RRCF   00,F
0CEC:  MOVLW  3F
0CEE:  ANDWF  00,F
0CF0:  BCF    x2A.2
0CF2:  BTFSC  00.0
0CF4:  BSF    x2A.2
....................    OutputBoth.B12 = EEpDat >> 3; 
0CF6:  RRCF   39,W
0CF8:  MOVWF  00
0CFA:  RRCF   00,F
0CFC:  RRCF   00,F
0CFE:  MOVLW  1F
0D00:  ANDWF  00,F
0D02:  BCF    x2A.3
0D04:  BTFSC  00.0
0D06:  BSF    x2A.3
....................    OutputBoth.B13 = EEpDat >> 4; 
0D08:  SWAPF  39,W
0D0A:  MOVWF  00
0D0C:  MOVLW  0F
0D0E:  ANDWF  00,F
0D10:  BCF    x2A.4
0D12:  BTFSC  00.0
0D14:  BSF    x2A.4
....................    OutputBoth.B14 = EEpDat >> 5; 
0D16:  SWAPF  39,W
0D18:  MOVWF  00
0D1A:  RRCF   00,F
0D1C:  MOVLW  07
0D1E:  ANDWF  00,F
0D20:  BCF    x2A.5
0D22:  BTFSC  00.0
0D24:  BSF    x2A.5
....................    OutputBoth.B15 = EEpDat >> 6; 
0D26:  SWAPF  39,W
0D28:  MOVWF  00
0D2A:  RRCF   00,F
0D2C:  RRCF   00,F
0D2E:  MOVLW  03
0D30:  ANDWF  00,F
0D32:  BCF    x2A.6
0D34:  BTFSC  00.0
0D36:  BSF    x2A.6
....................    OutputBoth.B16 = EEpDat >> 7; 
0D38:  CLRF   00
0D3A:  BTFSC  39.7
0D3C:  BSF    00.0
0D3E:  BCF    x2A.7
0D40:  BTFSC  00.0
0D42:  BSF    x2A.7
....................     
....................    EEpDat = read_eeprom(0x0C);   // Output Both 9-16 
0D44:  MOVFF  FF2,1E7
0D48:  BCF    FF2.7
0D4A:  MOVLW  0C
0D4C:  MOVWF  FA9
0D4E:  BCF    FA6.6
0D50:  BCF    FA6.7
0D52:  BSF    FA6.0
0D54:  MOVF   FA8,W
0D56:  BTFSC  xE7.7
0D58:  BSF    FF2.7
0D5A:  MOVWF  39
....................    OutputBoth17_24 = EEpDat; 
0D5C:  MOVFF  39,45
....................  
....................    OutputBoth.B17 = EEpDat; 
0D60:  BCF    x2B.0
0D62:  BTFSC  39.0
0D64:  BSF    x2B.0
....................    OutputBoth.B18 = EEpDat >> 1; 
0D66:  BCF    FD8.0
0D68:  RRCF   39,W
0D6A:  BCF    x2B.1
0D6C:  BTFSC  FE8.0
0D6E:  BSF    x2B.1
....................    OutputBoth.B19 = EEpDat >> 2; 
0D70:  RRCF   39,W
0D72:  MOVWF  00
0D74:  RRCF   00,F
0D76:  MOVLW  3F
0D78:  ANDWF  00,F
0D7A:  BCF    x2B.2
0D7C:  BTFSC  00.0
0D7E:  BSF    x2B.2
....................    OutputBoth.B20 = EEpDat >> 3; 
0D80:  RRCF   39,W
0D82:  MOVWF  00
0D84:  RRCF   00,F
0D86:  RRCF   00,F
0D88:  MOVLW  1F
0D8A:  ANDWF  00,F
0D8C:  BCF    x2B.3
0D8E:  BTFSC  00.0
0D90:  BSF    x2B.3
....................    OutputBoth.B21 = EEpDat >> 4; 
0D92:  SWAPF  39,W
0D94:  MOVWF  00
0D96:  MOVLW  0F
0D98:  ANDWF  00,F
0D9A:  BCF    x2B.4
0D9C:  BTFSC  00.0
0D9E:  BSF    x2B.4
....................    OutputBoth.B22 = EEpDat >> 5; 
0DA0:  SWAPF  39,W
0DA2:  MOVWF  00
0DA4:  RRCF   00,F
0DA6:  MOVLW  07
0DA8:  ANDWF  00,F
0DAA:  BCF    x2B.5
0DAC:  BTFSC  00.0
0DAE:  BSF    x2B.5
....................    OutputBoth.B23 = EEpDat >> 6; 
0DB0:  SWAPF  39,W
0DB2:  MOVWF  00
0DB4:  RRCF   00,F
0DB6:  RRCF   00,F
0DB8:  MOVLW  03
0DBA:  ANDWF  00,F
0DBC:  BCF    x2B.6
0DBE:  BTFSC  00.0
0DC0:  BSF    x2B.6
....................    OutputBoth.B24 = EEpDat >> 7; 
0DC2:  CLRF   00
0DC4:  BTFSC  39.7
0DC6:  BSF    00.0
0DC8:  BCF    x2B.7
0DCA:  BTFSC  00.0
0DCC:  BSF    x2B.7
....................  
....................  
....................    ///////////////////////////////////////////////// 
....................  
....................    EEpDat = read_eeprom(0x0D);   // AlarmIndicator 1-8 
0DCE:  MOVFF  FF2,1E7
0DD2:  BCF    FF2.7
0DD4:  MOVLW  0D
0DD6:  MOVWF  FA9
0DD8:  BCF    FA6.6
0DDA:  BCF    FA6.7
0DDC:  BSF    FA6.0
0DDE:  MOVF   FA8,W
0DE0:  BTFSC  xE7.7
0DE2:  BSF    FF2.7
0DE4:  MOVWF  39
....................    Alarm_Indicator1_8 = EEpDat; 
0DE6:  MOVFF  39,46
....................  
....................    AlarmIndicator.B1 = EEpDat; 
0DEA:  BCF    x2D.0
0DEC:  BTFSC  39.0
0DEE:  BSF    x2D.0
....................    AlarmIndicator.B2 = EEpDat >> 1; 
0DF0:  BCF    FD8.0
0DF2:  RRCF   39,W
0DF4:  BCF    x2D.1
0DF6:  BTFSC  FE8.0
0DF8:  BSF    x2D.1
....................    AlarmIndicator.B3 = EEpDat >> 2; 
0DFA:  RRCF   39,W
0DFC:  MOVWF  00
0DFE:  RRCF   00,F
0E00:  MOVLW  3F
0E02:  ANDWF  00,F
0E04:  BCF    x2D.2
0E06:  BTFSC  00.0
0E08:  BSF    x2D.2
....................    AlarmIndicator.B4 = EEpDat >> 3; 
0E0A:  RRCF   39,W
0E0C:  MOVWF  00
0E0E:  RRCF   00,F
0E10:  RRCF   00,F
0E12:  MOVLW  1F
0E14:  ANDWF  00,F
0E16:  BCF    x2D.3
0E18:  BTFSC  00.0
0E1A:  BSF    x2D.3
....................    AlarmIndicator.B5 = EEpDat >> 4; 
0E1C:  SWAPF  39,W
0E1E:  MOVWF  00
0E20:  MOVLW  0F
0E22:  ANDWF  00,F
0E24:  BCF    x2D.4
0E26:  BTFSC  00.0
0E28:  BSF    x2D.4
....................    AlarmIndicator.B6 = EEpDat >> 5; 
0E2A:  SWAPF  39,W
0E2C:  MOVWF  00
0E2E:  RRCF   00,F
0E30:  MOVLW  07
0E32:  ANDWF  00,F
0E34:  BCF    x2D.5
0E36:  BTFSC  00.0
0E38:  BSF    x2D.5
....................    AlarmIndicator.B7 = EEpDat >> 6; 
0E3A:  SWAPF  39,W
0E3C:  MOVWF  00
0E3E:  RRCF   00,F
0E40:  RRCF   00,F
0E42:  MOVLW  03
0E44:  ANDWF  00,F
0E46:  BCF    x2D.6
0E48:  BTFSC  00.0
0E4A:  BSF    x2D.6
....................    AlarmIndicator.B8 = EEpDat >> 7; 
0E4C:  CLRF   00
0E4E:  BTFSC  39.7
0E50:  BSF    00.0
0E52:  BCF    x2D.7
0E54:  BTFSC  00.0
0E56:  BSF    x2D.7
....................  
....................    EEpDat = read_eeprom(0x0E);   // AlarmIndicator 9-16 
0E58:  MOVFF  FF2,1E7
0E5C:  BCF    FF2.7
0E5E:  MOVLW  0E
0E60:  MOVWF  FA9
0E62:  BCF    FA6.6
0E64:  BCF    FA6.7
0E66:  BSF    FA6.0
0E68:  MOVF   FA8,W
0E6A:  BTFSC  xE7.7
0E6C:  BSF    FF2.7
0E6E:  MOVWF  39
....................    Alarm_Indicator9_16 = EEpDat; 
0E70:  MOVFF  39,47
....................  
....................    AlarmIndicator.B9 = EEpDat; 
0E74:  BCF    x2E.0
0E76:  BTFSC  39.0
0E78:  BSF    x2E.0
....................    AlarmIndicator.B10 = EEpDat >> 1; 
0E7A:  BCF    FD8.0
0E7C:  RRCF   39,W
0E7E:  BCF    x2E.1
0E80:  BTFSC  FE8.0
0E82:  BSF    x2E.1
....................    AlarmIndicator.B11 = EEpDat >> 2; 
0E84:  RRCF   39,W
0E86:  MOVWF  00
0E88:  RRCF   00,F
0E8A:  MOVLW  3F
0E8C:  ANDWF  00,F
0E8E:  BCF    x2E.2
0E90:  BTFSC  00.0
0E92:  BSF    x2E.2
....................    AlarmIndicator.B12 = EEpDat >> 3; 
0E94:  RRCF   39,W
0E96:  MOVWF  00
0E98:  RRCF   00,F
0E9A:  RRCF   00,F
0E9C:  MOVLW  1F
0E9E:  ANDWF  00,F
0EA0:  BCF    x2E.3
0EA2:  BTFSC  00.0
0EA4:  BSF    x2E.3
....................    AlarmIndicator.B13 = EEpDat >> 4; 
0EA6:  SWAPF  39,W
0EA8:  MOVWF  00
0EAA:  MOVLW  0F
0EAC:  ANDWF  00,F
0EAE:  BCF    x2E.4
0EB0:  BTFSC  00.0
0EB2:  BSF    x2E.4
....................    AlarmIndicator.B14 = EEpDat >> 5; 
0EB4:  SWAPF  39,W
0EB6:  MOVWF  00
0EB8:  RRCF   00,F
0EBA:  MOVLW  07
0EBC:  ANDWF  00,F
0EBE:  BCF    x2E.5
0EC0:  BTFSC  00.0
0EC2:  BSF    x2E.5
....................    AlarmIndicator.B15 = EEpDat >> 6; 
0EC4:  SWAPF  39,W
0EC6:  MOVWF  00
0EC8:  RRCF   00,F
0ECA:  RRCF   00,F
0ECC:  MOVLW  03
0ECE:  ANDWF  00,F
0ED0:  BCF    x2E.6
0ED2:  BTFSC  00.0
0ED4:  BSF    x2E.6
....................    AlarmIndicator.B16 = EEpDat >> 7; 
0ED6:  CLRF   00
0ED8:  BTFSC  39.7
0EDA:  BSF    00.0
0EDC:  BCF    x2E.7
0EDE:  BTFSC  00.0
0EE0:  BSF    x2E.7
....................     
....................    EEpDat = read_eeprom(0x0F);   // AlarmIndicator 9-16 
0EE2:  MOVFF  FF2,1E7
0EE6:  BCF    FF2.7
0EE8:  MOVLW  0F
0EEA:  MOVWF  FA9
0EEC:  BCF    FA6.6
0EEE:  BCF    FA6.7
0EF0:  BSF    FA6.0
0EF2:  MOVF   FA8,W
0EF4:  BTFSC  xE7.7
0EF6:  BSF    FF2.7
0EF8:  MOVWF  39
....................    Alarm_Indicator17_24 = EEpDat; 
0EFA:  MOVFF  39,48
....................  
....................    AlarmIndicator.B17 = EEpDat; 
0EFE:  BCF    x2F.0
0F00:  BTFSC  39.0
0F02:  BSF    x2F.0
....................    AlarmIndicator.B18 = EEpDat >> 1; 
0F04:  BCF    FD8.0
0F06:  RRCF   39,W
0F08:  BCF    x2F.1
0F0A:  BTFSC  FE8.0
0F0C:  BSF    x2F.1
....................    AlarmIndicator.B19 = EEpDat >> 2; 
0F0E:  RRCF   39,W
0F10:  MOVWF  00
0F12:  RRCF   00,F
0F14:  MOVLW  3F
0F16:  ANDWF  00,F
0F18:  BCF    x2F.2
0F1A:  BTFSC  00.0
0F1C:  BSF    x2F.2
....................    AlarmIndicator.B20 = EEpDat >> 3; 
0F1E:  RRCF   39,W
0F20:  MOVWF  00
0F22:  RRCF   00,F
0F24:  RRCF   00,F
0F26:  MOVLW  1F
0F28:  ANDWF  00,F
0F2A:  BCF    x2F.3
0F2C:  BTFSC  00.0
0F2E:  BSF    x2F.3
....................    AlarmIndicator.B21 = EEpDat >> 4; 
0F30:  SWAPF  39,W
0F32:  MOVWF  00
0F34:  MOVLW  0F
0F36:  ANDWF  00,F
0F38:  BCF    x2F.4
0F3A:  BTFSC  00.0
0F3C:  BSF    x2F.4
....................    AlarmIndicator.B22 = EEpDat >> 5; 
0F3E:  SWAPF  39,W
0F40:  MOVWF  00
0F42:  RRCF   00,F
0F44:  MOVLW  07
0F46:  ANDWF  00,F
0F48:  BCF    x2F.5
0F4A:  BTFSC  00.0
0F4C:  BSF    x2F.5
....................    AlarmIndicator.B23 = EEpDat >> 6; 
0F4E:  SWAPF  39,W
0F50:  MOVWF  00
0F52:  RRCF   00,F
0F54:  RRCF   00,F
0F56:  MOVLW  03
0F58:  ANDWF  00,F
0F5A:  BCF    x2F.6
0F5C:  BTFSC  00.0
0F5E:  BSF    x2F.6
....................    AlarmIndicator.B24 = EEpDat >> 7; 
0F60:  CLRF   00
0F62:  BTFSC  39.7
0F64:  BSF    00.0
0F66:  BCF    x2F.7
0F68:  BTFSC  00.0
0F6A:  BSF    x2F.7
....................  
....................    ////////////////////////////////////////////////// 
....................    EEpDat = read_eeprom(0x10); 
0F6C:  MOVFF  FF2,1E7
0F70:  BCF    FF2.7
0F72:  MOVLW  10
0F74:  MOVWF  FA9
0F76:  BCF    FA6.6
0F78:  BCF    FA6.7
0F7A:  BSF    FA6.0
0F7C:  MOVF   FA8,W
0F7E:  BTFSC  xE7.7
0F80:  BSF    FF2.7
0F82:  MOVWF  39
....................    //Red1_8 = EEpDat; 
....................    RED_Colour.B1 = EEpDat; 
0F84:  BCF    x45.0
0F86:  BTFSC  39.0
0F88:  BSF    x45.0
....................    RED_Colour.B2 = EEpDat >> 1; 
0F8A:  BCF    FD8.0
0F8C:  RRCF   39,W
0F8E:  BCF    x45.1
0F90:  BTFSC  FE8.0
0F92:  BSF    x45.1
....................    RED_Colour.B3 = EEpDat >> 2; 
0F94:  RRCF   39,W
0F96:  MOVWF  00
0F98:  RRCF   00,F
0F9A:  MOVLW  3F
0F9C:  ANDWF  00,F
0F9E:  BCF    x45.2
0FA0:  BTFSC  00.0
0FA2:  BSF    x45.2
....................    RED_Colour.B4 = EEpDat >> 3; 
0FA4:  RRCF   39,W
0FA6:  MOVWF  00
0FA8:  RRCF   00,F
0FAA:  RRCF   00,F
0FAC:  MOVLW  1F
0FAE:  ANDWF  00,F
0FB0:  BCF    x45.3
0FB2:  BTFSC  00.0
0FB4:  BSF    x45.3
....................    RED_Colour.B5 = EEpDat >> 4; 
0FB6:  SWAPF  39,W
0FB8:  MOVWF  00
0FBA:  MOVLW  0F
0FBC:  ANDWF  00,F
0FBE:  BCF    x45.4
0FC0:  BTFSC  00.0
0FC2:  BSF    x45.4
....................    RED_Colour.B6 = EEpDat >> 5; 
0FC4:  SWAPF  39,W
0FC6:  MOVWF  00
0FC8:  RRCF   00,F
0FCA:  MOVLW  07
0FCC:  ANDWF  00,F
0FCE:  BCF    x45.5
0FD0:  BTFSC  00.0
0FD2:  BSF    x45.5
....................    RED_Colour.B7 = EEpDat >> 6; 
0FD4:  SWAPF  39,W
0FD6:  MOVWF  00
0FD8:  RRCF   00,F
0FDA:  RRCF   00,F
0FDC:  MOVLW  03
0FDE:  ANDWF  00,F
0FE0:  BCF    x45.6
0FE2:  BTFSC  00.0
0FE4:  BSF    x45.6
....................    RED_Colour.B8 = EEpDat >> 7; 
0FE6:  CLRF   00
0FE8:  BTFSC  39.7
0FEA:  BSF    00.0
0FEC:  BCF    x45.7
0FEE:  BTFSC  00.0
0FF0:  BSF    x45.7
....................     
....................    EEpDat = read_eeprom(0x11); 
0FF2:  MOVFF  FF2,1E7
0FF6:  BCF    FF2.7
0FF8:  MOVLW  11
0FFA:  MOVWF  FA9
0FFC:  BCF    FA6.6
0FFE:  BCF    FA6.7
1000:  BSF    FA6.0
1002:  MOVF   FA8,W
1004:  BTFSC  xE7.7
1006:  BSF    FF2.7
1008:  MOVWF  39
....................    //Green9_10 = EEpDat; 
....................    RED_Colour.B9 = EEpDat; 
100A:  BCF    x46.0
100C:  BTFSC  39.0
100E:  BSF    x46.0
....................    RED_Colour.B10 = EEpDat >> 1; 
1010:  BCF    FD8.0
1012:  RRCF   39,W
1014:  BCF    x46.1
1016:  BTFSC  FE8.0
1018:  BSF    x46.1
....................     
....................     
....................    EEpDat = read_eeprom(0x12); 
101A:  MOVFF  FF2,1E7
101E:  BCF    FF2.7
1020:  MOVLW  12
1022:  MOVWF  FA9
1024:  BCF    FA6.6
1026:  BCF    FA6.7
1028:  BSF    FA6.0
102A:  MOVF   FA8,W
102C:  BTFSC  xE7.7
102E:  BSF    FF2.7
1030:  MOVWF  39
....................    //Red11_18 = EEpDat; 
....................    RED_Colour.B11 = EEpDat; 
1032:  BCF    x46.2
1034:  BTFSC  39.0
1036:  BSF    x46.2
....................    RED_Colour.B12 = EEpDat >> 1; 
1038:  BCF    FD8.0
103A:  RRCF   39,W
103C:  BCF    x46.3
103E:  BTFSC  FE8.0
1040:  BSF    x46.3
....................    RED_Colour.B13 = EEpDat >> 2; 
1042:  RRCF   39,W
1044:  MOVWF  00
1046:  RRCF   00,F
1048:  MOVLW  3F
104A:  ANDWF  00,F
104C:  BCF    x46.4
104E:  BTFSC  00.0
1050:  BSF    x46.4
....................    RED_Colour.B14 = EEpDat >> 3; 
1052:  RRCF   39,W
1054:  MOVWF  00
1056:  RRCF   00,F
1058:  RRCF   00,F
105A:  MOVLW  1F
105C:  ANDWF  00,F
105E:  BCF    x46.5
1060:  BTFSC  00.0
1062:  BSF    x46.5
....................    RED_Colour.B15 = EEpDat >> 4; 
1064:  SWAPF  39,W
1066:  MOVWF  00
1068:  MOVLW  0F
106A:  ANDWF  00,F
106C:  BCF    x46.6
106E:  BTFSC  00.0
1070:  BSF    x46.6
....................    RED_Colour.B16 = EEpDat >> 5; 
1072:  SWAPF  39,W
1074:  MOVWF  00
1076:  RRCF   00,F
1078:  MOVLW  07
107A:  ANDWF  00,F
107C:  BCF    x46.7
107E:  BTFSC  00.0
1080:  BSF    x46.7
....................    RED_Colour.B17 = EEpDat >> 6; 
1082:  SWAPF  39,W
1084:  MOVWF  00
1086:  RRCF   00,F
1088:  RRCF   00,F
108A:  MOVLW  03
108C:  ANDWF  00,F
108E:  BCF    x47.0
1090:  BTFSC  00.0
1092:  BSF    x47.0
....................    RED_Colour.B18 = EEpDat >> 7; 
1094:  CLRF   00
1096:  BTFSC  39.7
1098:  BSF    00.0
109A:  BCF    x47.1
109C:  BTFSC  00.0
109E:  BSF    x47.1
....................     
....................    EEpDat = read_eeprom(0x13); 
10A0:  MOVFF  FF2,1E7
10A4:  BCF    FF2.7
10A6:  MOVLW  13
10A8:  MOVWF  FA9
10AA:  BCF    FA6.6
10AC:  BCF    FA6.7
10AE:  BSF    FA6.0
10B0:  MOVF   FA8,W
10B2:  BTFSC  xE7.7
10B4:  BSF    FF2.7
10B6:  MOVWF  39
....................    //Red19_20 = EEpDat; 
....................    RED_Colour.B19 = EEpDat; 
10B8:  BCF    x47.2
10BA:  BTFSC  39.0
10BC:  BSF    x47.2
....................    RED_Colour.B20 = EEpDat >> 1; 
10BE:  BCF    FD8.0
10C0:  RRCF   39,W
10C2:  BCF    x47.3
10C4:  BTFSC  FE8.0
10C6:  BSF    x47.3
....................     
....................     
....................    EEpDat = read_eeprom(0x14); 
10C8:  MOVFF  FF2,1E7
10CC:  BCF    FF2.7
10CE:  MOVLW  14
10D0:  MOVWF  FA9
10D2:  BCF    FA6.6
10D4:  BCF    FA6.7
10D6:  BSF    FA6.0
10D8:  MOVF   FA8,W
10DA:  BTFSC  xE7.7
10DC:  BSF    FF2.7
10DE:  MOVWF  39
....................    //Green1_8 = EEpDat; 
....................    GREEN_Colour.B1 = EEpDat; 
10E0:  BCF    x49.0
10E2:  BTFSC  39.0
10E4:  BSF    x49.0
....................    GREEN_Colour.B2 = EEpDat >> 1; 
10E6:  BCF    FD8.0
10E8:  RRCF   39,W
10EA:  BCF    x49.1
10EC:  BTFSC  FE8.0
10EE:  BSF    x49.1
....................    GREEN_Colour.B3 = EEpDat >> 2; 
10F0:  RRCF   39,W
10F2:  MOVWF  00
10F4:  RRCF   00,F
10F6:  MOVLW  3F
10F8:  ANDWF  00,F
10FA:  BCF    x49.2
10FC:  BTFSC  00.0
10FE:  BSF    x49.2
....................    GREEN_Colour.B4 = EEpDat >> 3; 
1100:  RRCF   39,W
1102:  MOVWF  00
1104:  RRCF   00,F
1106:  RRCF   00,F
1108:  MOVLW  1F
110A:  ANDWF  00,F
110C:  BCF    x49.3
110E:  BTFSC  00.0
1110:  BSF    x49.3
....................    GREEN_Colour.B5 = EEpDat >> 4; 
1112:  SWAPF  39,W
1114:  MOVWF  00
1116:  MOVLW  0F
1118:  ANDWF  00,F
111A:  BCF    x49.4
111C:  BTFSC  00.0
111E:  BSF    x49.4
....................    GREEN_Colour.B6 = EEpDat >> 5; 
1120:  SWAPF  39,W
1122:  MOVWF  00
1124:  RRCF   00,F
1126:  MOVLW  07
1128:  ANDWF  00,F
112A:  BCF    x49.5
112C:  BTFSC  00.0
112E:  BSF    x49.5
....................    GREEN_Colour.B7 = EEpDat >> 6; 
1130:  SWAPF  39,W
1132:  MOVWF  00
1134:  RRCF   00,F
1136:  RRCF   00,F
1138:  MOVLW  03
113A:  ANDWF  00,F
113C:  BCF    x49.6
113E:  BTFSC  00.0
1140:  BSF    x49.6
....................    GREEN_Colour.B8 = EEpDat >> 7; 
1142:  CLRF   00
1144:  BTFSC  39.7
1146:  BSF    00.0
1148:  BCF    x49.7
114A:  BTFSC  00.0
114C:  BSF    x49.7
....................     
....................    EEpDat = read_eeprom(0x15); 
114E:  MOVFF  FF2,1E7
1152:  BCF    FF2.7
1154:  MOVLW  15
1156:  MOVWF  FA9
1158:  BCF    FA6.6
115A:  BCF    FA6.7
115C:  BSF    FA6.0
115E:  MOVF   FA8,W
1160:  BTFSC  xE7.7
1162:  BSF    FF2.7
1164:  MOVWF  39
....................    //Green9_10 = EEpDat; 
....................    GREEN_Colour.B9 = EEpDat; 
1166:  BCF    x4A.0
1168:  BTFSC  39.0
116A:  BSF    x4A.0
....................    GREEN_Colour.B10 = EEpDat >> 1; 
116C:  BCF    FD8.0
116E:  RRCF   39,W
1170:  BCF    x4A.1
1172:  BTFSC  FE8.0
1174:  BSF    x4A.1
....................     
....................     
....................    EEpDat = read_eeprom(0x16); 
1176:  MOVFF  FF2,1E7
117A:  BCF    FF2.7
117C:  MOVLW  16
117E:  MOVWF  FA9
1180:  BCF    FA6.6
1182:  BCF    FA6.7
1184:  BSF    FA6.0
1186:  MOVF   FA8,W
1188:  BTFSC  xE7.7
118A:  BSF    FF2.7
118C:  MOVWF  39
....................    //Green11_18 = EEpDat; 
....................    GREEN_Colour.B11 = EEpDat; 
118E:  BCF    x4A.2
1190:  BTFSC  39.0
1192:  BSF    x4A.2
....................    GREEN_Colour.B12 = EEpDat >> 1; 
1194:  BCF    FD8.0
1196:  RRCF   39,W
1198:  BCF    x4A.3
119A:  BTFSC  FE8.0
119C:  BSF    x4A.3
....................    GREEN_Colour.B13 = EEpDat >> 2; 
119E:  RRCF   39,W
11A0:  MOVWF  00
11A2:  RRCF   00,F
11A4:  MOVLW  3F
11A6:  ANDWF  00,F
11A8:  BCF    x4A.4
11AA:  BTFSC  00.0
11AC:  BSF    x4A.4
....................    GREEN_Colour.B14 = EEpDat >> 3; 
11AE:  RRCF   39,W
11B0:  MOVWF  00
11B2:  RRCF   00,F
11B4:  RRCF   00,F
11B6:  MOVLW  1F
11B8:  ANDWF  00,F
11BA:  BCF    x4A.5
11BC:  BTFSC  00.0
11BE:  BSF    x4A.5
....................    GREEN_Colour.B15 = EEpDat >> 4; 
11C0:  SWAPF  39,W
11C2:  MOVWF  00
11C4:  MOVLW  0F
11C6:  ANDWF  00,F
11C8:  BCF    x4A.6
11CA:  BTFSC  00.0
11CC:  BSF    x4A.6
....................    GREEN_Colour.B16 = EEpDat >> 5; 
11CE:  SWAPF  39,W
11D0:  MOVWF  00
11D2:  RRCF   00,F
11D4:  MOVLW  07
11D6:  ANDWF  00,F
11D8:  BCF    x4A.7
11DA:  BTFSC  00.0
11DC:  BSF    x4A.7
....................    GREEN_Colour.B17 = EEpDat >> 6; 
11DE:  SWAPF  39,W
11E0:  MOVWF  00
11E2:  RRCF   00,F
11E4:  RRCF   00,F
11E6:  MOVLW  03
11E8:  ANDWF  00,F
11EA:  BCF    x4B.0
11EC:  BTFSC  00.0
11EE:  BSF    x4B.0
....................    GREEN_Colour.B18 = EEpDat >> 7; 
11F0:  CLRF   00
11F2:  BTFSC  39.7
11F4:  BSF    00.0
11F6:  BCF    x4B.1
11F8:  BTFSC  00.0
11FA:  BSF    x4B.1
....................     
....................    EEpDat = read_eeprom(0x17); 
11FC:  MOVFF  FF2,1E7
1200:  BCF    FF2.7
1202:  MOVLW  17
1204:  MOVWF  FA9
1206:  BCF    FA6.6
1208:  BCF    FA6.7
120A:  BSF    FA6.0
120C:  MOVF   FA8,W
120E:  BTFSC  xE7.7
1210:  BSF    FF2.7
1212:  MOVWF  39
....................    //Green19_20 = EEpDat; 
....................    GREEN_Colour.B19 = EEpDat; 
1214:  BCF    x4B.2
1216:  BTFSC  39.0
1218:  BSF    x4B.2
....................    GREEN_Colour.B20 = EEpDat >> 1; 
121A:  BCF    FD8.0
121C:  RRCF   39,W
121E:  BCF    x4B.3
1220:  BTFSC  FE8.0
1222:  BSF    x4B.3
....................     
....................    
....................  
....................    ////////////////////////////////////////////////// 
....................  
....................    AutoAck = read_eeprom(0x18);          // Auto Acknoeledge 
1224:  MOVFF  FF2,1E7
1228:  BCF    FF2.7
122A:  MOVLW  18
122C:  MOVWF  FA9
122E:  BCF    FA6.6
1230:  BCF    FA6.7
1232:  BSF    FA6.0
1234:  MOVF   FA8,W
1236:  BTFSC  xE7.7
1238:  BSF    FF2.7
123A:  MOVWF  60
....................    AutoAckTime = read_eeprom(0x19);      // Auto Acknoeledge Time 
123C:  MOVFF  FF2,1E7
1240:  BCF    FF2.7
1242:  MOVLW  19
1244:  MOVWF  FA9
1246:  BCF    FA6.6
1248:  BCF    FA6.7
124A:  BSF    FA6.0
124C:  MOVF   FA8,W
124E:  BTFSC  xE7.7
1250:  BSF    FF2.7
1252:  MOVWF  61
....................    FlashingRate = read_eeprom(0x1A); // Flashing rate 
1254:  MOVFF  FF2,1E7
1258:  BCF    FF2.7
125A:  MOVLW  1A
125C:  MOVWF  FA9
125E:  BCF    FA6.6
1260:  BCF    FA6.7
1262:  BSF    FA6.0
1264:  MOVF   FA8,W
1266:  BTFSC  xE7.7
1268:  BSF    FF2.7
126A:  MOVWF  62
....................    NoOfPoint = read_eeprom(0x1B);        // Number of total point 
126C:  MOVFF  FF2,1E7
1270:  BCF    FF2.7
1272:  MOVLW  1B
1274:  MOVWF  FA9
1276:  BCF    FA6.6
1278:  BCF    FA6.7
127A:  BSF    FA6.0
127C:  MOVF   FA8,W
127E:  BTFSC  xE7.7
1280:  BSF    FF2.7
1282:  MOVWF  63
....................    FaultDelayTime[0] = read_eeprom(0x1C);  // Master or slave sync(flashing) 
1284:  MOVFF  FF2,1E7
1288:  BCF    FF2.7
128A:  MOVLW  1C
128C:  MOVWF  FA9
128E:  BCF    FA6.6
1290:  BCF    FA6.7
1292:  BSF    FA6.0
1294:  MOVF   FA8,W
1296:  BTFSC  xE7.7
1298:  BSF    FF2.7
129A:  CLRF   x92
129C:  MOVWF  x91
....................  
....................    Address = read_eeprom(0x1D);          //Communication address 
129E:  MOVFF  FF2,1E7
12A2:  BCF    FF2.7
12A4:  MOVLW  1D
12A6:  MOVWF  FA9
12A8:  BCF    FA6.6
12AA:  BCF    FA6.7
12AC:  BSF    FA6.0
12AE:  MOVF   FA8,W
12B0:  BTFSC  xE7.7
12B2:  BSF    FF2.7
12B4:  MOVWF  6F
....................     
....................    FaultDelayTime[1] = read_eeprom(0x1E); 
12B6:  MOVFF  FF2,1E7
12BA:  BCF    FF2.7
12BC:  MOVLW  1E
12BE:  MOVWF  FA9
12C0:  BCF    FA6.6
12C2:  BCF    FA6.7
12C4:  BSF    FA6.0
12C6:  MOVF   FA8,W
12C8:  BTFSC  xE7.7
12CA:  BSF    FF2.7
12CC:  CLRF   x94
12CE:  MOVWF  x93
....................    FaultDelayTime[2] = read_eeprom(0x1F); 
12D0:  MOVFF  FF2,1E7
12D4:  BCF    FF2.7
12D6:  MOVLW  1F
12D8:  MOVWF  FA9
12DA:  BCF    FA6.6
12DC:  BCF    FA6.7
12DE:  BSF    FA6.0
12E0:  MOVF   FA8,W
12E2:  BTFSC  xE7.7
12E4:  BSF    FF2.7
12E6:  CLRF   x96
12E8:  MOVWF  x95
....................    FaultDelayTime[3] = read_eeprom(0x20); 
12EA:  MOVFF  FF2,1E7
12EE:  BCF    FF2.7
12F0:  MOVLW  20
12F2:  MOVWF  FA9
12F4:  BCF    FA6.6
12F6:  BCF    FA6.7
12F8:  BSF    FA6.0
12FA:  MOVF   FA8,W
12FC:  BTFSC  xE7.7
12FE:  BSF    FF2.7
1300:  CLRF   x98
1302:  MOVWF  x97
....................    FaultDelayTime[4] = read_eeprom(0x21); 
1304:  MOVFF  FF2,1E7
1308:  BCF    FF2.7
130A:  MOVLW  21
130C:  MOVWF  FA9
130E:  BCF    FA6.6
1310:  BCF    FA6.7
1312:  BSF    FA6.0
1314:  MOVF   FA8,W
1316:  BTFSC  xE7.7
1318:  BSF    FF2.7
131A:  CLRF   x9A
131C:  MOVWF  x99
....................    FaultDelayTime[5] = read_eeprom(0x22); 
131E:  MOVFF  FF2,1E7
1322:  BCF    FF2.7
1324:  MOVLW  22
1326:  MOVWF  FA9
1328:  BCF    FA6.6
132A:  BCF    FA6.7
132C:  BSF    FA6.0
132E:  MOVF   FA8,W
1330:  BTFSC  xE7.7
1332:  BSF    FF2.7
1334:  CLRF   x9C
1336:  MOVWF  x9B
....................    FaultDelayTime[6] = read_eeprom(0x23); 
1338:  MOVFF  FF2,1E7
133C:  BCF    FF2.7
133E:  MOVLW  23
1340:  MOVWF  FA9
1342:  BCF    FA6.6
1344:  BCF    FA6.7
1346:  BSF    FA6.0
1348:  MOVF   FA8,W
134A:  BTFSC  xE7.7
134C:  BSF    FF2.7
134E:  CLRF   x9E
1350:  MOVWF  x9D
....................    FaultDelayTime[7] = read_eeprom(0x24); 
1352:  MOVFF  FF2,1E7
1356:  BCF    FF2.7
1358:  MOVLW  24
135A:  MOVWF  FA9
135C:  BCF    FA6.6
135E:  BCF    FA6.7
1360:  BSF    FA6.0
1362:  MOVF   FA8,W
1364:  BTFSC  xE7.7
1366:  BSF    FF2.7
1368:  CLRF   xA0
136A:  MOVWF  x9F
....................    FaultDelayTime[8] = read_eeprom(0x25); 
136C:  MOVFF  FF2,1E7
1370:  BCF    FF2.7
1372:  MOVLW  25
1374:  MOVWF  FA9
1376:  BCF    FA6.6
1378:  BCF    FA6.7
137A:  BSF    FA6.0
137C:  MOVF   FA8,W
137E:  BTFSC  xE7.7
1380:  BSF    FF2.7
1382:  CLRF   xA2
1384:  MOVWF  xA1
....................    FaultDelayTime[9] = read_eeprom(0x26); 
1386:  MOVFF  FF2,1E7
138A:  BCF    FF2.7
138C:  MOVLW  26
138E:  MOVWF  FA9
1390:  BCF    FA6.6
1392:  BCF    FA6.7
1394:  BSF    FA6.0
1396:  MOVF   FA8,W
1398:  BTFSC  xE7.7
139A:  BSF    FF2.7
139C:  CLRF   xA4
139E:  MOVWF  xA3
....................    FaultDelayTime[10] = read_eeprom(0x27); 
13A0:  MOVFF  FF2,1E7
13A4:  BCF    FF2.7
13A6:  MOVLW  27
13A8:  MOVWF  FA9
13AA:  BCF    FA6.6
13AC:  BCF    FA6.7
13AE:  BSF    FA6.0
13B0:  MOVF   FA8,W
13B2:  BTFSC  xE7.7
13B4:  BSF    FF2.7
13B6:  CLRF   xA6
13B8:  MOVWF  xA5
....................    FaultDelayTime[11] = read_eeprom(0x28); 
13BA:  MOVFF  FF2,1E7
13BE:  BCF    FF2.7
13C0:  MOVLW  28
13C2:  MOVWF  FA9
13C4:  BCF    FA6.6
13C6:  BCF    FA6.7
13C8:  BSF    FA6.0
13CA:  MOVF   FA8,W
13CC:  BTFSC  xE7.7
13CE:  BSF    FF2.7
13D0:  CLRF   xA8
13D2:  MOVWF  xA7
....................    FaultDelayTime[12] = read_eeprom(0x29); 
13D4:  MOVFF  FF2,1E7
13D8:  BCF    FF2.7
13DA:  MOVLW  29
13DC:  MOVWF  FA9
13DE:  BCF    FA6.6
13E0:  BCF    FA6.7
13E2:  BSF    FA6.0
13E4:  MOVF   FA8,W
13E6:  BTFSC  xE7.7
13E8:  BSF    FF2.7
13EA:  CLRF   xAA
13EC:  MOVWF  xA9
....................    FaultDelayTime[13] = read_eeprom(0x2A); 
13EE:  MOVFF  FF2,1E7
13F2:  BCF    FF2.7
13F4:  MOVLW  2A
13F6:  MOVWF  FA9
13F8:  BCF    FA6.6
13FA:  BCF    FA6.7
13FC:  BSF    FA6.0
13FE:  MOVF   FA8,W
1400:  BTFSC  xE7.7
1402:  BSF    FF2.7
1404:  CLRF   xAC
1406:  MOVWF  xAB
....................    FaultDelayTime[14] = read_eeprom(0x2B); 
1408:  MOVFF  FF2,1E7
140C:  BCF    FF2.7
140E:  MOVLW  2B
1410:  MOVWF  FA9
1412:  BCF    FA6.6
1414:  BCF    FA6.7
1416:  BSF    FA6.0
1418:  MOVF   FA8,W
141A:  BTFSC  xE7.7
141C:  BSF    FF2.7
141E:  CLRF   xAE
1420:  MOVWF  xAD
....................    FaultDelayTime[15] = read_eeprom(0x2C); 
1422:  MOVFF  FF2,1E7
1426:  BCF    FF2.7
1428:  MOVLW  2C
142A:  MOVWF  FA9
142C:  BCF    FA6.6
142E:  BCF    FA6.7
1430:  BSF    FA6.0
1432:  MOVF   FA8,W
1434:  BTFSC  xE7.7
1436:  BSF    FF2.7
1438:  CLRF   xB0
143A:  MOVWF  xAF
....................    FaultDelayTime[16] = read_eeprom(0x2D); 
143C:  MOVFF  FF2,1E7
1440:  BCF    FF2.7
1442:  MOVLW  2D
1444:  MOVWF  FA9
1446:  BCF    FA6.6
1448:  BCF    FA6.7
144A:  BSF    FA6.0
144C:  MOVF   FA8,W
144E:  BTFSC  xE7.7
1450:  BSF    FF2.7
1452:  CLRF   xB2
1454:  MOVWF  xB1
....................    FaultDelayTime[17] = read_eeprom(0x2E); 
1456:  MOVFF  FF2,1E7
145A:  BCF    FF2.7
145C:  MOVLW  2E
145E:  MOVWF  FA9
1460:  BCF    FA6.6
1462:  BCF    FA6.7
1464:  BSF    FA6.0
1466:  MOVF   FA8,W
1468:  BTFSC  xE7.7
146A:  BSF    FF2.7
146C:  CLRF   xB4
146E:  MOVWF  xB3
....................    FaultDelayTime[18] = read_eeprom(0x2F); 
1470:  MOVFF  FF2,1E7
1474:  BCF    FF2.7
1476:  MOVLW  2F
1478:  MOVWF  FA9
147A:  BCF    FA6.6
147C:  BCF    FA6.7
147E:  BSF    FA6.0
1480:  MOVF   FA8,W
1482:  BTFSC  xE7.7
1484:  BSF    FF2.7
1486:  CLRF   xB6
1488:  MOVWF  xB5
....................    FaultDelayTime[19] = read_eeprom(0x30); 
148A:  MOVFF  FF2,1E7
148E:  BCF    FF2.7
1490:  MOVLW  30
1492:  MOVWF  FA9
1494:  BCF    FA6.6
1496:  BCF    FA6.7
1498:  BSF    FA6.0
149A:  MOVF   FA8,W
149C:  BTFSC  xE7.7
149E:  BSF    FF2.7
14A0:  CLRF   xB8
14A2:  MOVWF  xB7
....................    FaultDelayTime[20] = read_eeprom(0x31); 
14A4:  MOVFF  FF2,1E7
14A8:  BCF    FF2.7
14AA:  MOVLW  31
14AC:  MOVWF  FA9
14AE:  BCF    FA6.6
14B0:  BCF    FA6.7
14B2:  BSF    FA6.0
14B4:  MOVF   FA8,W
14B6:  BTFSC  xE7.7
14B8:  BSF    FF2.7
14BA:  CLRF   xBA
14BC:  MOVWF  xB9
14BE:  MOVLB  0
14C0:  RETURN 0
....................     
....................    //BuadRate = read_eeprom(0x61);         //Buad Rate 
....................    //NoOfbit = read_eeprom(0x62); 
....................    //Parity = read_eeprom(0x63); 
....................    //Stopbit = read_eeprom(0x64); 
.................... } 
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #int_RDA 
.................... void RDA_isr(void) 
.................... { 
....................  
....................    //Data = getc(); 
....................    //putc(Data); 
....................    SBUF = getc(); 
*
050C:  CLRWDT
050E:  BTFSS  F9E.5
0510:  BRA    050C
0512:  MOVFF  FAE,2E
....................    checkCommand(); 
0516:  BRA    02DA
.................... } 
.................... /* 
.................... #int_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
....................    //ReadIn_flag =1; 
.................... } 
.................... */ 
0518:  BCF    F9E.5
051A:  GOTO   006C
.................... #int_TIMER2 
.................... void TIMER2_isr(void)      //10ms 
.................... { 
....................    StatusTime++; 
051E:  INCF   19,F
....................  
....................    if(T_timeout != 0) 
0520:  MOVLB  1
0522:  MOVF   x12,F
0524:  BZ    0534
....................    { 
....................       T_timeout--; 
0526:  DECF   x12,F
....................       if(T_timeout == 0) 
0528:  MOVF   x12,F
052A:  BNZ   0534
....................       { 
....................          //sequence = stop_sq;         //timeout 
....................          sequence = end_sq;         //timeout  
052C:  MOVFF  66,6E
....................          output_bit(P485ctrl,0); 
0530:  BCF    F8A.3
0532:  BCF    F93.3
....................       } 
....................    } 
....................    ////////// Time Base 1 Second ///////////// 
....................    if(TimeBase1s != 0x00) 
0534:  MOVF   1C,F
0536:  BZ    055E
....................    { 
....................       TimeBase1s--; 
0538:  DECF   1C,F
....................       if(TimeBase1s == 0x00)      // <====== code in time base 1 second 
053A:  MOVF   1C,F
053C:  BNZ   055E
....................       { 
....................          if(AutoAckDelayTime != 0x00) 
053E:  MOVF   1D,F
0540:  BZ    054A
....................          { 
....................             AutoAckDelayTime--; 
0542:  DECF   1D,F
....................             if(AutoAckDelayTime == 0x00) 
0544:  MOVF   1D,F
0546:  BNZ   054A
....................             { 
....................                AutoAckFlag = 1 ; 
0548:  BSF    1A.2
....................             } 
....................          } 
....................          ////////////////////////////// 
....................           
....................          if(++StartReadCount >=2) 
054A:  INCF   65,F
054C:  MOVF   65,W
054E:  SUBLW  01
0550:  BC    0558
....................          { 
....................             StartRead = 1; 
0552:  BSF    30.4
....................             StartReadCount =2; 
0554:  MOVLW  02
0556:  MOVWF  65
....................          } 
....................          ////////////////////////////// 
....................          RefreshConfigData = 1; 
0558:  BSF    30.3
....................          TimeBase1s = 100; 
055A:  MOVLW  64
055C:  MOVWF  1C
....................       } 
....................  
....................    } 
....................    ///////////// End Time base 1 Second /////// 
....................  
....................  
....................  
....................    if(StatusTime == 40)    //500mS 
055E:  MOVF   19,W
0560:  SUBLW  28
0562:  BNZ   058C
....................    { 
....................       StatusTime = 0; 
0564:  CLRF   19
....................       if(HearthbeatInd == 0) 
0566:  BTFSC  1A.0
0568:  BRA    0572
....................       { 
....................          HearthbeatInd = 1; 
056A:  BSF    1A.0
....................          output_bit(Pled,1); 
056C:  BSF    F8A.5
056E:  BCF    F93.5
....................       } 
0570:  BRA    0578
....................       else 
....................       { 
....................          HearthbeatInd = 0; 
0572:  BCF    1A.0
....................          output_bit(Pled,0); 
0574:  BCF    F8A.5
0576:  BCF    F93.5
....................       } 
....................       /////////////////////////////////////////// time base 500 ms 
....................       if(Test == 1)            //Test function 
0578:  BTFSS  1A.6
057A:  BRA    058A
....................          { 
....................              if(T_test > 0x00) T_test --; 
057C:  MOVF   2F,F
057E:  BZ    0582
0580:  DECF   2F,F
....................              if(T_test == 0x00) Test_fault = 1; 
0582:  MOVF   2F,F
0584:  BNZ   0588
0586:  BSF    1A.5
....................          } 
0588:  BRA    058C
....................          else 
....................          { 
....................              //Test = 0; 
....................              T_test = 0x00; 
058A:  CLRF   2F
....................          } 
....................    } 
....................    /////////////////////////////// 
....................    if(FlashingRateTime != 0) 
058C:  MOVF   1B,F
058E:  BZ    05B6
....................    { 
....................       FlashingRateTime--; 
0590:  DECF   1B,F
....................       if(FlashingRateTime == 0) 
0592:  MOVF   1B,F
0594:  BNZ   05AA
....................       { 
....................          outmcp23 = 0xff; 
0596:  SETF   x14
....................           
....................          if(SyncStatus == 0) 
0598:  BTFSC  30.1
059A:  BRA    05A6
....................          { 
....................             if(FlashingFlag == 1) 
059C:  BTFSS  1A.1
059E:  BRA    05A4
....................             { 
....................                FlashingFlag = 0; 
05A0:  BCF    1A.1
....................                //output_bit(PSyncS,0); 
....................             } 
05A2:  BRA    05A6
....................             else 
....................             { 
....................  
....................                FlashingFlag = 1; 
05A4:  BSF    1A.1
....................                //output_bit(PSyncS,1); 
....................             } 
....................          } 
....................          //FlashingFlag = ~FlashingFlag; 
....................          FlashingRateTime = FlashingRate;      //reload value 
05A6:  MOVFF  62,1B
....................       } 
....................  
....................       if(Synctimer != 0x00) 
05AA:  MOVF   31,F
05AC:  BZ    05B6
....................       { 
....................          Synctimer--; 
05AE:  DECF   31,F
....................          if(Synctimer == 0x00) 
05B0:  MOVF   31,F
05B2:  BNZ   05B6
....................          { 
....................             SyncStatus = 0; 
05B4:  BCF    30.1
....................          } 
....................       } 
....................  
....................    } 
....................    /* 
....................    ReadIn_Count=ReadIn_Count+1; 
....................    if(ReadIn_Count==10) 
....................    { 
....................       ReadIn_Count=0; 
....................       ReadIn_flag = 1; 
....................    } 
....................    */ 
05B6:  BCF    F9E.1
05B8:  MOVLB  0
05BA:  GOTO   006C
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void Anal_Function(void) 
.................... { 
....................    ///////////////////////////////////////////////////////////////////////////// 
....................    ////////////////////////////// MANUAL RESET ///////////////////////////////// 
....................    ///////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //if(NoOfPoint >= 10) 
.................... //{ 
....................  
.................... //input1 
....................    if(AlarmIndicator.B1 == 1)    // Alarm Function 
*
4A4E:  MOVLB  1
4A50:  BTFSS  x2D.0
4A52:  BRA    4AC6
....................    { 
....................       if((((Inputt.B1 ^ InputType.B1) == 1) && (FaultType.B1 == 1))|| In.B1 == 1)    // alarm1 occure and "Lock type" 
4A54:  MOVLW  00
4A56:  BTFSC  x15.0
4A58:  MOVLW  01
4A5A:  MOVLB  2
4A5C:  MOVWF  x01
4A5E:  MOVLW  00
4A60:  MOVLB  1
4A62:  BTFSC  x1D.0
4A64:  MOVLW  01
4A66:  MOVLB  2
4A68:  XORWF  x01,W
4A6A:  SUBLW  01
4A6C:  BNZ   4A74
4A6E:  MOVLB  1
4A70:  BTFSC  x21.0
4A72:  BRA    4A7A
4A74:  MOVLB  1
4A76:  BTFSS  x35.0
4A78:  BRA    4ABE
....................       //if(Inputt.B1 == 0) 
....................       { 
....................          if(Ack.B1 == 0) 
4A7A:  BTFSC  x31.0
4A7C:  BRA    4ABC
....................          { 
....................             if(In.B1 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4A7E:  BTFSC  x35.0
4A80:  BRA    4A90
4A82:  MOVF   60,W
4A84:  SUBLW  0F
4A86:  BNZ   4A90
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
4A88:  MOVLW  64
4A8A:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
4A8C:  MOVFF  61,1D
....................             } 
....................  
....................             In.B1 = 1;                                 // setbit in1 
4A90:  BSF    x35.0
....................             if(FlashingFlag == 0)                                                                                                                                                                                                                                                                 
4A92:  BTFSC  1A.1
4A94:  BRA    4A9A
....................             { 
....................                Output.B1 = 0;           //Flash output1 
4A96:  BCF    x19.0
....................             } 
4A98:  BRA    4A9C
....................             else 
....................             { 
....................                Output.B1 = 1; 
4A9A:  BSF    x19.0
....................             } 
....................  
....................             if (~AutoTestFlag) 
4A9C:  BTFSC  1A.4
4A9E:  BRA    4ABC
....................             { 
....................                if(OutputBoth.B1 == 0)                  //Both output 
4AA0:  BTFSC  x29.0
4AA2:  BRA    4AAE
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
4AA4:  BSF    F89.4
4AA6:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
4AA8:  BSF    F89.3
4AAA:  BCF    F92.3
....................                } 
4AAC:  BRA    4ABC
....................                else 
....................                { 
....................                   if(OutputType.B1 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
4AAE:  BTFSS  x25.0
4AB0:  BRA    4AB8
4AB2:  BSF    F89.4
4AB4:  BCF    F92.4
4AB6:  BRA    4ABC
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
4AB8:  BSF    F89.3
4ABA:  BCF    F92.3
....................                } 
....................             } 
....................         } 
....................       } 
4ABC:  BRA    4AC4
....................       else if(FaultType.B1 == 1) Ack.B1 = 0; 
4ABE:  BTFSS  x21.0
4AC0:  BRA    4AC4
4AC2:  BCF    x31.0
....................    } 
4AC4:  BRA    4AEC
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B1 ^ InputType.B1) == 1) 
4AC6:  MOVLW  00
4AC8:  BTFSC  x15.0
4ACA:  MOVLW  01
4ACC:  MOVLB  2
4ACE:  MOVWF  x01
4AD0:  MOVLW  00
4AD2:  MOVLB  1
4AD4:  BTFSC  x1D.0
4AD6:  MOVLW  01
4AD8:  MOVLB  2
4ADA:  XORWF  x01,W
4ADC:  SUBLW  01
4ADE:  BNZ   4AE8
....................       { 
....................          Output.B1 = 0; 
4AE0:  MOVLB  1
4AE2:  BCF    x19.0
....................       } 
4AE4:  BRA    4AEC
4AE6:  MOVLB  2
....................       else 
....................       { 
....................          Output.B1 = 1; 
4AE8:  MOVLB  1
4AEA:  BSF    x19.0
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input2 
....................    if(AlarmIndicator.B2 == 1)    // Alarm Function 
4AEC:  BTFSS  x2D.1
4AEE:  BRA    4B62
....................    { 
....................       if((((Inputt.B2 ^ InputType.B2) == 1) && (FaultType.B2 == 1))|| In.B2 == 1)    // alarm1 occure and "Lock type" 
4AF0:  MOVLW  00
4AF2:  BTFSC  x15.1
4AF4:  MOVLW  01
4AF6:  MOVLB  2
4AF8:  MOVWF  x01
4AFA:  MOVLW  00
4AFC:  MOVLB  1
4AFE:  BTFSC  x1D.1
4B00:  MOVLW  01
4B02:  MOVLB  2
4B04:  XORWF  x01,W
4B06:  SUBLW  01
4B08:  BNZ   4B10
4B0A:  MOVLB  1
4B0C:  BTFSC  x21.1
4B0E:  BRA    4B16
4B10:  MOVLB  1
4B12:  BTFSS  x35.1
4B14:  BRA    4B5A
....................       //if(Inputt.B2 == 0) 
....................       { 
....................          if(Ack.B2 == 0) 
4B16:  BTFSC  x31.1
4B18:  BRA    4B58
....................          { 
....................             if(In.B2 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4B1A:  BTFSC  x35.1
4B1C:  BRA    4B2C
4B1E:  MOVF   60,W
4B20:  SUBLW  0F
4B22:  BNZ   4B2C
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
4B24:  MOVLW  64
4B26:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
4B28:  MOVFF  61,1D
....................             } 
....................  
....................             In.B2 = 1;                                 // setbit in1 
4B2C:  BSF    x35.1
....................             if(FlashingFlag == 0) 
4B2E:  BTFSC  1A.1
4B30:  BRA    4B36
....................             { 
....................                Output.B2 = 0;           //Flash output1 
4B32:  BCF    x19.1
....................             } 
4B34:  BRA    4B38
....................             else 
....................             { 
....................                Output.B2 = 1; 
4B36:  BSF    x19.1
....................             } 
....................  
....................             if (~AutoTestFlag) 
4B38:  BTFSC  1A.4
4B3A:  BRA    4B58
....................             { 
....................                if(OutputBoth.B2 == 0)                  //Both output 
4B3C:  BTFSC  x29.1
4B3E:  BRA    4B4A
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
4B40:  BSF    F89.4
4B42:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
4B44:  BSF    F89.3
4B46:  BCF    F92.3
....................                } 
4B48:  BRA    4B58
....................                else 
....................                { 
....................                   if(OutputType.B2 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
4B4A:  BTFSS  x25.1
4B4C:  BRA    4B54
4B4E:  BSF    F89.4
4B50:  BCF    F92.4
4B52:  BRA    4B58
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
4B54:  BSF    F89.3
4B56:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
4B58:  BRA    4B60
....................       else if(FaultType.B2 == 1) Ack.B2 = 0; 
4B5A:  BTFSS  x21.1
4B5C:  BRA    4B60
4B5E:  BCF    x31.1
....................    } 
4B60:  BRA    4B88
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B2 ^ InputType.B2) == 1) 
4B62:  MOVLW  00
4B64:  BTFSC  x15.1
4B66:  MOVLW  01
4B68:  MOVLB  2
4B6A:  MOVWF  x01
4B6C:  MOVLW  00
4B6E:  MOVLB  1
4B70:  BTFSC  x1D.1
4B72:  MOVLW  01
4B74:  MOVLB  2
4B76:  XORWF  x01,W
4B78:  SUBLW  01
4B7A:  BNZ   4B84
....................       { 
....................          Output.B2 = 0; 
4B7C:  MOVLB  1
4B7E:  BCF    x19.1
....................       } 
4B80:  BRA    4B88
4B82:  MOVLB  2
....................       else 
....................       { 
....................          Output.B2 = 1; 
4B84:  MOVLB  1
4B86:  BSF    x19.1
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input3 
....................    if(AlarmIndicator.B3 == 1)    // Alarm Function 
4B88:  BTFSS  x2D.2
4B8A:  BRA    4BFE
....................    { 
....................       if((((Inputt.B3 ^ InputType.B3) == 1) && (FaultType.B3 == 1))|| In.B3 == 1)    // alarm1 occure and "Lock type" 
4B8C:  MOVLW  00
4B8E:  BTFSC  x15.2
4B90:  MOVLW  01
4B92:  MOVLB  2
4B94:  MOVWF  x01
4B96:  MOVLW  00
4B98:  MOVLB  1
4B9A:  BTFSC  x1D.2
4B9C:  MOVLW  01
4B9E:  MOVLB  2
4BA0:  XORWF  x01,W
4BA2:  SUBLW  01
4BA4:  BNZ   4BAC
4BA6:  MOVLB  1
4BA8:  BTFSC  x21.2
4BAA:  BRA    4BB2
4BAC:  MOVLB  1
4BAE:  BTFSS  x35.2
4BB0:  BRA    4BF6
....................       //if(Inputt.B3 == 0) 
....................       { 
....................          if(Ack.B3 == 0) 
4BB2:  BTFSC  x31.2
4BB4:  BRA    4BF4
....................          { 
....................             if(In.B3 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4BB6:  BTFSC  x35.2
4BB8:  BRA    4BC8
4BBA:  MOVF   60,W
4BBC:  SUBLW  0F
4BBE:  BNZ   4BC8
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
4BC0:  MOVLW  64
4BC2:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
4BC4:  MOVFF  61,1D
....................             } 
....................  
....................             In.B3 = 1;                                 // setbit in1 
4BC8:  BSF    x35.2
....................             if(FlashingFlag == 0) 
4BCA:  BTFSC  1A.1
4BCC:  BRA    4BD2
....................             { 
....................                Output.B3 = 0;           //Flash output1 
4BCE:  BCF    x19.2
....................             } 
4BD0:  BRA    4BD4
....................             else 
....................             { 
....................                Output.B3 = 1; 
4BD2:  BSF    x19.2
....................             } 
....................  
....................             if (~AutoTestFlag) 
4BD4:  BTFSC  1A.4
4BD6:  BRA    4BF4
....................             { 
....................                if(OutputBoth.B3 == 0)                  //Both output 
4BD8:  BTFSC  x29.2
4BDA:  BRA    4BE6
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
4BDC:  BSF    F89.4
4BDE:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
4BE0:  BSF    F89.3
4BE2:  BCF    F92.3
....................                } 
4BE4:  BRA    4BF4
....................                else 
....................                { 
....................                   if(OutputType.B3 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
4BE6:  BTFSS  x25.2
4BE8:  BRA    4BF0
4BEA:  BSF    F89.4
4BEC:  BCF    F92.4
4BEE:  BRA    4BF4
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
4BF0:  BSF    F89.3
4BF2:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
4BF4:  BRA    4BFC
....................       else if(FaultType.B3 == 1) Ack.B3 = 0; 
4BF6:  BTFSS  x21.2
4BF8:  BRA    4BFC
4BFA:  BCF    x31.2
....................    } 
4BFC:  BRA    4C24
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B3 ^ InputType.B3) == 1) 
4BFE:  MOVLW  00
4C00:  BTFSC  x15.2
4C02:  MOVLW  01
4C04:  MOVLB  2
4C06:  MOVWF  x01
4C08:  MOVLW  00
4C0A:  MOVLB  1
4C0C:  BTFSC  x1D.2
4C0E:  MOVLW  01
4C10:  MOVLB  2
4C12:  XORWF  x01,W
4C14:  SUBLW  01
4C16:  BNZ   4C20
....................       { 
....................          Output.B3 = 0; 
4C18:  MOVLB  1
4C1A:  BCF    x19.2
....................       } 
4C1C:  BRA    4C24
4C1E:  MOVLB  2
....................       else 
....................       { 
....................          Output.B3 = 1; 
4C20:  MOVLB  1
4C22:  BSF    x19.2
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input4 
....................    if(AlarmIndicator.B4 == 1)    // Alarm Function 
4C24:  BTFSS  x2D.3
4C26:  BRA    4C9A
....................    { 
....................       if((((Inputt.B4 ^ InputType.B4) == 1) && (FaultType.B4 == 1))|| In.B4 == 1)    // alarm1 occure and "Lock type" 
4C28:  MOVLW  00
4C2A:  BTFSC  x15.3
4C2C:  MOVLW  01
4C2E:  MOVLB  2
4C30:  MOVWF  x01
4C32:  MOVLW  00
4C34:  MOVLB  1
4C36:  BTFSC  x1D.3
4C38:  MOVLW  01
4C3A:  MOVLB  2
4C3C:  XORWF  x01,W
4C3E:  SUBLW  01
4C40:  BNZ   4C48
4C42:  MOVLB  1
4C44:  BTFSC  x21.3
4C46:  BRA    4C4E
4C48:  MOVLB  1
4C4A:  BTFSS  x35.3
4C4C:  BRA    4C92
....................       //if(Inputt.B4 == 0) 
....................       { 
....................          if(Ack.B4 == 0) 
4C4E:  BTFSC  x31.3
4C50:  BRA    4C90
....................          { 
....................             if(In.B4 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4C52:  BTFSC  x35.3
4C54:  BRA    4C64
4C56:  MOVF   60,W
4C58:  SUBLW  0F
4C5A:  BNZ   4C64
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
4C5C:  MOVLW  64
4C5E:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
4C60:  MOVFF  61,1D
....................             } 
....................  
....................             In.B4 = 1;                                 // setbit in1 
4C64:  BSF    x35.3
....................             if(FlashingFlag == 0) 
4C66:  BTFSC  1A.1
4C68:  BRA    4C6E
....................             { 
....................                Output.B4 = 0;           //Flash output1 
4C6A:  BCF    x19.3
....................             } 
4C6C:  BRA    4C70
....................             else 
....................             { 
....................                Output.B4 = 1; 
4C6E:  BSF    x19.3
....................             } 
....................  
....................             if (~AutoTestFlag) 
4C70:  BTFSC  1A.4
4C72:  BRA    4C90
....................             { 
....................                if(OutputBoth.B4 == 0)                  //Both output 
4C74:  BTFSC  x29.3
4C76:  BRA    4C82
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
4C78:  BSF    F89.4
4C7A:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
4C7C:  BSF    F89.3
4C7E:  BCF    F92.3
....................                } 
4C80:  BRA    4C90
....................                else 
....................                { 
....................                   if(OutputType.B4 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
4C82:  BTFSS  x25.3
4C84:  BRA    4C8C
4C86:  BSF    F89.4
4C88:  BCF    F92.4
4C8A:  BRA    4C90
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
4C8C:  BSF    F89.3
4C8E:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................       } 
4C90:  BRA    4C98
....................       else if(FaultType.B4 == 1) Ack.B4 = 0; 
4C92:  BTFSS  x21.3
4C94:  BRA    4C98
4C96:  BCF    x31.3
....................    } 
4C98:  BRA    4CC0
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B4 ^ InputType.B4) == 1) 
4C9A:  MOVLW  00
4C9C:  BTFSC  x15.3
4C9E:  MOVLW  01
4CA0:  MOVLB  2
4CA2:  MOVWF  x01
4CA4:  MOVLW  00
4CA6:  MOVLB  1
4CA8:  BTFSC  x1D.3
4CAA:  MOVLW  01
4CAC:  MOVLB  2
4CAE:  XORWF  x01,W
4CB0:  SUBLW  01
4CB2:  BNZ   4CBC
....................       { 
....................          Output.B4 = 0; 
4CB4:  MOVLB  1
4CB6:  BCF    x19.3
....................       } 
4CB8:  BRA    4CC0
4CBA:  MOVLB  2
....................       else 
....................       { 
....................          Output.B4 = 1; 
4CBC:  MOVLB  1
4CBE:  BSF    x19.3
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input5 
....................    if(AlarmIndicator.B5 == 1)    // Alarm Function 
4CC0:  BTFSS  x2D.4
4CC2:  BRA    4D36
....................    { 
....................       if((((Inputt.B5 ^ InputType.B5) == 1) && (FaultType.B5 == 1))|| In.B5 == 1)    // alarm1 occure and "Lock type" 
4CC4:  MOVLW  00
4CC6:  BTFSC  x15.4
4CC8:  MOVLW  01
4CCA:  MOVLB  2
4CCC:  MOVWF  x01
4CCE:  MOVLW  00
4CD0:  MOVLB  1
4CD2:  BTFSC  x1D.4
4CD4:  MOVLW  01
4CD6:  MOVLB  2
4CD8:  XORWF  x01,W
4CDA:  SUBLW  01
4CDC:  BNZ   4CE4
4CDE:  MOVLB  1
4CE0:  BTFSC  x21.4
4CE2:  BRA    4CEA
4CE4:  MOVLB  1
4CE6:  BTFSS  x35.4
4CE8:  BRA    4D2E
....................       //if(Inputt.B5 == 0) 
....................       { 
....................          if(Ack.B5 == 0) 
4CEA:  BTFSC  x31.4
4CEC:  BRA    4D2C
....................          { 
....................             if(In.B5 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4CEE:  BTFSC  x35.4
4CF0:  BRA    4D00
4CF2:  MOVF   60,W
4CF4:  SUBLW  0F
4CF6:  BNZ   4D00
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
4CF8:  MOVLW  64
4CFA:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
4CFC:  MOVFF  61,1D
....................             } 
....................  
....................             In.B5 = 1;                                 // setbit in1 
4D00:  BSF    x35.4
....................             if(FlashingFlag == 0) 
4D02:  BTFSC  1A.1
4D04:  BRA    4D0A
....................             { 
....................                Output.B5 = 0;           //Flash output1 
4D06:  BCF    x19.4
....................             } 
4D08:  BRA    4D0C
....................             else 
....................             { 
....................                Output.B5 = 1; 
4D0A:  BSF    x19.4
....................             } 
....................  
....................             if (~AutoTestFlag) 
4D0C:  BTFSC  1A.4
4D0E:  BRA    4D2C
....................             { 
....................                if(OutputBoth.B5 == 0)                  //Both output 
4D10:  BTFSC  x29.4
4D12:  BRA    4D1E
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
4D14:  BSF    F89.4
4D16:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
4D18:  BSF    F89.3
4D1A:  BCF    F92.3
....................                } 
4D1C:  BRA    4D2C
....................                else 
....................                { 
....................                   if(OutputType.B5 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
4D1E:  BTFSS  x25.4
4D20:  BRA    4D28
4D22:  BSF    F89.4
4D24:  BCF    F92.4
4D26:  BRA    4D2C
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
4D28:  BSF    F89.3
4D2A:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
4D2C:  BRA    4D34
....................       else if(FaultType.B5 == 1) Ack.B5 = 0; 
4D2E:  BTFSS  x21.4
4D30:  BRA    4D34
4D32:  BCF    x31.4
....................    } 
4D34:  BRA    4D5C
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B5 ^ InputType.B5) == 1) 
4D36:  MOVLW  00
4D38:  BTFSC  x15.4
4D3A:  MOVLW  01
4D3C:  MOVLB  2
4D3E:  MOVWF  x01
4D40:  MOVLW  00
4D42:  MOVLB  1
4D44:  BTFSC  x1D.4
4D46:  MOVLW  01
4D48:  MOVLB  2
4D4A:  XORWF  x01,W
4D4C:  SUBLW  01
4D4E:  BNZ   4D58
....................       { 
....................          Output.B5 = 0; 
4D50:  MOVLB  1
4D52:  BCF    x19.4
....................       } 
4D54:  BRA    4D5C
4D56:  MOVLB  2
....................       else 
....................       { 
....................          Output.B5 = 1; 
4D58:  MOVLB  1
4D5A:  BSF    x19.4
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input6 
....................    if(AlarmIndicator.B6 == 1)    // Alarm Function 
4D5C:  BTFSS  x2D.5
4D5E:  BRA    4DD2
....................    { 
....................       if((((Inputt.B6 ^ InputType.B6) == 1) && (FaultType.B6 == 1))|| In.B6 == 1)    // alarm1 occure and "Lock type" 
4D60:  MOVLW  00
4D62:  BTFSC  x15.5
4D64:  MOVLW  01
4D66:  MOVLB  2
4D68:  MOVWF  x01
4D6A:  MOVLW  00
4D6C:  MOVLB  1
4D6E:  BTFSC  x1D.5
4D70:  MOVLW  01
4D72:  MOVLB  2
4D74:  XORWF  x01,W
4D76:  SUBLW  01
4D78:  BNZ   4D80
4D7A:  MOVLB  1
4D7C:  BTFSC  x21.5
4D7E:  BRA    4D86
4D80:  MOVLB  1
4D82:  BTFSS  x35.5
4D84:  BRA    4DCA
....................       //if(Inputt.B6 == 0) 
....................       { 
....................          if(Ack.B6 == 0) 
4D86:  BTFSC  x31.5
4D88:  BRA    4DC8
....................          { 
....................             if(In.B6 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4D8A:  BTFSC  x35.5
4D8C:  BRA    4D9C
4D8E:  MOVF   60,W
4D90:  SUBLW  0F
4D92:  BNZ   4D9C
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
4D94:  MOVLW  64
4D96:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
4D98:  MOVFF  61,1D
....................             } 
....................  
....................             In.B6 = 1;                                 // setbit in1 
4D9C:  BSF    x35.5
....................             if(FlashingFlag == 0) 
4D9E:  BTFSC  1A.1
4DA0:  BRA    4DA6
....................             { 
....................                Output.B6 = 0;           //Flash output1 
4DA2:  BCF    x19.5
....................             } 
4DA4:  BRA    4DA8
....................             else 
....................             { 
....................                Output.B6 = 1; 
4DA6:  BSF    x19.5
....................             } 
....................  
....................             if (~AutoTestFlag) 
4DA8:  BTFSC  1A.4
4DAA:  BRA    4DC8
....................             { 
....................                if(OutputBoth.B6 == 0)                  //Both output 
4DAC:  BTFSC  x29.5
4DAE:  BRA    4DBA
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
4DB0:  BSF    F89.4
4DB2:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
4DB4:  BSF    F89.3
4DB6:  BCF    F92.3
....................                } 
4DB8:  BRA    4DC8
....................                else 
....................                { 
....................                   if(OutputType.B6 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
4DBA:  BTFSS  x25.5
4DBC:  BRA    4DC4
4DBE:  BSF    F89.4
4DC0:  BCF    F92.4
4DC2:  BRA    4DC8
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
4DC4:  BSF    F89.3
4DC6:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................       } 
4DC8:  BRA    4DD0
....................       else if(FaultType.B6 == 1) Ack.B6 = 0; 
4DCA:  BTFSS  x21.5
4DCC:  BRA    4DD0
4DCE:  BCF    x31.5
....................    } 
4DD0:  BRA    4DF8
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B6 ^ InputType.B6) == 1) 
4DD2:  MOVLW  00
4DD4:  BTFSC  x15.5
4DD6:  MOVLW  01
4DD8:  MOVLB  2
4DDA:  MOVWF  x01
4DDC:  MOVLW  00
4DDE:  MOVLB  1
4DE0:  BTFSC  x1D.5
4DE2:  MOVLW  01
4DE4:  MOVLB  2
4DE6:  XORWF  x01,W
4DE8:  SUBLW  01
4DEA:  BNZ   4DF4
....................       { 
....................          Output.B6 = 0; 
4DEC:  MOVLB  1
4DEE:  BCF    x19.5
....................       } 
4DF0:  BRA    4DF8
4DF2:  MOVLB  2
....................       else 
....................       { 
....................          Output.B6 = 1; 
4DF4:  MOVLB  1
4DF6:  BSF    x19.5
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input7 
....................    if(AlarmIndicator.B7 == 1)    // Alarm Function 
4DF8:  BTFSS  x2D.6
4DFA:  BRA    4E6E
....................    { 
....................       if((((Inputt.B7 ^ InputType.B7) == 1) && (FaultType.B7 == 1))|| In.B7 == 1)    // alarm1 occure and "Lock type" 
4DFC:  MOVLW  00
4DFE:  BTFSC  x15.6
4E00:  MOVLW  01
4E02:  MOVLB  2
4E04:  MOVWF  x01
4E06:  MOVLW  00
4E08:  MOVLB  1
4E0A:  BTFSC  x1D.6
4E0C:  MOVLW  01
4E0E:  MOVLB  2
4E10:  XORWF  x01,W
4E12:  SUBLW  01
4E14:  BNZ   4E1C
4E16:  MOVLB  1
4E18:  BTFSC  x21.6
4E1A:  BRA    4E22
4E1C:  MOVLB  1
4E1E:  BTFSS  x35.6
4E20:  BRA    4E66
....................       //if(Inputt.B7 == 0) 
....................       { 
....................          if(Ack.B7 == 0) 
4E22:  BTFSC  x31.6
4E24:  BRA    4E64
....................          { 
....................             if(In.B7 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4E26:  BTFSC  x35.6
4E28:  BRA    4E38
4E2A:  MOVF   60,W
4E2C:  SUBLW  0F
4E2E:  BNZ   4E38
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
4E30:  MOVLW  64
4E32:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
4E34:  MOVFF  61,1D
....................             } 
....................  
....................             In.B7 = 1;                                 // setbit in1 
4E38:  BSF    x35.6
....................             if(FlashingFlag == 0) 
4E3A:  BTFSC  1A.1
4E3C:  BRA    4E42
....................             { 
....................                Output.B7 = 0;           //Flash output1 
4E3E:  BCF    x19.6
....................             } 
4E40:  BRA    4E44
....................             else 
....................             { 
....................                Output.B7 = 1; 
4E42:  BSF    x19.6
....................             } 
....................  
....................             if (~AutoTestFlag) 
4E44:  BTFSC  1A.4
4E46:  BRA    4E64
....................             { 
....................                if(OutputBoth.B7 == 0)                  //Both output 
4E48:  BTFSC  x29.6
4E4A:  BRA    4E56
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
4E4C:  BSF    F89.4
4E4E:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
4E50:  BSF    F89.3
4E52:  BCF    F92.3
....................                } 
4E54:  BRA    4E64
....................                else 
....................                { 
....................                   if(OutputType.B7 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
4E56:  BTFSS  x25.6
4E58:  BRA    4E60
4E5A:  BSF    F89.4
4E5C:  BCF    F92.4
4E5E:  BRA    4E64
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
4E60:  BSF    F89.3
4E62:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
4E64:  BRA    4E6C
....................       else if(FaultType.B7 == 1) Ack.B7 = 0; 
4E66:  BTFSS  x21.6
4E68:  BRA    4E6C
4E6A:  BCF    x31.6
....................    } 
4E6C:  BRA    4E94
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B7 ^ InputType.B7) == 1) 
4E6E:  MOVLW  00
4E70:  BTFSC  x15.6
4E72:  MOVLW  01
4E74:  MOVLB  2
4E76:  MOVWF  x01
4E78:  MOVLW  00
4E7A:  MOVLB  1
4E7C:  BTFSC  x1D.6
4E7E:  MOVLW  01
4E80:  MOVLB  2
4E82:  XORWF  x01,W
4E84:  SUBLW  01
4E86:  BNZ   4E90
....................       { 
....................          Output.B7 = 0; 
4E88:  MOVLB  1
4E8A:  BCF    x19.6
....................       } 
4E8C:  BRA    4E94
4E8E:  MOVLB  2
....................       else 
....................       { 
....................          Output.B7 = 1; 
4E90:  MOVLB  1
4E92:  BSF    x19.6
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input8 
....................    if(AlarmIndicator.B8 == 1)    // Alarm Function 
4E94:  BTFSS  x2D.7
4E96:  BRA    4F0A
....................    { 
....................       if((((Inputt.B8 ^ InputType.B8) == 1) && (FaultType.B8 == 1))|| In.B8 == 1)    // alarm1 occure and "Lock type" 
4E98:  MOVLW  00
4E9A:  BTFSC  x15.7
4E9C:  MOVLW  01
4E9E:  MOVLB  2
4EA0:  MOVWF  x01
4EA2:  MOVLW  00
4EA4:  MOVLB  1
4EA6:  BTFSC  x1D.7
4EA8:  MOVLW  01
4EAA:  MOVLB  2
4EAC:  XORWF  x01,W
4EAE:  SUBLW  01
4EB0:  BNZ   4EB8
4EB2:  MOVLB  1
4EB4:  BTFSC  x21.7
4EB6:  BRA    4EBE
4EB8:  MOVLB  1
4EBA:  BTFSS  x35.7
4EBC:  BRA    4F02
....................       //if(Inputt.B8 == 0) 
....................       { 
....................          if(Ack.B8 == 0) 
4EBE:  BTFSC  x31.7
4EC0:  BRA    4F00
....................          { 
....................             if(In.B8 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4EC2:  BTFSC  x35.7
4EC4:  BRA    4ED4
4EC6:  MOVF   60,W
4EC8:  SUBLW  0F
4ECA:  BNZ   4ED4
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
4ECC:  MOVLW  64
4ECE:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
4ED0:  MOVFF  61,1D
....................             } 
....................  
....................             In.B8 = 1;                                 // setbit in1 
4ED4:  BSF    x35.7
....................             if(FlashingFlag == 0) 
4ED6:  BTFSC  1A.1
4ED8:  BRA    4EDE
....................             { 
....................                Output.B8 = 0;           //Flash output1 
4EDA:  BCF    x19.7
....................             } 
4EDC:  BRA    4EE0
....................             else 
....................             { 
....................                Output.B8 = 1; 
4EDE:  BSF    x19.7
....................             } 
....................  
....................             if (~AutoTestFlag) 
4EE0:  BTFSC  1A.4
4EE2:  BRA    4F00
....................             { 
....................                if(OutputBoth.B8 == 0)                  //Both output 
4EE4:  BTFSC  x29.7
4EE6:  BRA    4EF2
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
4EE8:  BSF    F89.4
4EEA:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
4EEC:  BSF    F89.3
4EEE:  BCF    F92.3
....................                } 
4EF0:  BRA    4F00
....................                else 
....................                { 
....................                   if(OutputType.B8 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
4EF2:  BTFSS  x25.7
4EF4:  BRA    4EFC
4EF6:  BSF    F89.4
4EF8:  BCF    F92.4
4EFA:  BRA    4F00
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
4EFC:  BSF    F89.3
4EFE:  BCF    F92.3
....................                } 
....................             } 
....................        } 
....................  
....................       } 
4F00:  BRA    4F08
....................       else if(FaultType.B8 == 1) Ack.B8 = 0; 
4F02:  BTFSS  x21.7
4F04:  BRA    4F08
4F06:  BCF    x31.7
....................    } 
4F08:  BRA    4F30
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B8 ^ InputType.B8) == 1) 
4F0A:  MOVLW  00
4F0C:  BTFSC  x15.7
4F0E:  MOVLW  01
4F10:  MOVLB  2
4F12:  MOVWF  x01
4F14:  MOVLW  00
4F16:  MOVLB  1
4F18:  BTFSC  x1D.7
4F1A:  MOVLW  01
4F1C:  MOVLB  2
4F1E:  XORWF  x01,W
4F20:  SUBLW  01
4F22:  BNZ   4F2C
....................       { 
....................          Output.B8 = 0; 
4F24:  MOVLB  1
4F26:  BCF    x19.7
....................       } 
4F28:  BRA    4F30
4F2A:  MOVLB  2
....................       else 
....................       { 
....................          Output.B8 = 1; 
4F2C:  MOVLB  1
4F2E:  BSF    x19.7
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input9 
....................    if(AlarmIndicator.B9 == 1)    // Alarm Function 
4F30:  BTFSS  x2E.0
4F32:  BRA    4FA6
....................    { 
....................       if((((Inputt.B9 ^ InputType.B9) == 1) && (FaultType.B9 == 1))|| In.B9 == 1)    // alarm1 occure and "Lock type" 
4F34:  MOVLW  00
4F36:  BTFSC  x16.0
4F38:  MOVLW  01
4F3A:  MOVLB  2
4F3C:  MOVWF  x01
4F3E:  MOVLW  00
4F40:  MOVLB  1
4F42:  BTFSC  x1E.0
4F44:  MOVLW  01
4F46:  MOVLB  2
4F48:  XORWF  x01,W
4F4A:  SUBLW  01
4F4C:  BNZ   4F54
4F4E:  MOVLB  1
4F50:  BTFSC  x22.0
4F52:  BRA    4F5A
4F54:  MOVLB  1
4F56:  BTFSS  x36.0
4F58:  BRA    4F9E
....................       //if(Inputt.B9 == 0) 
....................       { 
....................          if(Ack.B9 == 0) 
4F5A:  BTFSC  x32.0
4F5C:  BRA    4F9C
....................          { 
....................             if(In.B9 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4F5E:  BTFSC  x36.0
4F60:  BRA    4F70
4F62:  MOVF   60,W
4F64:  SUBLW  0F
4F66:  BNZ   4F70
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
4F68:  MOVLW  64
4F6A:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
4F6C:  MOVFF  61,1D
....................             } 
....................  
....................             In.B9 = 1;                                 // setbit in1 
4F70:  BSF    x36.0
....................             if(FlashingFlag == 0) 
4F72:  BTFSC  1A.1
4F74:  BRA    4F7A
....................             { 
....................                Output.B9 = 0;           //Flash output1 
4F76:  BCF    x1A.0
....................             } 
4F78:  BRA    4F7C
....................             else 
....................             { 
....................                Output.B9 = 1; 
4F7A:  BSF    x1A.0
....................             } 
....................  
....................             if (~AutoTestFlag) 
4F7C:  BTFSC  1A.4
4F7E:  BRA    4F9C
....................             { 
....................                if(OutputBoth.B9 == 0)                  //Both output 
4F80:  BTFSC  x2A.0
4F82:  BRA    4F8E
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
4F84:  BSF    F89.4
4F86:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
4F88:  BSF    F89.3
4F8A:  BCF    F92.3
....................                } 
4F8C:  BRA    4F9C
....................                else 
....................                { 
....................                   if(OutputType.B9 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
4F8E:  BTFSS  x26.0
4F90:  BRA    4F98
4F92:  BSF    F89.4
4F94:  BCF    F92.4
4F96:  BRA    4F9C
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
4F98:  BSF    F89.3
4F9A:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
4F9C:  BRA    4FA4
....................       else if(FaultType.B9 == 1) Ack.B9 = 0; 
4F9E:  BTFSS  x22.0
4FA0:  BRA    4FA4
4FA2:  BCF    x32.0
....................    } 
4FA4:  BRA    4FCC
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B9 ^ InputType.B9) == 1) 
4FA6:  MOVLW  00
4FA8:  BTFSC  x16.0
4FAA:  MOVLW  01
4FAC:  MOVLB  2
4FAE:  MOVWF  x01
4FB0:  MOVLW  00
4FB2:  MOVLB  1
4FB4:  BTFSC  x1E.0
4FB6:  MOVLW  01
4FB8:  MOVLB  2
4FBA:  XORWF  x01,W
4FBC:  SUBLW  01
4FBE:  BNZ   4FC8
....................       { 
....................          Output.B9 = 0; 
4FC0:  MOVLB  1
4FC2:  BCF    x1A.0
....................       } 
4FC4:  BRA    4FCC
4FC6:  MOVLB  2
....................       else 
....................       { 
....................          Output.B9 = 1; 
4FC8:  MOVLB  1
4FCA:  BSF    x1A.0
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input10 
....................    if(AlarmIndicator.B10 == 1)    // Alarm Function 
4FCC:  BTFSS  x2E.1
4FCE:  BRA    5042
....................    { 
....................       if((((Inputt.B10 ^ InputType.B10) == 1) && (FaultType.B10 == 1))|| In.B10 == 1)    // alarm1 occure and "Lock type" 
4FD0:  MOVLW  00
4FD2:  BTFSC  x16.1
4FD4:  MOVLW  01
4FD6:  MOVLB  2
4FD8:  MOVWF  x01
4FDA:  MOVLW  00
4FDC:  MOVLB  1
4FDE:  BTFSC  x1E.1
4FE0:  MOVLW  01
4FE2:  MOVLB  2
4FE4:  XORWF  x01,W
4FE6:  SUBLW  01
4FE8:  BNZ   4FF0
4FEA:  MOVLB  1
4FEC:  BTFSC  x22.1
4FEE:  BRA    4FF6
4FF0:  MOVLB  1
4FF2:  BTFSS  x36.1
4FF4:  BRA    503A
....................       //if(Inputt.B10 == 0) 
....................       { 
....................          if(Ack.B10 == 0) 
4FF6:  BTFSC  x32.1
4FF8:  BRA    5038
....................          { 
....................             if(In.B10 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4FFA:  BTFSC  x36.1
4FFC:  BRA    500C
4FFE:  MOVF   60,W
5000:  SUBLW  0F
5002:  BNZ   500C
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
5004:  MOVLW  64
5006:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
5008:  MOVFF  61,1D
....................             } 
....................  
....................             In.B10 = 1;                                 // setbit in1 
500C:  BSF    x36.1
....................             if(FlashingFlag == 0) 
500E:  BTFSC  1A.1
5010:  BRA    5016
....................             { 
....................                Output.B10 = 0;           //Flash output1 
5012:  BCF    x1A.1
....................             } 
5014:  BRA    5018
....................             else 
....................             { 
....................                Output.B10 = 1; 
5016:  BSF    x1A.1
....................             } 
....................  
....................             if (~AutoTestFlag) 
5018:  BTFSC  1A.4
501A:  BRA    5038
....................             { 
....................                if(OutputBoth.B10 == 0)                  //Both output 
501C:  BTFSC  x2A.1
501E:  BRA    502A
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5020:  BSF    F89.4
5022:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5024:  BSF    F89.3
5026:  BCF    F92.3
....................                } 
5028:  BRA    5038
....................                else 
....................                { 
....................                   if(OutputType.B10 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
502A:  BTFSS  x26.1
502C:  BRA    5034
502E:  BSF    F89.4
5030:  BCF    F92.4
5032:  BRA    5038
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
5034:  BSF    F89.3
5036:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
5038:  BRA    5040
....................       else if(FaultType.B10 == 1) Ack.B10 = 0; 
503A:  BTFSS  x22.1
503C:  BRA    5040
503E:  BCF    x32.1
....................    } 
5040:  BRA    5068
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B10 ^ InputType.B10) == 1) 
5042:  MOVLW  00
5044:  BTFSC  x16.1
5046:  MOVLW  01
5048:  MOVLB  2
504A:  MOVWF  x01
504C:  MOVLW  00
504E:  MOVLB  1
5050:  BTFSC  x1E.1
5052:  MOVLW  01
5054:  MOVLB  2
5056:  XORWF  x01,W
5058:  SUBLW  01
505A:  BNZ   5064
....................       { 
....................          Output.B10 = 0; 
505C:  MOVLB  1
505E:  BCF    x1A.1
....................       } 
5060:  BRA    5068
5062:  MOVLB  2
....................       else 
....................       { 
....................          Output.B10 = 1; 
5064:  MOVLB  1
5066:  BSF    x1A.1
....................       } 
....................    } 
.................... //} 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //if(NoOfPoint >= 20) 
.................... //{ 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input11 
....................    if(AlarmIndicator.B11 == 1)    // Alarm Function 
5068:  BTFSS  x2E.2
506A:  BRA    50DE
....................    { 
....................       if((((Inputt.B11 ^ InputType.B11) == 1) && (FaultType.B11 == 1))|| In.B11 == 1)    // alarm1 occure and "Lock type" 
506C:  MOVLW  00
506E:  BTFSC  x16.2
5070:  MOVLW  01
5072:  MOVLB  2
5074:  MOVWF  x01
5076:  MOVLW  00
5078:  MOVLB  1
507A:  BTFSC  x1E.2
507C:  MOVLW  01
507E:  MOVLB  2
5080:  XORWF  x01,W
5082:  SUBLW  01
5084:  BNZ   508C
5086:  MOVLB  1
5088:  BTFSC  x22.2
508A:  BRA    5092
508C:  MOVLB  1
508E:  BTFSS  x36.2
5090:  BRA    50D6
....................       //if(Inputt.B11 == 0) 
....................       { 
....................          if(Ack.B11 == 0) 
5092:  BTFSC  x32.2
5094:  BRA    50D4
....................          { 
....................             if(In.B11 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
5096:  BTFSC  x36.2
5098:  BRA    50A8
509A:  MOVF   60,W
509C:  SUBLW  0F
509E:  BNZ   50A8
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
50A0:  MOVLW  64
50A2:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
50A4:  MOVFF  61,1D
....................             } 
....................  
....................             In.B11 = 1;                                 // setbit in1 
50A8:  BSF    x36.2
....................             if(FlashingFlag == 0) 
50AA:  BTFSC  1A.1
50AC:  BRA    50B2
....................             { 
....................                Output.B11 = 0;           //Flash output1 
50AE:  BCF    x1A.2
....................             } 
50B0:  BRA    50B4
....................             else 
....................             { 
....................                Output.B11 = 1; 
50B2:  BSF    x1A.2
....................             } 
....................  
....................             if (~AutoTestFlag) 
50B4:  BTFSC  1A.4
50B6:  BRA    50D4
....................             { 
....................                if(OutputBoth.B11 == 0)                  //Both output 
50B8:  BTFSC  x2A.2
50BA:  BRA    50C6
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
50BC:  BSF    F89.4
50BE:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
50C0:  BSF    F89.3
50C2:  BCF    F92.3
....................                } 
50C4:  BRA    50D4
....................                else 
....................                { 
....................                   if(OutputType.B11 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
50C6:  BTFSS  x26.2
50C8:  BRA    50D0
50CA:  BSF    F89.4
50CC:  BCF    F92.4
50CE:  BRA    50D4
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
50D0:  BSF    F89.3
50D2:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
50D4:  BRA    50DC
....................       else if(FaultType.B11 == 1) Ack.B11 = 0; 
50D6:  BTFSS  x22.2
50D8:  BRA    50DC
50DA:  BCF    x32.2
....................    } 
50DC:  BRA    5104
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B11 ^ InputType.B11) == 1) 
50DE:  MOVLW  00
50E0:  BTFSC  x16.2
50E2:  MOVLW  01
50E4:  MOVLB  2
50E6:  MOVWF  x01
50E8:  MOVLW  00
50EA:  MOVLB  1
50EC:  BTFSC  x1E.2
50EE:  MOVLW  01
50F0:  MOVLB  2
50F2:  XORWF  x01,W
50F4:  SUBLW  01
50F6:  BNZ   5100
....................       { 
....................          Output.B11 = 0; 
50F8:  MOVLB  1
50FA:  BCF    x1A.2
....................       } 
50FC:  BRA    5104
50FE:  MOVLB  2
....................       else 
....................       { 
....................          Output.B11 = 1; 
5100:  MOVLB  1
5102:  BSF    x1A.2
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input12 
....................    if(AlarmIndicator.B12 == 1)    // Alarm Function 
5104:  BTFSS  x2E.3
5106:  BRA    517A
....................    { 
....................       if((((Inputt.B12 ^ InputType.B12) == 1) && (FaultType.B12 == 1))|| In.B12 == 1)    // alarm1 occure and "Lock type" 
5108:  MOVLW  00
510A:  BTFSC  x16.3
510C:  MOVLW  01
510E:  MOVLB  2
5110:  MOVWF  x01
5112:  MOVLW  00
5114:  MOVLB  1
5116:  BTFSC  x1E.3
5118:  MOVLW  01
511A:  MOVLB  2
511C:  XORWF  x01,W
511E:  SUBLW  01
5120:  BNZ   5128
5122:  MOVLB  1
5124:  BTFSC  x22.3
5126:  BRA    512E
5128:  MOVLB  1
512A:  BTFSS  x36.3
512C:  BRA    5172
....................       //if(Inputt.B12 == 0) 
....................       { 
....................          if(Ack.B12 == 0) 
512E:  BTFSC  x32.3
5130:  BRA    5170
....................          { 
....................             if(In.B12 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
5132:  BTFSC  x36.3
5134:  BRA    5144
5136:  MOVF   60,W
5138:  SUBLW  0F
513A:  BNZ   5144
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
513C:  MOVLW  64
513E:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
5140:  MOVFF  61,1D
....................             } 
....................  
....................             In.B12 = 1;                                 // setbit in1 
5144:  BSF    x36.3
....................             if(FlashingFlag == 0) 
5146:  BTFSC  1A.1
5148:  BRA    514E
....................             { 
....................                Output.B12 = 0;           //Flash output1 
514A:  BCF    x1A.3
....................             } 
514C:  BRA    5150
....................             else 
....................             { 
....................                Output.B12 = 1; 
514E:  BSF    x1A.3
....................             } 
....................  
....................             if (~AutoTestFlag) 
5150:  BTFSC  1A.4
5152:  BRA    5170
....................             { 
....................                if(OutputBoth.B12 == 0)                  //Both output 
5154:  BTFSC  x2A.3
5156:  BRA    5162
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5158:  BSF    F89.4
515A:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
515C:  BSF    F89.3
515E:  BCF    F92.3
....................                } 
5160:  BRA    5170
....................                else 
....................                { 
....................                   if(OutputType.B12 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
5162:  BTFSS  x26.3
5164:  BRA    516C
5166:  BSF    F89.4
5168:  BCF    F92.4
516A:  BRA    5170
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
516C:  BSF    F89.3
516E:  BCF    F92.3
....................                } 
....................             } 
....................         } 
....................  
....................       } 
5170:  BRA    5178
....................       else if(FaultType.B12 == 1) Ack.B12 = 0; 
5172:  BTFSS  x22.3
5174:  BRA    5178
5176:  BCF    x32.3
....................    } 
5178:  BRA    51A0
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B12 ^ InputType.B12) == 1) 
517A:  MOVLW  00
517C:  BTFSC  x16.3
517E:  MOVLW  01
5180:  MOVLB  2
5182:  MOVWF  x01
5184:  MOVLW  00
5186:  MOVLB  1
5188:  BTFSC  x1E.3
518A:  MOVLW  01
518C:  MOVLB  2
518E:  XORWF  x01,W
5190:  SUBLW  01
5192:  BNZ   519C
....................       { 
....................          Output.B12 = 0; 
5194:  MOVLB  1
5196:  BCF    x1A.3
....................       } 
5198:  BRA    51A0
519A:  MOVLB  2
....................       else 
....................       { 
....................          Output.B12 = 1; 
519C:  MOVLB  1
519E:  BSF    x1A.3
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input13 
....................    if(AlarmIndicator.B13 == 1)    // Alarm Function 
51A0:  BTFSS  x2E.4
51A2:  BRA    5216
....................    { 
....................       if((((Inputt.B13 ^ InputType.B13) == 1) && (FaultType.B13 == 1))|| In.B13 == 1)    // alarm1 occure and "Lock type" 
51A4:  MOVLW  00
51A6:  BTFSC  x16.4
51A8:  MOVLW  01
51AA:  MOVLB  2
51AC:  MOVWF  x01
51AE:  MOVLW  00
51B0:  MOVLB  1
51B2:  BTFSC  x1E.4
51B4:  MOVLW  01
51B6:  MOVLB  2
51B8:  XORWF  x01,W
51BA:  SUBLW  01
51BC:  BNZ   51C4
51BE:  MOVLB  1
51C0:  BTFSC  x22.4
51C2:  BRA    51CA
51C4:  MOVLB  1
51C6:  BTFSS  x36.4
51C8:  BRA    520E
....................       //if(Inputt.B13 == 0) 
....................       { 
....................          if(Ack.B13 == 0) 
51CA:  BTFSC  x32.4
51CC:  BRA    520C
....................          { 
....................             if(In.B13 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
51CE:  BTFSC  x36.4
51D0:  BRA    51E0
51D2:  MOVF   60,W
51D4:  SUBLW  0F
51D6:  BNZ   51E0
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
51D8:  MOVLW  64
51DA:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
51DC:  MOVFF  61,1D
....................             } 
....................  
....................             In.B13 = 1;                                 // setbit in1 
51E0:  BSF    x36.4
....................             if(FlashingFlag == 0) 
51E2:  BTFSC  1A.1
51E4:  BRA    51EA
....................             { 
....................                Output.B13 = 0;           //Flash output1 
51E6:  BCF    x1A.4
....................             } 
51E8:  BRA    51EC
....................             else 
....................             { 
....................                Output.B13 = 1; 
51EA:  BSF    x1A.4
....................             } 
....................  
....................             if (~AutoTestFlag) 
51EC:  BTFSC  1A.4
51EE:  BRA    520C
....................             { 
....................                if(OutputBoth.B13 == 0)                  //Both output 
51F0:  BTFSC  x2A.4
51F2:  BRA    51FE
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
51F4:  BSF    F89.4
51F6:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
51F8:  BSF    F89.3
51FA:  BCF    F92.3
....................                } 
51FC:  BRA    520C
....................                else 
....................                { 
....................                   if(OutputType.B13 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
51FE:  BTFSS  x26.4
5200:  BRA    5208
5202:  BSF    F89.4
5204:  BCF    F92.4
5206:  BRA    520C
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
5208:  BSF    F89.3
520A:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
520C:  BRA    5214
....................       else if(FaultType.B13 == 1) Ack.B13 = 0; 
520E:  BTFSS  x22.4
5210:  BRA    5214
5212:  BCF    x32.4
....................    } 
5214:  BRA    523C
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B13 ^ InputType.B13) == 1) 
5216:  MOVLW  00
5218:  BTFSC  x16.4
521A:  MOVLW  01
521C:  MOVLB  2
521E:  MOVWF  x01
5220:  MOVLW  00
5222:  MOVLB  1
5224:  BTFSC  x1E.4
5226:  MOVLW  01
5228:  MOVLB  2
522A:  XORWF  x01,W
522C:  SUBLW  01
522E:  BNZ   5238
....................       { 
....................          Output.B13 = 0; 
5230:  MOVLB  1
5232:  BCF    x1A.4
....................       } 
5234:  BRA    523C
5236:  MOVLB  2
....................       else 
....................       { 
....................          Output.B13 = 1; 
5238:  MOVLB  1
523A:  BSF    x1A.4
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input14 
....................    if(AlarmIndicator.B14 == 1)    // Alarm Function 
523C:  BTFSS  x2E.5
523E:  BRA    52B2
....................    { 
....................       if((((Inputt.B14 ^ InputType.B14) == 1) && (FaultType.B14 == 1))|| In.B14 == 1)    // alarm1 occure and "Lock type" 
5240:  MOVLW  00
5242:  BTFSC  x16.5
5244:  MOVLW  01
5246:  MOVLB  2
5248:  MOVWF  x01
524A:  MOVLW  00
524C:  MOVLB  1
524E:  BTFSC  x1E.5
5250:  MOVLW  01
5252:  MOVLB  2
5254:  XORWF  x01,W
5256:  SUBLW  01
5258:  BNZ   5260
525A:  MOVLB  1
525C:  BTFSC  x22.5
525E:  BRA    5266
5260:  MOVLB  1
5262:  BTFSS  x36.5
5264:  BRA    52AA
....................       //if(Inputt.B14 == 0) 
....................       { 
....................          if(Ack.B14 == 0) 
5266:  BTFSC  x32.5
5268:  BRA    52A8
....................          { 
....................             if(In.B14 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
526A:  BTFSC  x36.5
526C:  BRA    527C
526E:  MOVF   60,W
5270:  SUBLW  0F
5272:  BNZ   527C
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
5274:  MOVLW  64
5276:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
5278:  MOVFF  61,1D
....................             } 
....................  
....................             In.B14 = 1;                                 // setbit in1 
527C:  BSF    x36.5
....................             if(FlashingFlag == 0) 
527E:  BTFSC  1A.1
5280:  BRA    5286
....................             { 
....................                Output.B14 = 0;           //Flash output1 
5282:  BCF    x1A.5
....................             } 
5284:  BRA    5288
....................             else 
....................             { 
....................                Output.B14 = 1; 
5286:  BSF    x1A.5
....................             } 
....................  
....................             if (~AutoTestFlag) 
5288:  BTFSC  1A.4
528A:  BRA    52A8
....................             { 
....................                if(OutputBoth.B14 == 0)                  //Both output 
528C:  BTFSC  x2A.5
528E:  BRA    529A
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5290:  BSF    F89.4
5292:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5294:  BSF    F89.3
5296:  BCF    F92.3
....................                } 
5298:  BRA    52A8
....................                else 
....................                { 
....................                   if(OutputType.B14 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
529A:  BTFSS  x26.5
529C:  BRA    52A4
529E:  BSF    F89.4
52A0:  BCF    F92.4
52A2:  BRA    52A8
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
52A4:  BSF    F89.3
52A6:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
52A8:  BRA    52B0
....................       else if(FaultType.B14 == 1) Ack.B14 = 0; 
52AA:  BTFSS  x22.5
52AC:  BRA    52B0
52AE:  BCF    x32.5
....................    } 
52B0:  BRA    52D8
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B14 ^ InputType.B14) == 1) 
52B2:  MOVLW  00
52B4:  BTFSC  x16.5
52B6:  MOVLW  01
52B8:  MOVLB  2
52BA:  MOVWF  x01
52BC:  MOVLW  00
52BE:  MOVLB  1
52C0:  BTFSC  x1E.5
52C2:  MOVLW  01
52C4:  MOVLB  2
52C6:  XORWF  x01,W
52C8:  SUBLW  01
52CA:  BNZ   52D4
....................       { 
....................          Output.B14 = 0; 
52CC:  MOVLB  1
52CE:  BCF    x1A.5
....................       } 
52D0:  BRA    52D8
52D2:  MOVLB  2
....................       else 
....................       { 
....................          Output.B14 = 1; 
52D4:  MOVLB  1
52D6:  BSF    x1A.5
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input15 
....................    if(AlarmIndicator.B15 == 1)    // Alarm Function 
52D8:  BTFSS  x2E.6
52DA:  BRA    534E
....................    { 
....................       if((((Inputt.B15 ^ InputType.B15) == 1) && (FaultType.B15 == 1))|| In.B15 == 1)    // alarm1 occure and "Lock type" 
52DC:  MOVLW  00
52DE:  BTFSC  x16.6
52E0:  MOVLW  01
52E2:  MOVLB  2
52E4:  MOVWF  x01
52E6:  MOVLW  00
52E8:  MOVLB  1
52EA:  BTFSC  x1E.6
52EC:  MOVLW  01
52EE:  MOVLB  2
52F0:  XORWF  x01,W
52F2:  SUBLW  01
52F4:  BNZ   52FC
52F6:  MOVLB  1
52F8:  BTFSC  x22.6
52FA:  BRA    5302
52FC:  MOVLB  1
52FE:  BTFSS  x36.6
5300:  BRA    5346
....................       //if(Inputt.B15 == 0) 
....................       { 
....................          if(Ack.B15 == 0) 
5302:  BTFSC  x32.6
5304:  BRA    5344
....................          { 
....................             if(In.B15 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
5306:  BTFSC  x36.6
5308:  BRA    5318
530A:  MOVF   60,W
530C:  SUBLW  0F
530E:  BNZ   5318
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
5310:  MOVLW  64
5312:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
5314:  MOVFF  61,1D
....................             } 
....................  
....................             In.B15 = 1;                                 // setbit in1 
5318:  BSF    x36.6
....................             if(FlashingFlag == 0) 
531A:  BTFSC  1A.1
531C:  BRA    5322
....................             { 
....................                Output.B15 = 0;           //Flash output1 
531E:  BCF    x1A.6
....................             } 
5320:  BRA    5324
....................             else 
....................             { 
....................                Output.B15 = 1; 
5322:  BSF    x1A.6
....................             } 
....................  
....................             if (~AutoTestFlag) 
5324:  BTFSC  1A.4
5326:  BRA    5344
....................             { 
....................                if(OutputBoth.B15 == 0)                  //Both output 
5328:  BTFSC  x2A.6
532A:  BRA    5336
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
532C:  BSF    F89.4
532E:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5330:  BSF    F89.3
5332:  BCF    F92.3
....................                } 
5334:  BRA    5344
....................                else 
....................                { 
....................                   if(OutputType.B15 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
5336:  BTFSS  x26.6
5338:  BRA    5340
533A:  BSF    F89.4
533C:  BCF    F92.4
533E:  BRA    5344
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
5340:  BSF    F89.3
5342:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
5344:  BRA    534C
....................       else if(FaultType.B15 == 1) Ack.B15 = 0; 
5346:  BTFSS  x22.6
5348:  BRA    534C
534A:  BCF    x32.6
....................    } 
534C:  BRA    5374
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B15 ^ InputType.B15) == 1) 
534E:  MOVLW  00
5350:  BTFSC  x16.6
5352:  MOVLW  01
5354:  MOVLB  2
5356:  MOVWF  x01
5358:  MOVLW  00
535A:  MOVLB  1
535C:  BTFSC  x1E.6
535E:  MOVLW  01
5360:  MOVLB  2
5362:  XORWF  x01,W
5364:  SUBLW  01
5366:  BNZ   5370
....................       { 
....................          Output.B15 = 0; 
5368:  MOVLB  1
536A:  BCF    x1A.6
....................       } 
536C:  BRA    5374
536E:  MOVLB  2
....................       else 
....................       { 
....................          Output.B15 = 1; 
5370:  MOVLB  1
5372:  BSF    x1A.6
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input16 
....................    if(AlarmIndicator.B16 == 1)    // Alarm Function 
5374:  BTFSS  x2E.7
5376:  BRA    53EA
....................    { 
....................       if((((Inputt.B16 ^ InputType.B16) == 1) && (FaultType.B16 == 1))|| In.B16 == 1)    // alarm1 occure and "Lock type" 
5378:  MOVLW  00
537A:  BTFSC  x16.7
537C:  MOVLW  01
537E:  MOVLB  2
5380:  MOVWF  x01
5382:  MOVLW  00
5384:  MOVLB  1
5386:  BTFSC  x1E.7
5388:  MOVLW  01
538A:  MOVLB  2
538C:  XORWF  x01,W
538E:  SUBLW  01
5390:  BNZ   5398
5392:  MOVLB  1
5394:  BTFSC  x22.7
5396:  BRA    539E
5398:  MOVLB  1
539A:  BTFSS  x36.7
539C:  BRA    53E2
....................       //if(Inputt.B16 == 0) 
....................       { 
....................          if(Ack.B16 == 0) 
539E:  BTFSC  x32.7
53A0:  BRA    53E0
....................          { 
....................             if(In.B16 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
53A2:  BTFSC  x36.7
53A4:  BRA    53B4
53A6:  MOVF   60,W
53A8:  SUBLW  0F
53AA:  BNZ   53B4
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
53AC:  MOVLW  64
53AE:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
53B0:  MOVFF  61,1D
....................             } 
....................  
....................             In.B16 = 1;                                 // setbit in1 
53B4:  BSF    x36.7
....................             if(FlashingFlag == 0) 
53B6:  BTFSC  1A.1
53B8:  BRA    53BE
....................             { 
....................                Output.B16 = 0;           //Flash output1 
53BA:  BCF    x1A.7
....................             } 
53BC:  BRA    53C0
....................             else 
....................             { 
....................                Output.B16 = 1; 
53BE:  BSF    x1A.7
....................             } 
....................  
....................  
....................             if (~AutoTestFlag) 
53C0:  BTFSC  1A.4
53C2:  BRA    53E0
....................             { 
....................                if(OutputBoth.B16 == 0)                  //Both output 
53C4:  BTFSC  x2A.7
53C6:  BRA    53D2
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
53C8:  BSF    F89.4
53CA:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
53CC:  BSF    F89.3
53CE:  BCF    F92.3
....................                } 
53D0:  BRA    53E0
....................                else 
....................                { 
....................                   if(OutputType.B16 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
53D2:  BTFSS  x26.7
53D4:  BRA    53DC
53D6:  BSF    F89.4
53D8:  BCF    F92.4
53DA:  BRA    53E0
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
53DC:  BSF    F89.3
53DE:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
53E0:  BRA    53E8
....................       else if(FaultType.B16 == 1) Ack.B16 = 0; 
53E2:  BTFSS  x22.7
53E4:  BRA    53E8
53E6:  BCF    x32.7
....................    } 
53E8:  BRA    5410
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B16 ^ InputType.B16) == 1) 
53EA:  MOVLW  00
53EC:  BTFSC  x16.7
53EE:  MOVLW  01
53F0:  MOVLB  2
53F2:  MOVWF  x01
53F4:  MOVLW  00
53F6:  MOVLB  1
53F8:  BTFSC  x1E.7
53FA:  MOVLW  01
53FC:  MOVLB  2
53FE:  XORWF  x01,W
5400:  SUBLW  01
5402:  BNZ   540C
....................       { 
....................          Output.B16 = 0; 
5404:  MOVLB  1
5406:  BCF    x1A.7
....................       } 
5408:  BRA    5410
540A:  MOVLB  2
....................       else 
....................       { 
....................          Output.B16 = 1; 
540C:  MOVLB  1
540E:  BSF    x1A.7
....................       } 
....................    } 
.................... //} 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input17 
....................     
....................    if(AlarmIndicator.B17 == 1)    // Alarm Function 
5410:  BTFSS  x2F.0
5412:  BRA    5486
....................    { 
....................       if((((Inputt.B17 ^ InputType.B17) == 1) && (FaultType.B17 == 1))|| In.B17 == 1)    // alarm1 occure and "Lock type" 
5414:  MOVLW  00
5416:  BTFSC  x17.0
5418:  MOVLW  01
541A:  MOVLB  2
541C:  MOVWF  x01
541E:  MOVLW  00
5420:  MOVLB  1
5422:  BTFSC  x1F.0
5424:  MOVLW  01
5426:  MOVLB  2
5428:  XORWF  x01,W
542A:  SUBLW  01
542C:  BNZ   5434
542E:  MOVLB  1
5430:  BTFSC  x23.0
5432:  BRA    543A
5434:  MOVLB  1
5436:  BTFSS  x37.0
5438:  BRA    547E
....................       //if(Inputt.B17 == 0) 
....................       { 
....................          if(Ack.B17 == 0) 
543A:  BTFSC  x33.0
543C:  BRA    547C
....................          { 
....................             if(In.B17 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
543E:  BTFSC  x37.0
5440:  BRA    5450
5442:  MOVF   60,W
5444:  SUBLW  0F
5446:  BNZ   5450
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
5448:  MOVLW  64
544A:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
544C:  MOVFF  61,1D
....................             } 
....................  
....................             In.B17 = 1;                                 // setbit in1 
5450:  BSF    x37.0
....................             if(FlashingFlag == 0) 
5452:  BTFSC  1A.1
5454:  BRA    545A
....................             { 
....................                Output.B17 = 0;           //Flash output1 
5456:  BCF    x1B.0
....................             } 
5458:  BRA    545C
....................             else 
....................             { 
....................                Output.B17 = 1; 
545A:  BSF    x1B.0
....................             } 
....................  
....................  
....................             if (~AutoTestFlag) 
545C:  BTFSC  1A.4
545E:  BRA    547C
....................             { 
....................                if(OutputBoth.B17 == 0)                  //Both output 
5460:  BTFSC  x2B.0
5462:  BRA    546E
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5464:  BSF    F89.4
5466:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5468:  BSF    F89.3
546A:  BCF    F92.3
....................                } 
546C:  BRA    547C
....................                else 
....................                { 
....................                   if(OutputType.B17 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
546E:  BTFSS  x27.0
5470:  BRA    5478
5472:  BSF    F89.4
5474:  BCF    F92.4
5476:  BRA    547C
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
5478:  BSF    F89.3
547A:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
547C:  BRA    5484
....................       else if(FaultType.B17 == 1) Ack.B17 = 0; 
547E:  BTFSS  x23.0
5480:  BRA    5484
5482:  BCF    x33.0
....................    } 
5484:  BRA    54AC
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B17 ^ InputType.B17) == 1) 
5486:  MOVLW  00
5488:  BTFSC  x17.0
548A:  MOVLW  01
548C:  MOVLB  2
548E:  MOVWF  x01
5490:  MOVLW  00
5492:  MOVLB  1
5494:  BTFSC  x1F.0
5496:  MOVLW  01
5498:  MOVLB  2
549A:  XORWF  x01,W
549C:  SUBLW  01
549E:  BNZ   54A8
....................       { 
....................          Output.B17 = 0; 
54A0:  MOVLB  1
54A2:  BCF    x1B.0
....................       } 
54A4:  BRA    54AC
54A6:  MOVLB  2
....................       else 
....................       { 
....................          Output.B17 = 1; 
54A8:  MOVLB  1
54AA:  BSF    x1B.0
....................       } 
....................    } 
.................... //} 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //input18 
....................    if(AlarmIndicator.B18 == 1)    // Alarm Function 
54AC:  BTFSS  x2F.1
54AE:  BRA    5522
....................    { 
....................       if((((Inputt.B18 ^ InputType.B18) == 1) && (FaultType.B18 == 1))|| In.B18 == 1)    // alarm1 occure and "Lock type" 
54B0:  MOVLW  00
54B2:  BTFSC  x17.1
54B4:  MOVLW  01
54B6:  MOVLB  2
54B8:  MOVWF  x01
54BA:  MOVLW  00
54BC:  MOVLB  1
54BE:  BTFSC  x1F.1
54C0:  MOVLW  01
54C2:  MOVLB  2
54C4:  XORWF  x01,W
54C6:  SUBLW  01
54C8:  BNZ   54D0
54CA:  MOVLB  1
54CC:  BTFSC  x23.1
54CE:  BRA    54D6
54D0:  MOVLB  1
54D2:  BTFSS  x37.1
54D4:  BRA    551A
....................       //if(Inputt.B18 == 0) 
....................       { 
....................          if(Ack.B18 == 0) 
54D6:  BTFSC  x33.1
54D8:  BRA    5518
....................          { 
....................             if(In.B18 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
54DA:  BTFSC  x37.1
54DC:  BRA    54EC
54DE:  MOVF   60,W
54E0:  SUBLW  0F
54E2:  BNZ   54EC
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
54E4:  MOVLW  64
54E6:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
54E8:  MOVFF  61,1D
....................             } 
....................  
....................             In.B18 = 1;                                 // setbit in1 
54EC:  BSF    x37.1
....................             if(FlashingFlag == 0) 
54EE:  BTFSC  1A.1
54F0:  BRA    54F6
....................             { 
....................                Output.B18 = 0;           //Flash output1 
54F2:  BCF    x1B.1
....................             } 
54F4:  BRA    54F8
....................             else 
....................             { 
....................                Output.B18 = 1; 
54F6:  BSF    x1B.1
....................             } 
....................  
....................  
....................             if (~AutoTestFlag) 
54F8:  BTFSC  1A.4
54FA:  BRA    5518
....................             { 
....................                if(OutputBoth.B18 == 0)                  //Both output 
54FC:  BTFSC  x2B.1
54FE:  BRA    550A
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5500:  BSF    F89.4
5502:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5504:  BSF    F89.3
5506:  BCF    F92.3
....................                } 
5508:  BRA    5518
....................                else 
....................                { 
....................                   if(OutputType.B18 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
550A:  BTFSS  x27.1
550C:  BRA    5514
550E:  BSF    F89.4
5510:  BCF    F92.4
5512:  BRA    5518
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
5514:  BSF    F89.3
5516:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
5518:  BRA    5520
....................       else if(FaultType.B18 == 1) Ack.B18 = 0; 
551A:  BTFSS  x23.1
551C:  BRA    5520
551E:  BCF    x33.1
....................    } 
5520:  BRA    5548
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B18 ^ InputType.B18) == 1) 
5522:  MOVLW  00
5524:  BTFSC  x17.1
5526:  MOVLW  01
5528:  MOVLB  2
552A:  MOVWF  x01
552C:  MOVLW  00
552E:  MOVLB  1
5530:  BTFSC  x1F.1
5532:  MOVLW  01
5534:  MOVLB  2
5536:  XORWF  x01,W
5538:  SUBLW  01
553A:  BNZ   5544
....................       { 
....................          Output.B18 = 0; 
553C:  MOVLB  1
553E:  BCF    x1B.1
....................       } 
5540:  BRA    5548
5542:  MOVLB  2
....................       else 
....................       { 
....................          Output.B18 = 1; 
5544:  MOVLB  1
5546:  BSF    x1B.1
....................       } 
....................    } 
.................... //} 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input19 
....................    if(AlarmIndicator.B19 == 1)    // Alarm Function 
5548:  BTFSS  x2F.2
554A:  BRA    55BE
....................    { 
....................       if((((Inputt.B19 ^ InputType.B19) == 1) && (FaultType.B19 == 1))|| In.B19 == 1)    // alarm1 occure and "Lock type" 
554C:  MOVLW  00
554E:  BTFSC  x17.2
5550:  MOVLW  01
5552:  MOVLB  2
5554:  MOVWF  x01
5556:  MOVLW  00
5558:  MOVLB  1
555A:  BTFSC  x1F.2
555C:  MOVLW  01
555E:  MOVLB  2
5560:  XORWF  x01,W
5562:  SUBLW  01
5564:  BNZ   556C
5566:  MOVLB  1
5568:  BTFSC  x23.2
556A:  BRA    5572
556C:  MOVLB  1
556E:  BTFSS  x37.2
5570:  BRA    55B6
....................       //if(Inputt.B19 == 0) 
....................       { 
....................          if(Ack.B19 == 0) 
5572:  BTFSC  x33.2
5574:  BRA    55B4
....................          { 
....................             if(In.B19 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
5576:  BTFSC  x37.2
5578:  BRA    5588
557A:  MOVF   60,W
557C:  SUBLW  0F
557E:  BNZ   5588
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
5580:  MOVLW  64
5582:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
5584:  MOVFF  61,1D
....................             } 
....................  
....................             In.B19 = 1;                                 // setbit in1 
5588:  BSF    x37.2
....................             if(FlashingFlag == 0) 
558A:  BTFSC  1A.1
558C:  BRA    5592
....................             { 
....................                Output.B19 = 0;           //Flash output1 
558E:  BCF    x1B.2
....................             } 
5590:  BRA    5594
....................             else 
....................             { 
....................                Output.B19 = 1; 
5592:  BSF    x1B.2
....................             } 
....................  
....................  
....................             if (~AutoTestFlag) 
5594:  BTFSC  1A.4
5596:  BRA    55B4
....................             { 
....................                if(OutputBoth.B19 == 0)                  //Both output 
5598:  BTFSC  x2B.2
559A:  BRA    55A6
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
559C:  BSF    F89.4
559E:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
55A0:  BSF    F89.3
55A2:  BCF    F92.3
....................                } 
55A4:  BRA    55B4
....................                else 
....................                { 
....................                   if(OutputType.B19 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
55A6:  BTFSS  x27.2
55A8:  BRA    55B0
55AA:  BSF    F89.4
55AC:  BCF    F92.4
55AE:  BRA    55B4
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
55B0:  BSF    F89.3
55B2:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
55B4:  BRA    55BC
....................       else if(FaultType.B19 == 1) Ack.B19 = 0; 
55B6:  BTFSS  x23.2
55B8:  BRA    55BC
55BA:  BCF    x33.2
....................    } 
55BC:  BRA    55E4
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B19 ^ InputType.B19) == 1) 
55BE:  MOVLW  00
55C0:  BTFSC  x17.2
55C2:  MOVLW  01
55C4:  MOVLB  2
55C6:  MOVWF  x01
55C8:  MOVLW  00
55CA:  MOVLB  1
55CC:  BTFSC  x1F.2
55CE:  MOVLW  01
55D0:  MOVLB  2
55D2:  XORWF  x01,W
55D4:  SUBLW  01
55D6:  BNZ   55E0
....................       { 
....................          Output.B19 = 0; 
55D8:  MOVLB  1
55DA:  BCF    x1B.2
....................       } 
55DC:  BRA    55E4
55DE:  MOVLB  2
....................       else 
....................       { 
....................          Output.B19 = 1; 
55E0:  MOVLB  1
55E2:  BSF    x1B.2
....................       } 
....................    } 
.................... //} 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input20 
....................    if(AlarmIndicator.B20 == 1)    // Alarm Function 
55E4:  BTFSS  x2F.3
55E6:  BRA    565A
....................    { 
....................       if((((Inputt.B20 ^ InputType.B20) == 1) && (FaultType.B20 == 1))|| In.B20 == 1)    // alarm1 occure and "Lock type" 
55E8:  MOVLW  00
55EA:  BTFSC  x17.3
55EC:  MOVLW  01
55EE:  MOVLB  2
55F0:  MOVWF  x01
55F2:  MOVLW  00
55F4:  MOVLB  1
55F6:  BTFSC  x1F.3
55F8:  MOVLW  01
55FA:  MOVLB  2
55FC:  XORWF  x01,W
55FE:  SUBLW  01
5600:  BNZ   5608
5602:  MOVLB  1
5604:  BTFSC  x23.3
5606:  BRA    560E
5608:  MOVLB  1
560A:  BTFSS  x37.3
560C:  BRA    5652
....................       //if(Inputt.B18 == 0) 
....................       { 
....................          if(Ack.B20 == 0) 
560E:  BTFSC  x33.3
5610:  BRA    5650
....................          { 
....................             if(In.B20 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
5612:  BTFSC  x37.3
5614:  BRA    5624
5616:  MOVF   60,W
5618:  SUBLW  0F
561A:  BNZ   5624
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
561C:  MOVLW  64
561E:  MOVWF  1C
....................                AutoAckDelayTime = AutoAckTime ; 
5620:  MOVFF  61,1D
....................             } 
....................  
....................             In.B20 = 1;                                 // setbit in1 
5624:  BSF    x37.3
....................             if(FlashingFlag == 0) 
5626:  BTFSC  1A.1
5628:  BRA    562E
....................             { 
....................                Output.B20 = 0;           //Flash output1 
562A:  BCF    x1B.3
....................             } 
562C:  BRA    5630
....................             else 
....................             { 
....................                Output.B20 = 1; 
562E:  BSF    x1B.3
....................             } 
....................  
....................  
....................             if (~AutoTestFlag) 
5630:  BTFSC  1A.4
5632:  BRA    5650
....................             { 
....................                if(OutputBoth.B20 == 0)                  //Both output 
5634:  BTFSC  x2B.3
5636:  BRA    5642
....................                { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5638:  BSF    F89.4
563A:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
563C:  BSF    F89.3
563E:  BCF    F92.3
....................                } 
5640:  BRA    5650
....................                else 
....................                { 
....................                   if(OutputType.B20 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
5642:  BTFSS  x27.3
5644:  BRA    564C
5646:  BSF    F89.4
5648:  BCF    F92.4
564A:  BRA    5650
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
564C:  BSF    F89.3
564E:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
5650:  BRA    5658
....................       else if(FaultType.B20 == 1) Ack.B20 = 0; 
5652:  BTFSS  x23.3
5654:  BRA    5658
5656:  BCF    x33.3
....................    } 
5658:  BRA    5680
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B20 ^ InputType.B20) == 1) 
565A:  MOVLW  00
565C:  BTFSC  x17.3
565E:  MOVLW  01
5660:  MOVLB  2
5662:  MOVWF  x01
5664:  MOVLW  00
5666:  MOVLB  1
5668:  BTFSC  x1F.3
566A:  MOVLW  01
566C:  MOVLB  2
566E:  XORWF  x01,W
5670:  SUBLW  01
5672:  BNZ   567C
....................       { 
....................          Output.B20 = 0; 
5674:  MOVLB  1
5676:  BCF    x1B.3
....................       } 
5678:  BRA    5680
567A:  MOVLB  2
....................       else 
....................       { 
....................          Output.B20 = 1; 
567C:  MOVLB  1
567E:  BSF    x1B.3
....................       } 
....................    } 
....................      
.................... //} 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////// END MANUAL RESET ////////////////////////////////////////// 
....................  
....................  
....................    ///////////////////////////////////////////////////////////////////////////// 
....................    ////////////////////////////// AUTO RESET /////////////////////////////////// 
....................    ///////////////////////////////////////////////////////////////////////////// 
....................  
.................... //if(NoOfPoint >= 10) 
.................... //{ 
.................... static unsigned char inputflag = 0; 
....................  
.................... //input1 
....................    if((((Inputt.B1 ^ InputType.B1) == 1) && (FaultType.B1 == 0)) ||Test_fault==1)   // alarm1 occure and " Non Lock type" 
5680:  MOVLW  00
5682:  BTFSC  x15.0
5684:  MOVLW  01
5686:  MOVLB  2
5688:  MOVWF  x01
568A:  MOVLW  00
568C:  MOVLB  1
568E:  BTFSC  x1D.0
5690:  MOVLW  01
5692:  MOVLB  2
5694:  XORWF  x01,W
5696:  SUBLW  01
5698:  BNZ   56A2
569A:  MOVLB  1
569C:  BTFSS  x21.0
569E:  BRA    56A8
56A0:  MOVLB  2
56A2:  BTFSS  1A.5
56A4:  BRA    56F8
56A6:  MOVLB  1
....................    { 
....................       if(In2.B1 == 0 && AutoAck == 0x0F && Ack.B1 == 0)   //use auto acknowlegde 
56A8:  BTFSC  x39.0
56AA:  BRA    56BE
56AC:  MOVF   60,W
56AE:  SUBLW  0F
56B0:  BNZ   56BE
56B2:  BTFSC  x31.0
56B4:  BRA    56BE
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
56B6:  MOVLW  64
56B8:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
56BA:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B1 = 1; 
56BE:  BSF    x39.0
....................       if(Ack.B1 == 0) 
56C0:  BTFSC  x31.0
56C2:  BRA    56F2
....................       { 
....................          if(FlashingFlag == 0) 
56C4:  BTFSC  1A.1
56C6:  BRA    56CC
....................             { 
....................                Output.B1 = 0;           //Flash output1 
56C8:  BCF    x19.0
....................             } 
56CA:  BRA    56CE
....................             else 
....................             { 
....................                Output.B1 = 1; 
56CC:  BSF    x19.0
....................             } 
....................          if (~AutoTestFlag) 
56CE:  BTFSC  1A.4
56D0:  BRA    56F2
....................          { 
....................             if(AlarmIndicator.B1 == 1){ 
56D2:  BTFSS  x2D.0
56D4:  BRA    56F2
....................                 if(OutputBoth.B1 == 0)        //Both output 
56D6:  BTFSC  x29.0
56D8:  BRA    56E4
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
56DA:  BSF    F89.4
56DC:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
56DE:  BSF    F89.3
56E0:  BCF    F92.3
....................                 } 
56E2:  BRA    56F2
....................                 else 
....................                 { 
....................                   if(OutputType.B1 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
56E4:  BTFSS  x25.0
56E6:  BRA    56EE
56E8:  BSF    F89.4
56EA:  BCF    F92.4
56EC:  BRA    56F2
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
56EE:  BSF    F89.3
56F0:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................        inputflag =1; 
56F2:  MOVLW  01
56F4:  MOVWF  xE4
....................    } 
56F6:  BRA    57A4
....................     
....................    else if(FaultType.B1 == 0) 
56F8:  MOVLB  1
56FA:  BTFSC  x21.0
56FC:  BRA    57A4
....................    { 
....................       In2.B1 = 0x00; 
56FE:  BCF    x39.0
....................       Ack.B1 = 0; 
5700:  BCF    x31.0
....................       Output.B1 = 1;      //Off LED 
5702:  BSF    x19.0
....................  
....................       if((OutputType.B1 == 1 || OutputBoth.B1 == 0) && inputflag ==0)     //If Buzzer or Both 
5704:  BTFSC  x25.0
5706:  BRA    570C
5708:  BTFSC  x29.0
570A:  BRA    5726
570C:  MOVF   xE4,F
570E:  BNZ   5726
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
5710:  MOVLW  01
5712:  MOVWF  xEF
5714:  MOVLB  0
5716:  CALL   40E6
571A:  DECFSZ 01,W
571C:  BRA    5720
571E:  BRA    5724
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5720:  BCF    F89.4
5722:  BCF    F92.4
5724:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B1 == 0 || OutputBoth.B1 == 0) && inputflag ==0)  //If Bell or Both 
5726:  BTFSS  x25.0
5728:  BRA    572E
572A:  BTFSC  x29.0
572C:  BRA    574C
572E:  MOVF   xE4,F
5730:  BNZ   574C
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5732:  MOVLW  02
5734:  MOVWF  xEF
5736:  MOVLB  0
5738:  CALL   40E6
573C:  DECFSZ 01,W
573E:  BRA    5742
5740:  BRA    574A
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
5742:  BCF    F89.3
5744:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5746:  BCF    F89.4
5748:  BCF    F92.4
574A:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
574C:  BTFSC  x39.0
574E:  BRA    57A4
5750:  BTFSC  x39.1
5752:  BRA    57A4
5754:  BTFSC  x39.2
5756:  BRA    57A4
5758:  BTFSC  x39.3
575A:  BRA    57A4
575C:  BTFSC  x39.4
575E:  BRA    57A4
5760:  BTFSC  x39.5
5762:  BRA    57A4
5764:  BTFSC  x39.6
5766:  BRA    57A4
5768:  BTFSC  x39.7
576A:  BRA    57A4
576C:  BTFSC  x3A.0
576E:  BRA    57A4
5770:  BTFSC  x3A.1
5772:  BRA    57A4
5774:  BTFSC  x3A.2
5776:  BRA    57A4
5778:  BTFSC  x3A.3
577A:  BRA    57A4
577C:  BTFSC  x3A.4
577E:  BRA    57A4
5780:  BTFSC  x3A.5
5782:  BRA    57A4
5784:  BTFSC  x3A.6
5786:  BRA    57A4
5788:  BTFSC  x3A.7
578A:  BRA    57A4
578C:  BTFSC  x3B.0
578E:  BRA    57A4
5790:  BTFSC  x3B.1
5792:  BRA    57A4
5794:  BTFSC  x3B.2
5796:  BRA    57A4
5798:  BTFSC  x3B.3
579A:  BRA    57A4
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
579C:  BCF    F89.3
579E:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
57A0:  BCF    F89.4
57A2:  BCF    F92.4
....................       } 
....................    } 
....................     
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input2 
....................    if((((Inputt.B2 ^ InputType.B2) == 1) && (FaultType.B2 == 0)) ||Test_fault==1)   // alarm1 occure and " Non Lock type" 
57A4:  MOVLW  00
57A6:  BTFSC  x15.1
57A8:  MOVLW  01
57AA:  MOVLB  2
57AC:  MOVWF  x01
57AE:  MOVLW  00
57B0:  MOVLB  1
57B2:  BTFSC  x1D.1
57B4:  MOVLW  01
57B6:  MOVLB  2
57B8:  XORWF  x01,W
57BA:  SUBLW  01
57BC:  BNZ   57C6
57BE:  MOVLB  1
57C0:  BTFSS  x21.1
57C2:  BRA    57CC
57C4:  MOVLB  2
57C6:  BTFSS  1A.5
57C8:  BRA    581C
57CA:  MOVLB  1
....................    { 
....................       if(In2.B2 == 0 && AutoAck == 0x0F && Ack.B2 == 0)   //use auto acknowlegde 
57CC:  BTFSC  x39.1
57CE:  BRA    57E2
57D0:  MOVF   60,W
57D2:  SUBLW  0F
57D4:  BNZ   57E2
57D6:  BTFSC  x31.1
57D8:  BRA    57E2
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
57DA:  MOVLW  64
57DC:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
57DE:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B2 = 1; 
57E2:  BSF    x39.1
....................       if(Ack.B2 == 0) 
57E4:  BTFSC  x31.1
57E6:  BRA    5816
....................       { 
....................          if(FlashingFlag == 0) 
57E8:  BTFSC  1A.1
57EA:  BRA    57F0
....................             { 
....................                Output.B2 = 0;           //Flash output1 
57EC:  BCF    x19.1
....................             } 
57EE:  BRA    57F2
....................             else 
....................             { 
....................                Output.B2 = 1; 
57F0:  BSF    x19.1
....................             } 
....................          if (~AutoTestFlag) 
57F2:  BTFSC  1A.4
57F4:  BRA    5816
....................          { 
....................             if(AlarmIndicator.B2 == 1){ 
57F6:  BTFSS  x2D.1
57F8:  BRA    5816
....................                 if(OutputBoth.B2 == 0)        //Both output 
57FA:  BTFSC  x29.1
57FC:  BRA    5808
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
57FE:  BSF    F89.4
5800:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5802:  BSF    F89.3
5804:  BCF    F92.3
....................                 } 
5806:  BRA    5816
....................                 else 
....................                 { 
....................                   if(OutputType.B2 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
5808:  BTFSS  x25.1
580A:  BRA    5812
580C:  BSF    F89.4
580E:  BCF    F92.4
5810:  BRA    5816
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
5812:  BSF    F89.3
5814:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
5816:  MOVLW  01
5818:  MOVWF  xE4
....................    } 
581A:  BRA    58C8
....................    else if(FaultType.B2 == 0) 
581C:  MOVLB  1
581E:  BTFSC  x21.1
5820:  BRA    58C8
....................    { 
....................       In2.B2 = 0x00; 
5822:  BCF    x39.1
....................       Ack.B2 = 0; 
5824:  BCF    x31.1
....................       Output.B2 = 1;      //Off LED 
5826:  BSF    x19.1
....................  
....................       if((OutputType.B2 == 1 || OutputBoth.B2 == 0) && inputflag ==0)     //If Buzzer or Both 
5828:  BTFSC  x25.1
582A:  BRA    5830
582C:  BTFSC  x29.1
582E:  BRA    584A
5830:  MOVF   xE4,F
5832:  BNZ   584A
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
5834:  MOVLW  01
5836:  MOVWF  xEF
5838:  MOVLB  0
583A:  CALL   40E6
583E:  DECFSZ 01,W
5840:  BRA    5844
5842:  BRA    5848
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5844:  BCF    F89.4
5846:  BCF    F92.4
5848:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B2 == 0 || OutputBoth.B2 == 0) && inputflag ==0) //If Bell or Both 
584A:  BTFSS  x25.1
584C:  BRA    5852
584E:  BTFSC  x29.1
5850:  BRA    5870
5852:  MOVF   xE4,F
5854:  BNZ   5870
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5856:  MOVLW  02
5858:  MOVWF  xEF
585A:  MOVLB  0
585C:  CALL   40E6
5860:  DECFSZ 01,W
5862:  BRA    5866
5864:  BRA    586E
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
5866:  BCF    F89.3
5868:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
586A:  BCF    F89.4
586C:  BCF    F92.4
586E:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
5870:  BTFSC  x39.0
5872:  BRA    58C8
5874:  BTFSC  x39.1
5876:  BRA    58C8
5878:  BTFSC  x39.2
587A:  BRA    58C8
587C:  BTFSC  x39.3
587E:  BRA    58C8
5880:  BTFSC  x39.4
5882:  BRA    58C8
5884:  BTFSC  x39.5
5886:  BRA    58C8
5888:  BTFSC  x39.6
588A:  BRA    58C8
588C:  BTFSC  x39.7
588E:  BRA    58C8
5890:  BTFSC  x3A.0
5892:  BRA    58C8
5894:  BTFSC  x3A.1
5896:  BRA    58C8
5898:  BTFSC  x3A.2
589A:  BRA    58C8
589C:  BTFSC  x3A.3
589E:  BRA    58C8
58A0:  BTFSC  x3A.4
58A2:  BRA    58C8
58A4:  BTFSC  x3A.5
58A6:  BRA    58C8
58A8:  BTFSC  x3A.6
58AA:  BRA    58C8
58AC:  BTFSC  x3A.7
58AE:  BRA    58C8
58B0:  BTFSC  x3B.0
58B2:  BRA    58C8
58B4:  BTFSC  x3B.1
58B6:  BRA    58C8
58B8:  BTFSC  x3B.2
58BA:  BRA    58C8
58BC:  BTFSC  x3B.3
58BE:  BRA    58C8
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
58C0:  BCF    F89.3
58C2:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
58C4:  BCF    F89.4
58C6:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input3 
....................    if((((Inputt.B3 ^ InputType.B3) == 1) && (FaultType.B3 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
58C8:  MOVLW  00
58CA:  BTFSC  x15.2
58CC:  MOVLW  01
58CE:  MOVLB  2
58D0:  MOVWF  x01
58D2:  MOVLW  00
58D4:  MOVLB  1
58D6:  BTFSC  x1D.2
58D8:  MOVLW  01
58DA:  MOVLB  2
58DC:  XORWF  x01,W
58DE:  SUBLW  01
58E0:  BNZ   58EA
58E2:  MOVLB  1
58E4:  BTFSS  x21.2
58E6:  BRA    58F0
58E8:  MOVLB  2
58EA:  BTFSS  1A.5
58EC:  BRA    5940
58EE:  MOVLB  1
....................    { 
....................       if(In2.B3 == 0 && AutoAck == 0x0F && Ack.B3 == 0)   //use auto acknowlegde 
58F0:  BTFSC  x39.2
58F2:  BRA    5906
58F4:  MOVF   60,W
58F6:  SUBLW  0F
58F8:  BNZ   5906
58FA:  BTFSC  x31.2
58FC:  BRA    5906
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
58FE:  MOVLW  64
5900:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
5902:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B3 = 1; 
5906:  BSF    x39.2
....................       if(Ack.B3 == 0) 
5908:  BTFSC  x31.2
590A:  BRA    593A
....................       { 
....................          if(FlashingFlag == 0) 
590C:  BTFSC  1A.1
590E:  BRA    5914
....................             { 
....................                Output.B3 = 0;           //Flash output1 
5910:  BCF    x19.2
....................             } 
5912:  BRA    5916
....................             else 
....................             { 
....................                Output.B3 = 1; 
5914:  BSF    x19.2
....................             } 
....................          if (~AutoTestFlag) 
5916:  BTFSC  1A.4
5918:  BRA    593A
....................          { 
....................             if(AlarmIndicator.B3 == 1){ 
591A:  BTFSS  x2D.2
591C:  BRA    593A
....................                 if(OutputBoth.B3 == 0)        //Both output 
591E:  BTFSC  x29.2
5920:  BRA    592C
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5922:  BSF    F89.4
5924:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5926:  BSF    F89.3
5928:  BCF    F92.3
....................                 } 
592A:  BRA    593A
....................                 else 
....................                 { 
....................                   if(OutputType.B3 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
592C:  BTFSS  x25.2
592E:  BRA    5936
5930:  BSF    F89.4
5932:  BCF    F92.4
5934:  BRA    593A
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
5936:  BSF    F89.3
5938:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
593A:  MOVLW  01
593C:  MOVWF  xE4
....................    } 
593E:  BRA    59EC
....................    else if(FaultType.B3 == 0) 
5940:  MOVLB  1
5942:  BTFSC  x21.2
5944:  BRA    59EC
....................    { 
....................       In2.B3 = 0x00; 
5946:  BCF    x39.2
....................       Ack.B3 = 0; 
5948:  BCF    x31.2
....................       Output.B3 = 1;      //Off LED 
594A:  BSF    x19.2
....................  
....................       if((OutputType.B3 == 1 || OutputBoth.B3 == 0) && inputflag ==0)     //If Buzzer or Both 
594C:  BTFSC  x25.2
594E:  BRA    5954
5950:  BTFSC  x29.2
5952:  BRA    596E
5954:  MOVF   xE4,F
5956:  BNZ   596E
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
5958:  MOVLW  01
595A:  MOVWF  xEF
595C:  MOVLB  0
595E:  CALL   40E6
5962:  DECFSZ 01,W
5964:  BRA    5968
5966:  BRA    596C
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5968:  BCF    F89.4
596A:  BCF    F92.4
596C:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B3 == 0 || OutputBoth.B3 == 0) && inputflag ==0) //If Bell or Both 
596E:  BTFSS  x25.2
5970:  BRA    5976
5972:  BTFSC  x29.2
5974:  BRA    5994
5976:  MOVF   xE4,F
5978:  BNZ   5994
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
597A:  MOVLW  02
597C:  MOVWF  xEF
597E:  MOVLB  0
5980:  CALL   40E6
5984:  DECFSZ 01,W
5986:  BRA    598A
5988:  BRA    5992
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
598A:  BCF    F89.3
598C:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
598E:  BCF    F89.4
5990:  BCF    F92.4
5992:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
5994:  BTFSC  x39.0
5996:  BRA    59EC
5998:  BTFSC  x39.1
599A:  BRA    59EC
599C:  BTFSC  x39.2
599E:  BRA    59EC
59A0:  BTFSC  x39.3
59A2:  BRA    59EC
59A4:  BTFSC  x39.4
59A6:  BRA    59EC
59A8:  BTFSC  x39.5
59AA:  BRA    59EC
59AC:  BTFSC  x39.6
59AE:  BRA    59EC
59B0:  BTFSC  x39.7
59B2:  BRA    59EC
59B4:  BTFSC  x3A.0
59B6:  BRA    59EC
59B8:  BTFSC  x3A.1
59BA:  BRA    59EC
59BC:  BTFSC  x3A.2
59BE:  BRA    59EC
59C0:  BTFSC  x3A.3
59C2:  BRA    59EC
59C4:  BTFSC  x3A.4
59C6:  BRA    59EC
59C8:  BTFSC  x3A.5
59CA:  BRA    59EC
59CC:  BTFSC  x3A.6
59CE:  BRA    59EC
59D0:  BTFSC  x3A.7
59D2:  BRA    59EC
59D4:  BTFSC  x3B.0
59D6:  BRA    59EC
59D8:  BTFSC  x3B.1
59DA:  BRA    59EC
59DC:  BTFSC  x3B.2
59DE:  BRA    59EC
59E0:  BTFSC  x3B.3
59E2:  BRA    59EC
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
59E4:  BCF    F89.3
59E6:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
59E8:  BCF    F89.4
59EA:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input4 
....................    if((((Inputt.B4 ^ InputType.B4) == 1) && (FaultType.B4 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
59EC:  MOVLW  00
59EE:  BTFSC  x15.3
59F0:  MOVLW  01
59F2:  MOVLB  2
59F4:  MOVWF  x01
59F6:  MOVLW  00
59F8:  MOVLB  1
59FA:  BTFSC  x1D.3
59FC:  MOVLW  01
59FE:  MOVLB  2
5A00:  XORWF  x01,W
5A02:  SUBLW  01
5A04:  BNZ   5A0E
5A06:  MOVLB  1
5A08:  BTFSS  x21.3
5A0A:  BRA    5A14
5A0C:  MOVLB  2
5A0E:  BTFSS  1A.5
5A10:  BRA    5A64
5A12:  MOVLB  1
....................    { 
....................       if(In2.B4 == 0 && AutoAck == 0x0F && Ack.B4 == 0)   //use auto acknowlegde 
5A14:  BTFSC  x39.3
5A16:  BRA    5A2A
5A18:  MOVF   60,W
5A1A:  SUBLW  0F
5A1C:  BNZ   5A2A
5A1E:  BTFSC  x31.3
5A20:  BRA    5A2A
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
5A22:  MOVLW  64
5A24:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
5A26:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B4 = 1; 
5A2A:  BSF    x39.3
....................       if(Ack.B4 == 0) 
5A2C:  BTFSC  x31.3
5A2E:  BRA    5A5E
....................       { 
....................          if(FlashingFlag == 0) 
5A30:  BTFSC  1A.1
5A32:  BRA    5A38
....................             { 
....................                Output.B4 = 0;           //Flash output1 
5A34:  BCF    x19.3
....................             } 
5A36:  BRA    5A3A
....................             else 
....................             { 
....................                Output.B4 = 1; 
5A38:  BSF    x19.3
....................             } 
....................          if (~AutoTestFlag) 
5A3A:  BTFSC  1A.4
5A3C:  BRA    5A5E
....................          { 
....................             if(AlarmIndicator.B4 == 1){ 
5A3E:  BTFSS  x2D.3
5A40:  BRA    5A5E
....................                 if(OutputBoth.B4 == 0)        //Both output 
5A42:  BTFSC  x29.3
5A44:  BRA    5A50
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5A46:  BSF    F89.4
5A48:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5A4A:  BSF    F89.3
5A4C:  BCF    F92.3
....................                 } 
5A4E:  BRA    5A5E
....................                 else 
....................                 { 
....................                   if(OutputType.B4 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
5A50:  BTFSS  x25.3
5A52:  BRA    5A5A
5A54:  BSF    F89.4
5A56:  BCF    F92.4
5A58:  BRA    5A5E
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
5A5A:  BSF    F89.3
5A5C:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
5A5E:  MOVLW  01
5A60:  MOVWF  xE4
....................    } 
5A62:  BRA    5B10
....................    else if(FaultType.B4 == 0) 
5A64:  MOVLB  1
5A66:  BTFSC  x21.3
5A68:  BRA    5B10
....................    { 
....................       In2.B4 = 0x00; 
5A6A:  BCF    x39.3
....................       Ack.B4 = 0; 
5A6C:  BCF    x31.3
....................       Output.B4 = 1;      //Off LED 
5A6E:  BSF    x19.3
....................  
....................       if((OutputType.B4 == 1 || OutputBoth.B4 == 0) && inputflag ==0)     //If Buzzer or Both 
5A70:  BTFSC  x25.3
5A72:  BRA    5A78
5A74:  BTFSC  x29.3
5A76:  BRA    5A92
5A78:  MOVF   xE4,F
5A7A:  BNZ   5A92
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
5A7C:  MOVLW  01
5A7E:  MOVWF  xEF
5A80:  MOVLB  0
5A82:  CALL   40E6
5A86:  DECFSZ 01,W
5A88:  BRA    5A8C
5A8A:  BRA    5A90
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5A8C:  BCF    F89.4
5A8E:  BCF    F92.4
5A90:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B4 == 0 || OutputBoth.B4 == 0) && inputflag ==0)  //If Bell or Both 
5A92:  BTFSS  x25.3
5A94:  BRA    5A9A
5A96:  BTFSC  x29.3
5A98:  BRA    5AB8
5A9A:  MOVF   xE4,F
5A9C:  BNZ   5AB8
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5A9E:  MOVLW  02
5AA0:  MOVWF  xEF
5AA2:  MOVLB  0
5AA4:  CALL   40E6
5AA8:  DECFSZ 01,W
5AAA:  BRA    5AAE
5AAC:  BRA    5AB6
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
5AAE:  BCF    F89.3
5AB0:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5AB2:  BCF    F89.4
5AB4:  BCF    F92.4
5AB6:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
5AB8:  BTFSC  x39.0
5ABA:  BRA    5B10
5ABC:  BTFSC  x39.1
5ABE:  BRA    5B10
5AC0:  BTFSC  x39.2
5AC2:  BRA    5B10
5AC4:  BTFSC  x39.3
5AC6:  BRA    5B10
5AC8:  BTFSC  x39.4
5ACA:  BRA    5B10
5ACC:  BTFSC  x39.5
5ACE:  BRA    5B10
5AD0:  BTFSC  x39.6
5AD2:  BRA    5B10
5AD4:  BTFSC  x39.7
5AD6:  BRA    5B10
5AD8:  BTFSC  x3A.0
5ADA:  BRA    5B10
5ADC:  BTFSC  x3A.1
5ADE:  BRA    5B10
5AE0:  BTFSC  x3A.2
5AE2:  BRA    5B10
5AE4:  BTFSC  x3A.3
5AE6:  BRA    5B10
5AE8:  BTFSC  x3A.4
5AEA:  BRA    5B10
5AEC:  BTFSC  x3A.5
5AEE:  BRA    5B10
5AF0:  BTFSC  x3A.6
5AF2:  BRA    5B10
5AF4:  BTFSC  x3A.7
5AF6:  BRA    5B10
5AF8:  BTFSC  x3B.0
5AFA:  BRA    5B10
5AFC:  BTFSC  x3B.1
5AFE:  BRA    5B10
5B00:  BTFSC  x3B.2
5B02:  BRA    5B10
5B04:  BTFSC  x3B.3
5B06:  BRA    5B10
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
5B08:  BCF    F89.3
5B0A:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5B0C:  BCF    F89.4
5B0E:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input5 
....................    if((((Inputt.B5 ^ InputType.B5) == 1) && (FaultType.B5 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
5B10:  MOVLW  00
5B12:  BTFSC  x15.4
5B14:  MOVLW  01
5B16:  MOVLB  2
5B18:  MOVWF  x01
5B1A:  MOVLW  00
5B1C:  MOVLB  1
5B1E:  BTFSC  x1D.4
5B20:  MOVLW  01
5B22:  MOVLB  2
5B24:  XORWF  x01,W
5B26:  SUBLW  01
5B28:  BNZ   5B32
5B2A:  MOVLB  1
5B2C:  BTFSS  x21.4
5B2E:  BRA    5B38
5B30:  MOVLB  2
5B32:  BTFSS  1A.5
5B34:  BRA    5B88
5B36:  MOVLB  1
....................    { 
....................       if(In2.B5 == 0 && AutoAck == 0x0F && Ack.B5 == 0)   //use auto acknowlegde 
5B38:  BTFSC  x39.4
5B3A:  BRA    5B4E
5B3C:  MOVF   60,W
5B3E:  SUBLW  0F
5B40:  BNZ   5B4E
5B42:  BTFSC  x31.4
5B44:  BRA    5B4E
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
5B46:  MOVLW  64
5B48:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
5B4A:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B5 = 1; 
5B4E:  BSF    x39.4
....................       if(Ack.B5 == 0) 
5B50:  BTFSC  x31.4
5B52:  BRA    5B82
....................       { 
....................          if(FlashingFlag == 0) 
5B54:  BTFSC  1A.1
5B56:  BRA    5B5C
....................             { 
....................                Output.B5 = 0;           //Flash output1 
5B58:  BCF    x19.4
....................             } 
5B5A:  BRA    5B5E
....................             else 
....................             { 
....................                Output.B5 = 1; 
5B5C:  BSF    x19.4
....................             } 
....................          if (~AutoTestFlag) 
5B5E:  BTFSC  1A.4
5B60:  BRA    5B82
....................          { 
....................             if(AlarmIndicator.B5 == 1){ 
5B62:  BTFSS  x2D.4
5B64:  BRA    5B82
....................                 if(OutputBoth.B5 == 0)        //Both output 
5B66:  BTFSC  x29.4
5B68:  BRA    5B74
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5B6A:  BSF    F89.4
5B6C:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5B6E:  BSF    F89.3
5B70:  BCF    F92.3
....................                 } 
5B72:  BRA    5B82
....................                 else 
....................                 { 
....................                   if(OutputType.B5 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
5B74:  BTFSS  x25.4
5B76:  BRA    5B7E
5B78:  BSF    F89.4
5B7A:  BCF    F92.4
5B7C:  BRA    5B82
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
5B7E:  BSF    F89.3
5B80:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
5B82:  MOVLW  01
5B84:  MOVWF  xE4
....................    } 
5B86:  BRA    5C34
....................    else if(FaultType.B5 == 0) 
5B88:  MOVLB  1
5B8A:  BTFSC  x21.4
5B8C:  BRA    5C34
....................    { 
....................       In2.B5 = 0x00; 
5B8E:  BCF    x39.4
....................       Ack.B5 = 0; 
5B90:  BCF    x31.4
....................       Output.B5 = 1;      //Off LED 
5B92:  BSF    x19.4
....................  
....................       if((OutputType.B5 == 1 || OutputBoth.B5 == 0) && inputflag ==0)     //If Buzzer or Both 
5B94:  BTFSC  x25.4
5B96:  BRA    5B9C
5B98:  BTFSC  x29.4
5B9A:  BRA    5BB6
5B9C:  MOVF   xE4,F
5B9E:  BNZ   5BB6
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
5BA0:  MOVLW  01
5BA2:  MOVWF  xEF
5BA4:  MOVLB  0
5BA6:  CALL   40E6
5BAA:  DECFSZ 01,W
5BAC:  BRA    5BB0
5BAE:  BRA    5BB4
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5BB0:  BCF    F89.4
5BB2:  BCF    F92.4
5BB4:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B5 == 0 || OutputBoth.B5 == 0) && inputflag ==0) //If Bell or Both 
5BB6:  BTFSS  x25.4
5BB8:  BRA    5BBE
5BBA:  BTFSC  x29.4
5BBC:  BRA    5BDC
5BBE:  MOVF   xE4,F
5BC0:  BNZ   5BDC
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5BC2:  MOVLW  02
5BC4:  MOVWF  xEF
5BC6:  MOVLB  0
5BC8:  CALL   40E6
5BCC:  DECFSZ 01,W
5BCE:  BRA    5BD2
5BD0:  BRA    5BDA
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
5BD2:  BCF    F89.3
5BD4:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5BD6:  BCF    F89.4
5BD8:  BCF    F92.4
5BDA:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
5BDC:  BTFSC  x39.0
5BDE:  BRA    5C34
5BE0:  BTFSC  x39.1
5BE2:  BRA    5C34
5BE4:  BTFSC  x39.2
5BE6:  BRA    5C34
5BE8:  BTFSC  x39.3
5BEA:  BRA    5C34
5BEC:  BTFSC  x39.4
5BEE:  BRA    5C34
5BF0:  BTFSC  x39.5
5BF2:  BRA    5C34
5BF4:  BTFSC  x39.6
5BF6:  BRA    5C34
5BF8:  BTFSC  x39.7
5BFA:  BRA    5C34
5BFC:  BTFSC  x3A.0
5BFE:  BRA    5C34
5C00:  BTFSC  x3A.1
5C02:  BRA    5C34
5C04:  BTFSC  x3A.2
5C06:  BRA    5C34
5C08:  BTFSC  x3A.3
5C0A:  BRA    5C34
5C0C:  BTFSC  x3A.4
5C0E:  BRA    5C34
5C10:  BTFSC  x3A.5
5C12:  BRA    5C34
5C14:  BTFSC  x3A.6
5C16:  BRA    5C34
5C18:  BTFSC  x3A.7
5C1A:  BRA    5C34
5C1C:  BTFSC  x3B.0
5C1E:  BRA    5C34
5C20:  BTFSC  x3B.1
5C22:  BRA    5C34
5C24:  BTFSC  x3B.2
5C26:  BRA    5C34
5C28:  BTFSC  x3B.3
5C2A:  BRA    5C34
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
5C2C:  BCF    F89.3
5C2E:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5C30:  BCF    F89.4
5C32:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input6 
....................    if((((Inputt.B6 ^ InputType.B6) == 1) && (FaultType.B6 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
5C34:  MOVLW  00
5C36:  BTFSC  x15.5
5C38:  MOVLW  01
5C3A:  MOVLB  2
5C3C:  MOVWF  x01
5C3E:  MOVLW  00
5C40:  MOVLB  1
5C42:  BTFSC  x1D.5
5C44:  MOVLW  01
5C46:  MOVLB  2
5C48:  XORWF  x01,W
5C4A:  SUBLW  01
5C4C:  BNZ   5C56
5C4E:  MOVLB  1
5C50:  BTFSS  x21.5
5C52:  BRA    5C5C
5C54:  MOVLB  2
5C56:  BTFSS  1A.5
5C58:  BRA    5CAC
5C5A:  MOVLB  1
....................    { 
....................       if(In2.B6 == 0 && AutoAck == 0x0F && Ack.B6 == 0)   //use auto acknowlegde 
5C5C:  BTFSC  x39.5
5C5E:  BRA    5C72
5C60:  MOVF   60,W
5C62:  SUBLW  0F
5C64:  BNZ   5C72
5C66:  BTFSC  x31.5
5C68:  BRA    5C72
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
5C6A:  MOVLW  64
5C6C:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
5C6E:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B6 = 1; 
5C72:  BSF    x39.5
....................       if(Ack.B6 == 0) 
5C74:  BTFSC  x31.5
5C76:  BRA    5CA6
....................       { 
....................          if(FlashingFlag == 0) 
5C78:  BTFSC  1A.1
5C7A:  BRA    5C80
....................             { 
....................                Output.B6 = 0;           //Flash output1 
5C7C:  BCF    x19.5
....................             } 
5C7E:  BRA    5C82
....................             else 
....................             { 
....................                Output.B6 = 1; 
5C80:  BSF    x19.5
....................             } 
....................          if (~AutoTestFlag) 
5C82:  BTFSC  1A.4
5C84:  BRA    5CA6
....................          { 
....................             if(AlarmIndicator.B6 == 1){ 
5C86:  BTFSS  x2D.5
5C88:  BRA    5CA6
....................                 if(OutputBoth.B6 == 0)        //Both output 
5C8A:  BTFSC  x29.5
5C8C:  BRA    5C98
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5C8E:  BSF    F89.4
5C90:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5C92:  BSF    F89.3
5C94:  BCF    F92.3
....................                 } 
5C96:  BRA    5CA6
....................                 else 
....................                 { 
....................                   if(OutputType.B6 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
5C98:  BTFSS  x25.5
5C9A:  BRA    5CA2
5C9C:  BSF    F89.4
5C9E:  BCF    F92.4
5CA0:  BRA    5CA6
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
5CA2:  BSF    F89.3
5CA4:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
5CA6:  MOVLW  01
5CA8:  MOVWF  xE4
....................    } 
5CAA:  BRA    5D58
....................    else if(FaultType.B6 == 0) 
5CAC:  MOVLB  1
5CAE:  BTFSC  x21.5
5CB0:  BRA    5D58
....................    { 
....................       In2.B6 = 0x00; 
5CB2:  BCF    x39.5
....................       Ack.B6 = 0; 
5CB4:  BCF    x31.5
....................       Output.B6 = 1;      //Off LED 
5CB6:  BSF    x19.5
....................  
....................       if((OutputType.B6 == 1 || OutputBoth.B6 == 0)&& inputflag ==0)      //If Buzzer or Both 
5CB8:  BTFSC  x25.5
5CBA:  BRA    5CC0
5CBC:  BTFSC  x29.5
5CBE:  BRA    5CDA
5CC0:  MOVF   xE4,F
5CC2:  BNZ   5CDA
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
5CC4:  MOVLW  01
5CC6:  MOVWF  xEF
5CC8:  MOVLB  0
5CCA:  CALL   40E6
5CCE:  DECFSZ 01,W
5CD0:  BRA    5CD4
5CD2:  BRA    5CD8
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5CD4:  BCF    F89.4
5CD6:  BCF    F92.4
5CD8:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B6 == 0 || OutputBoth.B6 == 0)&& inputflag ==0)  //If Bell or Both 
5CDA:  BTFSS  x25.5
5CDC:  BRA    5CE2
5CDE:  BTFSC  x29.5
5CE0:  BRA    5D00
5CE2:  MOVF   xE4,F
5CE4:  BNZ   5D00
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5CE6:  MOVLW  02
5CE8:  MOVWF  xEF
5CEA:  MOVLB  0
5CEC:  CALL   40E6
5CF0:  DECFSZ 01,W
5CF2:  BRA    5CF6
5CF4:  BRA    5CFE
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
5CF6:  BCF    F89.3
5CF8:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5CFA:  BCF    F89.4
5CFC:  BCF    F92.4
5CFE:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
5D00:  BTFSC  x39.0
5D02:  BRA    5D58
5D04:  BTFSC  x39.1
5D06:  BRA    5D58
5D08:  BTFSC  x39.2
5D0A:  BRA    5D58
5D0C:  BTFSC  x39.3
5D0E:  BRA    5D58
5D10:  BTFSC  x39.4
5D12:  BRA    5D58
5D14:  BTFSC  x39.5
5D16:  BRA    5D58
5D18:  BTFSC  x39.6
5D1A:  BRA    5D58
5D1C:  BTFSC  x39.7
5D1E:  BRA    5D58
5D20:  BTFSC  x3A.0
5D22:  BRA    5D58
5D24:  BTFSC  x3A.1
5D26:  BRA    5D58
5D28:  BTFSC  x3A.2
5D2A:  BRA    5D58
5D2C:  BTFSC  x3A.3
5D2E:  BRA    5D58
5D30:  BTFSC  x3A.4
5D32:  BRA    5D58
5D34:  BTFSC  x3A.5
5D36:  BRA    5D58
5D38:  BTFSC  x3A.6
5D3A:  BRA    5D58
5D3C:  BTFSC  x3A.7
5D3E:  BRA    5D58
5D40:  BTFSC  x3B.0
5D42:  BRA    5D58
5D44:  BTFSC  x3B.1
5D46:  BRA    5D58
5D48:  BTFSC  x3B.2
5D4A:  BRA    5D58
5D4C:  BTFSC  x3B.3
5D4E:  BRA    5D58
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
5D50:  BCF    F89.3
5D52:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5D54:  BCF    F89.4
5D56:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input7 
....................    if((((Inputt.B7 ^ InputType.B7) == 1) && (FaultType.B7 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
5D58:  MOVLW  00
5D5A:  BTFSC  x15.6
5D5C:  MOVLW  01
5D5E:  MOVLB  2
5D60:  MOVWF  x01
5D62:  MOVLW  00
5D64:  MOVLB  1
5D66:  BTFSC  x1D.6
5D68:  MOVLW  01
5D6A:  MOVLB  2
5D6C:  XORWF  x01,W
5D6E:  SUBLW  01
5D70:  BNZ   5D7A
5D72:  MOVLB  1
5D74:  BTFSS  x21.6
5D76:  BRA    5D80
5D78:  MOVLB  2
5D7A:  BTFSS  1A.5
5D7C:  BRA    5DD0
5D7E:  MOVLB  1
....................    { 
....................       if(In2.B7 == 0 && AutoAck == 0x0F && Ack.B7 == 0)   //use auto acknowlegde 
5D80:  BTFSC  x39.6
5D82:  BRA    5D96
5D84:  MOVF   60,W
5D86:  SUBLW  0F
5D88:  BNZ   5D96
5D8A:  BTFSC  x31.6
5D8C:  BRA    5D96
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
5D8E:  MOVLW  64
5D90:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
5D92:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B7 = 1; 
5D96:  BSF    x39.6
....................       if(Ack.B7 == 0) 
5D98:  BTFSC  x31.6
5D9A:  BRA    5DCA
....................       { 
....................          if(FlashingFlag == 0) 
5D9C:  BTFSC  1A.1
5D9E:  BRA    5DA4
....................             { 
....................                Output.B7 = 0;           //Flash output1 
5DA0:  BCF    x19.6
....................             } 
5DA2:  BRA    5DA6
....................             else 
....................             { 
....................                Output.B7 = 1; 
5DA4:  BSF    x19.6
....................             } 
....................          if (~AutoTestFlag) 
5DA6:  BTFSC  1A.4
5DA8:  BRA    5DCA
....................          { 
....................             if(AlarmIndicator.B7 == 1){ 
5DAA:  BTFSS  x2D.6
5DAC:  BRA    5DCA
....................                 if(OutputBoth.B7 == 0)        //Both output 
5DAE:  BTFSC  x29.6
5DB0:  BRA    5DBC
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5DB2:  BSF    F89.4
5DB4:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5DB6:  BSF    F89.3
5DB8:  BCF    F92.3
....................                 } 
5DBA:  BRA    5DCA
....................                 else 
....................                 { 
....................                   if(OutputType.B7 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
5DBC:  BTFSS  x25.6
5DBE:  BRA    5DC6
5DC0:  BSF    F89.4
5DC2:  BCF    F92.4
5DC4:  BRA    5DCA
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
5DC6:  BSF    F89.3
5DC8:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
5DCA:  MOVLW  01
5DCC:  MOVWF  xE4
....................    } 
5DCE:  BRA    5E7C
....................    else if(FaultType.B7 == 0) 
5DD0:  MOVLB  1
5DD2:  BTFSC  x21.6
5DD4:  BRA    5E7C
....................    { 
....................       In2.B7 = 0x00; 
5DD6:  BCF    x39.6
....................       Ack.B7 = 0; 
5DD8:  BCF    x31.6
....................       Output.B7 = 1;      //Off LED 
5DDA:  BSF    x19.6
....................  
....................       if((OutputType.B7 == 1 || OutputBoth.B7 == 0)&& inputflag ==0)      //If Buzzer or Both 
5DDC:  BTFSC  x25.6
5DDE:  BRA    5DE4
5DE0:  BTFSC  x29.6
5DE2:  BRA    5DFE
5DE4:  MOVF   xE4,F
5DE6:  BNZ   5DFE
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
5DE8:  MOVLW  01
5DEA:  MOVWF  xEF
5DEC:  MOVLB  0
5DEE:  CALL   40E6
5DF2:  DECFSZ 01,W
5DF4:  BRA    5DF8
5DF6:  BRA    5DFC
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5DF8:  BCF    F89.4
5DFA:  BCF    F92.4
5DFC:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B7 == 0 || OutputBoth.B7 == 0)&& inputflag ==0)  //If Bell or Both 
5DFE:  BTFSS  x25.6
5E00:  BRA    5E06
5E02:  BTFSC  x29.6
5E04:  BRA    5E24
5E06:  MOVF   xE4,F
5E08:  BNZ   5E24
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5E0A:  MOVLW  02
5E0C:  MOVWF  xEF
5E0E:  MOVLB  0
5E10:  CALL   40E6
5E14:  DECFSZ 01,W
5E16:  BRA    5E1A
5E18:  BRA    5E22
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
5E1A:  BCF    F89.3
5E1C:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5E1E:  BCF    F89.4
5E20:  BCF    F92.4
5E22:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
5E24:  BTFSC  x39.0
5E26:  BRA    5E7C
5E28:  BTFSC  x39.1
5E2A:  BRA    5E7C
5E2C:  BTFSC  x39.2
5E2E:  BRA    5E7C
5E30:  BTFSC  x39.3
5E32:  BRA    5E7C
5E34:  BTFSC  x39.4
5E36:  BRA    5E7C
5E38:  BTFSC  x39.5
5E3A:  BRA    5E7C
5E3C:  BTFSC  x39.6
5E3E:  BRA    5E7C
5E40:  BTFSC  x39.7
5E42:  BRA    5E7C
5E44:  BTFSC  x3A.0
5E46:  BRA    5E7C
5E48:  BTFSC  x3A.1
5E4A:  BRA    5E7C
5E4C:  BTFSC  x3A.2
5E4E:  BRA    5E7C
5E50:  BTFSC  x3A.3
5E52:  BRA    5E7C
5E54:  BTFSC  x3A.4
5E56:  BRA    5E7C
5E58:  BTFSC  x3A.5
5E5A:  BRA    5E7C
5E5C:  BTFSC  x3A.6
5E5E:  BRA    5E7C
5E60:  BTFSC  x3A.7
5E62:  BRA    5E7C
5E64:  BTFSC  x3B.0
5E66:  BRA    5E7C
5E68:  BTFSC  x3B.1
5E6A:  BRA    5E7C
5E6C:  BTFSC  x3B.2
5E6E:  BRA    5E7C
5E70:  BTFSC  x3B.3
5E72:  BRA    5E7C
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
5E74:  BCF    F89.3
5E76:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5E78:  BCF    F89.4
5E7A:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input8 
....................    if((((Inputt.B8 ^ InputType.B8) == 1) && (FaultType.B8 == 0)) ||Test_fault==1)   // alarm1 occure and " Non Lock type" 
5E7C:  MOVLW  00
5E7E:  BTFSC  x15.7
5E80:  MOVLW  01
5E82:  MOVLB  2
5E84:  MOVWF  x01
5E86:  MOVLW  00
5E88:  MOVLB  1
5E8A:  BTFSC  x1D.7
5E8C:  MOVLW  01
5E8E:  MOVLB  2
5E90:  XORWF  x01,W
5E92:  SUBLW  01
5E94:  BNZ   5E9E
5E96:  MOVLB  1
5E98:  BTFSS  x21.7
5E9A:  BRA    5EA4
5E9C:  MOVLB  2
5E9E:  BTFSS  1A.5
5EA0:  BRA    5EF4
5EA2:  MOVLB  1
....................    { 
....................       if(In2.B8 == 0 && AutoAck == 0x0F && Ack.B8 == 0)   //use auto acknowlegde 
5EA4:  BTFSC  x39.7
5EA6:  BRA    5EBA
5EA8:  MOVF   60,W
5EAA:  SUBLW  0F
5EAC:  BNZ   5EBA
5EAE:  BTFSC  x31.7
5EB0:  BRA    5EBA
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
5EB2:  MOVLW  64
5EB4:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
5EB6:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B8 = 1; 
5EBA:  BSF    x39.7
....................       if(Ack.B8 == 0) 
5EBC:  BTFSC  x31.7
5EBE:  BRA    5EEE
....................       { 
....................          if(FlashingFlag == 0) 
5EC0:  BTFSC  1A.1
5EC2:  BRA    5EC8
....................             { 
....................                Output.B8 = 0;           //Flash output1 
5EC4:  BCF    x19.7
....................             } 
5EC6:  BRA    5ECA
....................             else 
....................             { 
....................                Output.B8 = 1; 
5EC8:  BSF    x19.7
....................             } 
....................          if (~AutoTestFlag) 
5ECA:  BTFSC  1A.4
5ECC:  BRA    5EEE
....................          { 
....................             if(AlarmIndicator.B8 == 1){ 
5ECE:  BTFSS  x2D.7
5ED0:  BRA    5EEE
....................                 if(OutputBoth.B8 == 0)        //Both output 
5ED2:  BTFSC  x29.7
5ED4:  BRA    5EE0
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5ED6:  BSF    F89.4
5ED8:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5EDA:  BSF    F89.3
5EDC:  BCF    F92.3
....................                 } 
5EDE:  BRA    5EEE
....................                 else 
....................                 { 
....................                   if(OutputType.B8 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
5EE0:  BTFSS  x25.7
5EE2:  BRA    5EEA
5EE4:  BSF    F89.4
5EE6:  BCF    F92.4
5EE8:  BRA    5EEE
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
5EEA:  BSF    F89.3
5EEC:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
5EEE:  MOVLW  01
5EF0:  MOVWF  xE4
....................    } 
5EF2:  BRA    5FA0
....................    else if(FaultType.B8 == 0) 
5EF4:  MOVLB  1
5EF6:  BTFSC  x21.7
5EF8:  BRA    5FA0
....................    { 
....................       In2.B8 = 0x00; 
5EFA:  BCF    x39.7
....................       Ack.B8 = 0; 
5EFC:  BCF    x31.7
....................       Output.B8 = 1;      //Off LED 
5EFE:  BSF    x19.7
....................  
....................       if((OutputType.B8 == 1 || OutputBoth.B8 == 0)&& inputflag ==0)      //If Buzzer or Both 
5F00:  BTFSC  x25.7
5F02:  BRA    5F08
5F04:  BTFSC  x29.7
5F06:  BRA    5F22
5F08:  MOVF   xE4,F
5F0A:  BNZ   5F22
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
5F0C:  MOVLW  01
5F0E:  MOVWF  xEF
5F10:  MOVLB  0
5F12:  CALL   40E6
5F16:  DECFSZ 01,W
5F18:  BRA    5F1C
5F1A:  BRA    5F20
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5F1C:  BCF    F89.4
5F1E:  BCF    F92.4
5F20:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B8 == 0 || OutputBoth.B8 == 0)&& inputflag ==0)  //If Bell or Both 
5F22:  BTFSS  x25.7
5F24:  BRA    5F2A
5F26:  BTFSC  x29.7
5F28:  BRA    5F48
5F2A:  MOVF   xE4,F
5F2C:  BNZ   5F48
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5F2E:  MOVLW  02
5F30:  MOVWF  xEF
5F32:  MOVLB  0
5F34:  CALL   40E6
5F38:  DECFSZ 01,W
5F3A:  BRA    5F3E
5F3C:  BRA    5F46
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
5F3E:  BCF    F89.3
5F40:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5F42:  BCF    F89.4
5F44:  BCF    F92.4
5F46:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
5F48:  BTFSC  x39.0
5F4A:  BRA    5FA0
5F4C:  BTFSC  x39.1
5F4E:  BRA    5FA0
5F50:  BTFSC  x39.2
5F52:  BRA    5FA0
5F54:  BTFSC  x39.3
5F56:  BRA    5FA0
5F58:  BTFSC  x39.4
5F5A:  BRA    5FA0
5F5C:  BTFSC  x39.5
5F5E:  BRA    5FA0
5F60:  BTFSC  x39.6
5F62:  BRA    5FA0
5F64:  BTFSC  x39.7
5F66:  BRA    5FA0
5F68:  BTFSC  x3A.0
5F6A:  BRA    5FA0
5F6C:  BTFSC  x3A.1
5F6E:  BRA    5FA0
5F70:  BTFSC  x3A.2
5F72:  BRA    5FA0
5F74:  BTFSC  x3A.3
5F76:  BRA    5FA0
5F78:  BTFSC  x3A.4
5F7A:  BRA    5FA0
5F7C:  BTFSC  x3A.5
5F7E:  BRA    5FA0
5F80:  BTFSC  x3A.6
5F82:  BRA    5FA0
5F84:  BTFSC  x3A.7
5F86:  BRA    5FA0
5F88:  BTFSC  x3B.0
5F8A:  BRA    5FA0
5F8C:  BTFSC  x3B.1
5F8E:  BRA    5FA0
5F90:  BTFSC  x3B.2
5F92:  BRA    5FA0
5F94:  BTFSC  x3B.3
5F96:  BRA    5FA0
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
5F98:  BCF    F89.3
5F9A:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
5F9C:  BCF    F89.4
5F9E:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input9 
....................    if((((Inputt.B9 ^ InputType.B9) == 1) && (FaultType.B9 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
5FA0:  MOVLW  00
5FA2:  BTFSC  x16.0
5FA4:  MOVLW  01
5FA6:  MOVLB  2
5FA8:  MOVWF  x01
5FAA:  MOVLW  00
5FAC:  MOVLB  1
5FAE:  BTFSC  x1E.0
5FB0:  MOVLW  01
5FB2:  MOVLB  2
5FB4:  XORWF  x01,W
5FB6:  SUBLW  01
5FB8:  BNZ   5FC2
5FBA:  MOVLB  1
5FBC:  BTFSS  x22.0
5FBE:  BRA    5FC8
5FC0:  MOVLB  2
5FC2:  BTFSS  1A.5
5FC4:  BRA    6018
5FC6:  MOVLB  1
....................    { 
....................       if(In2.B9 == 0 && AutoAck == 0x0F && Ack.B9 == 0)   //use auto acknowlegde 
5FC8:  BTFSC  x3A.0
5FCA:  BRA    5FDE
5FCC:  MOVF   60,W
5FCE:  SUBLW  0F
5FD0:  BNZ   5FDE
5FD2:  BTFSC  x32.0
5FD4:  BRA    5FDE
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
5FD6:  MOVLW  64
5FD8:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
5FDA:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B9 = 1; 
5FDE:  BSF    x3A.0
....................       if(Ack.B9 == 0) 
5FE0:  BTFSC  x32.0
5FE2:  BRA    6012
....................       { 
....................          if(FlashingFlag == 0) 
5FE4:  BTFSC  1A.1
5FE6:  BRA    5FEC
....................             { 
....................                Output.B9 = 0;           //Flash output1 
5FE8:  BCF    x1A.0
....................             } 
5FEA:  BRA    5FEE
....................             else 
....................             { 
....................                Output.B9 = 1; 
5FEC:  BSF    x1A.0
....................             } 
....................          if (~AutoTestFlag) 
5FEE:  BTFSC  1A.4
5FF0:  BRA    6012
....................          { 
....................             if(AlarmIndicator.B9 == 1){ 
5FF2:  BTFSS  x2E.0
5FF4:  BRA    6012
....................                 if(OutputBoth.B9 == 0)        //Both output 
5FF6:  BTFSC  x2A.0
5FF8:  BRA    6004
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
5FFA:  BSF    F89.4
5FFC:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
5FFE:  BSF    F89.3
6000:  BCF    F92.3
....................                 } 
6002:  BRA    6012
....................                 else 
....................                 { 
....................                   if(OutputType.B9 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
6004:  BTFSS  x26.0
6006:  BRA    600E
6008:  BSF    F89.4
600A:  BCF    F92.4
600C:  BRA    6012
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
600E:  BSF    F89.3
6010:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
6012:  MOVLW  01
6014:  MOVWF  xE4
....................    } 
6016:  BRA    60C4
....................    else if(FaultType.B9 == 0) 
6018:  MOVLB  1
601A:  BTFSC  x22.0
601C:  BRA    60C4
....................    { 
....................       In2.B9 = 0x00; 
601E:  BCF    x3A.0
....................       Ack.B9 = 0; 
6020:  BCF    x32.0
....................       Output.B9 = 1;      //Off LED 
6022:  BSF    x1A.0
....................  
....................       if((OutputType.B9 == 1 || OutputBoth.B9 == 0)&& inputflag ==0)      //If Buzzer or Both 
6024:  BTFSC  x26.0
6026:  BRA    602C
6028:  BTFSC  x2A.0
602A:  BRA    6046
602C:  MOVF   xE4,F
602E:  BNZ   6046
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
6030:  MOVLW  01
6032:  MOVWF  xEF
6034:  MOVLB  0
6036:  CALL   40E6
603A:  DECFSZ 01,W
603C:  BRA    6040
603E:  BRA    6044
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6040:  BCF    F89.4
6042:  BCF    F92.4
6044:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B9 == 0 || OutputBoth.B9 == 0)&& inputflag ==0)  //If Bell or Both 
6046:  BTFSS  x26.0
6048:  BRA    604E
604A:  BTFSC  x2A.0
604C:  BRA    606C
604E:  MOVF   xE4,F
6050:  BNZ   606C
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
6052:  MOVLW  02
6054:  MOVWF  xEF
6056:  MOVLB  0
6058:  CALL   40E6
605C:  DECFSZ 01,W
605E:  BRA    6062
6060:  BRA    606A
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
6062:  BCF    F89.3
6064:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6066:  BCF    F89.4
6068:  BCF    F92.4
606A:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
606C:  BTFSC  x39.0
606E:  BRA    60C4
6070:  BTFSC  x39.1
6072:  BRA    60C4
6074:  BTFSC  x39.2
6076:  BRA    60C4
6078:  BTFSC  x39.3
607A:  BRA    60C4
607C:  BTFSC  x39.4
607E:  BRA    60C4
6080:  BTFSC  x39.5
6082:  BRA    60C4
6084:  BTFSC  x39.6
6086:  BRA    60C4
6088:  BTFSC  x39.7
608A:  BRA    60C4
608C:  BTFSC  x3A.0
608E:  BRA    60C4
6090:  BTFSC  x3A.1
6092:  BRA    60C4
6094:  BTFSC  x3A.2
6096:  BRA    60C4
6098:  BTFSC  x3A.3
609A:  BRA    60C4
609C:  BTFSC  x3A.4
609E:  BRA    60C4
60A0:  BTFSC  x3A.5
60A2:  BRA    60C4
60A4:  BTFSC  x3A.6
60A6:  BRA    60C4
60A8:  BTFSC  x3A.7
60AA:  BRA    60C4
60AC:  BTFSC  x3B.0
60AE:  BRA    60C4
60B0:  BTFSC  x3B.1
60B2:  BRA    60C4
60B4:  BTFSC  x3B.2
60B6:  BRA    60C4
60B8:  BTFSC  x3B.3
60BA:  BRA    60C4
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
60BC:  BCF    F89.3
60BE:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
60C0:  BCF    F89.4
60C2:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input10 
....................    if((((Inputt.B10 ^ InputType.B10) == 1) && (FaultType.B10 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
60C4:  MOVLW  00
60C6:  BTFSC  x16.1
60C8:  MOVLW  01
60CA:  MOVLB  2
60CC:  MOVWF  x01
60CE:  MOVLW  00
60D0:  MOVLB  1
60D2:  BTFSC  x1E.1
60D4:  MOVLW  01
60D6:  MOVLB  2
60D8:  XORWF  x01,W
60DA:  SUBLW  01
60DC:  BNZ   60E6
60DE:  MOVLB  1
60E0:  BTFSS  x22.1
60E2:  BRA    60EC
60E4:  MOVLB  2
60E6:  BTFSS  1A.5
60E8:  BRA    613C
60EA:  MOVLB  1
....................    { 
....................       if(In2.B10 == 0 && AutoAck == 0x0F && Ack.B10 == 0)   //use auto acknowlegde 
60EC:  BTFSC  x3A.1
60EE:  BRA    6102
60F0:  MOVF   60,W
60F2:  SUBLW  0F
60F4:  BNZ   6102
60F6:  BTFSC  x32.1
60F8:  BRA    6102
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
60FA:  MOVLW  64
60FC:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
60FE:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B10 = 1; 
6102:  BSF    x3A.1
....................       if(Ack.B10 == 0) 
6104:  BTFSC  x32.1
6106:  BRA    6136
....................       { 
....................          if(FlashingFlag == 0) 
6108:  BTFSC  1A.1
610A:  BRA    6110
....................             { 
....................                Output.B10 = 0;           //Flash output1 
610C:  BCF    x1A.1
....................             } 
610E:  BRA    6112
....................             else 
....................             { 
....................                Output.B10 = 1; 
6110:  BSF    x1A.1
....................             } 
....................          if (~AutoTestFlag) 
6112:  BTFSC  1A.4
6114:  BRA    6136
....................          { 
....................             if(AlarmIndicator.B10 == 1){ 
6116:  BTFSS  x2E.1
6118:  BRA    6136
....................                 if(OutputBoth.B10 == 0)        //Both output 
611A:  BTFSC  x2A.1
611C:  BRA    6128
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
611E:  BSF    F89.4
6120:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
6122:  BSF    F89.3
6124:  BCF    F92.3
....................                 } 
6126:  BRA    6136
....................                 else 
....................                 { 
....................                   if(OutputType.B10 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
6128:  BTFSS  x26.1
612A:  BRA    6132
612C:  BSF    F89.4
612E:  BCF    F92.4
6130:  BRA    6136
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
6132:  BSF    F89.3
6134:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
6136:  MOVLW  01
6138:  MOVWF  xE4
....................    } 
613A:  BRA    61E8
....................    else if(FaultType.B10 == 0) 
613C:  MOVLB  1
613E:  BTFSC  x22.1
6140:  BRA    61E8
....................    { 
....................       In2.B10 = 0x00; 
6142:  BCF    x3A.1
....................       Ack.B10 = 0; 
6144:  BCF    x32.1
....................       Output.B10 = 1;      //Off LED 
6146:  BSF    x1A.1
....................  
....................       if((OutputType.B10 == 1 || OutputBoth.B10 == 0)&& inputflag ==0)      //If Buzzer or Both 
6148:  BTFSC  x26.1
614A:  BRA    6150
614C:  BTFSC  x2A.1
614E:  BRA    616A
6150:  MOVF   xE4,F
6152:  BNZ   616A
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
6154:  MOVLW  01
6156:  MOVWF  xEF
6158:  MOVLB  0
615A:  CALL   40E6
615E:  DECFSZ 01,W
6160:  BRA    6164
6162:  BRA    6168
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6164:  BCF    F89.4
6166:  BCF    F92.4
6168:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B10 == 0 || OutputBoth.B10 == 0)&& inputflag ==0)  //If Bell or Both 
616A:  BTFSS  x26.1
616C:  BRA    6172
616E:  BTFSC  x2A.1
6170:  BRA    6190
6172:  MOVF   xE4,F
6174:  BNZ   6190
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
6176:  MOVLW  02
6178:  MOVWF  xEF
617A:  MOVLB  0
617C:  CALL   40E6
6180:  DECFSZ 01,W
6182:  BRA    6186
6184:  BRA    618E
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
6186:  BCF    F89.3
6188:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
618A:  BCF    F89.4
618C:  BCF    F92.4
618E:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
6190:  BTFSC  x39.0
6192:  BRA    61E8
6194:  BTFSC  x39.1
6196:  BRA    61E8
6198:  BTFSC  x39.2
619A:  BRA    61E8
619C:  BTFSC  x39.3
619E:  BRA    61E8
61A0:  BTFSC  x39.4
61A2:  BRA    61E8
61A4:  BTFSC  x39.5
61A6:  BRA    61E8
61A8:  BTFSC  x39.6
61AA:  BRA    61E8
61AC:  BTFSC  x39.7
61AE:  BRA    61E8
61B0:  BTFSC  x3A.0
61B2:  BRA    61E8
61B4:  BTFSC  x3A.1
61B6:  BRA    61E8
61B8:  BTFSC  x3A.2
61BA:  BRA    61E8
61BC:  BTFSC  x3A.3
61BE:  BRA    61E8
61C0:  BTFSC  x3A.4
61C2:  BRA    61E8
61C4:  BTFSC  x3A.5
61C6:  BRA    61E8
61C8:  BTFSC  x3A.6
61CA:  BRA    61E8
61CC:  BTFSC  x3A.7
61CE:  BRA    61E8
61D0:  BTFSC  x3B.0
61D2:  BRA    61E8
61D4:  BTFSC  x3B.1
61D6:  BRA    61E8
61D8:  BTFSC  x3B.2
61DA:  BRA    61E8
61DC:  BTFSC  x3B.3
61DE:  BRA    61E8
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
61E0:  BCF    F89.3
61E2:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
61E4:  BCF    F89.4
61E6:  BCF    F92.4
....................       } 
....................    } 
....................     
.................... //} 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... //if(NoOfPoint >= 20) 
.................... //{ 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input11 
....................    if((((Inputt.B11 ^ InputType.B11) == 1) && (FaultType.B11 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
61E8:  MOVLW  00
61EA:  BTFSC  x16.2
61EC:  MOVLW  01
61EE:  MOVLB  2
61F0:  MOVWF  x01
61F2:  MOVLW  00
61F4:  MOVLB  1
61F6:  BTFSC  x1E.2
61F8:  MOVLW  01
61FA:  MOVLB  2
61FC:  XORWF  x01,W
61FE:  SUBLW  01
6200:  BNZ   620A
6202:  MOVLB  1
6204:  BTFSS  x22.2
6206:  BRA    6210
6208:  MOVLB  2
620A:  BTFSS  1A.5
620C:  BRA    6260
620E:  MOVLB  1
....................    { 
....................       if(In2.B11 == 0 && AutoAck == 0x0F && Ack.B11 == 0)   //use auto acknowlegde 
6210:  BTFSC  x3A.2
6212:  BRA    6226
6214:  MOVF   60,W
6216:  SUBLW  0F
6218:  BNZ   6226
621A:  BTFSC  x32.2
621C:  BRA    6226
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
621E:  MOVLW  64
6220:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
6222:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B11 = 1; 
6226:  BSF    x3A.2
....................       if(Ack.B11 == 0) 
6228:  BTFSC  x32.2
622A:  BRA    625A
....................       { 
....................          if(FlashingFlag == 0) 
622C:  BTFSC  1A.1
622E:  BRA    6234
....................             { 
....................                Output.B11 = 0;           //Flash output1 
6230:  BCF    x1A.2
....................             } 
6232:  BRA    6236
....................             else 
....................             { 
....................                Output.B11 = 1; 
6234:  BSF    x1A.2
....................             } 
....................          if (~AutoTestFlag) 
6236:  BTFSC  1A.4
6238:  BRA    625A
....................          { 
....................             if(AlarmIndicator.B11 == 1){ 
623A:  BTFSS  x2E.2
623C:  BRA    625A
....................                 if(OutputBoth.B11 == 0)        //Both output 
623E:  BTFSC  x2A.2
6240:  BRA    624C
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
6242:  BSF    F89.4
6244:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
6246:  BSF    F89.3
6248:  BCF    F92.3
....................                 } 
624A:  BRA    625A
....................                 else 
....................                 { 
....................                   if(OutputType.B11 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
624C:  BTFSS  x26.2
624E:  BRA    6256
6250:  BSF    F89.4
6252:  BCF    F92.4
6254:  BRA    625A
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
6256:  BSF    F89.3
6258:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
625A:  MOVLW  01
625C:  MOVWF  xE4
....................    } 
625E:  BRA    630C
....................    else if(FaultType.B11 == 0) 
6260:  MOVLB  1
6262:  BTFSC  x22.2
6264:  BRA    630C
....................    { 
....................       In2.B11 = 0x00; 
6266:  BCF    x3A.2
....................       Ack.B11 = 0; 
6268:  BCF    x32.2
....................       Output.B11 = 1;      //Off LED 
626A:  BSF    x1A.2
....................  
....................       if((OutputType.B11 == 1 || OutputBoth.B11 == 0)&& inputflag ==0)      //If Buzzer or Both 
626C:  BTFSC  x26.2
626E:  BRA    6274
6270:  BTFSC  x2A.2
6272:  BRA    628E
6274:  MOVF   xE4,F
6276:  BNZ   628E
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
6278:  MOVLW  01
627A:  MOVWF  xEF
627C:  MOVLB  0
627E:  CALL   40E6
6282:  DECFSZ 01,W
6284:  BRA    6288
6286:  BRA    628C
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6288:  BCF    F89.4
628A:  BCF    F92.4
628C:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B11 == 0 || OutputBoth.B11 == 0)&& inputflag ==0)  //If Bell or Both 
628E:  BTFSS  x26.2
6290:  BRA    6296
6292:  BTFSC  x2A.2
6294:  BRA    62B4
6296:  MOVF   xE4,F
6298:  BNZ   62B4
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
629A:  MOVLW  02
629C:  MOVWF  xEF
629E:  MOVLB  0
62A0:  CALL   40E6
62A4:  DECFSZ 01,W
62A6:  BRA    62AA
62A8:  BRA    62B2
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
62AA:  BCF    F89.3
62AC:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
62AE:  BCF    F89.4
62B0:  BCF    F92.4
62B2:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
62B4:  BTFSC  x39.0
62B6:  BRA    630C
62B8:  BTFSC  x39.1
62BA:  BRA    630C
62BC:  BTFSC  x39.2
62BE:  BRA    630C
62C0:  BTFSC  x39.3
62C2:  BRA    630C
62C4:  BTFSC  x39.4
62C6:  BRA    630C
62C8:  BTFSC  x39.5
62CA:  BRA    630C
62CC:  BTFSC  x39.6
62CE:  BRA    630C
62D0:  BTFSC  x39.7
62D2:  BRA    630C
62D4:  BTFSC  x3A.0
62D6:  BRA    630C
62D8:  BTFSC  x3A.1
62DA:  BRA    630C
62DC:  BTFSC  x3A.2
62DE:  BRA    630C
62E0:  BTFSC  x3A.3
62E2:  BRA    630C
62E4:  BTFSC  x3A.4
62E6:  BRA    630C
62E8:  BTFSC  x3A.5
62EA:  BRA    630C
62EC:  BTFSC  x3A.6
62EE:  BRA    630C
62F0:  BTFSC  x3A.7
62F2:  BRA    630C
62F4:  BTFSC  x3B.0
62F6:  BRA    630C
62F8:  BTFSC  x3B.1
62FA:  BRA    630C
62FC:  BTFSC  x3B.2
62FE:  BRA    630C
6300:  BTFSC  x3B.3
6302:  BRA    630C
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
6304:  BCF    F89.3
6306:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6308:  BCF    F89.4
630A:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input12 
....................    if((((Inputt.B12 ^ InputType.B12) == 1) && (FaultType.B12 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
630C:  MOVLW  00
630E:  BTFSC  x16.3
6310:  MOVLW  01
6312:  MOVLB  2
6314:  MOVWF  x01
6316:  MOVLW  00
6318:  MOVLB  1
631A:  BTFSC  x1E.3
631C:  MOVLW  01
631E:  MOVLB  2
6320:  XORWF  x01,W
6322:  SUBLW  01
6324:  BNZ   632E
6326:  MOVLB  1
6328:  BTFSS  x22.3
632A:  BRA    6334
632C:  MOVLB  2
632E:  BTFSS  1A.5
6330:  BRA    6384
6332:  MOVLB  1
....................    { 
....................       if(In2.B12 == 0 && AutoAck == 0x0F && Ack.B12 == 0)   //use auto acknowlegde 
6334:  BTFSC  x3A.3
6336:  BRA    634A
6338:  MOVF   60,W
633A:  SUBLW  0F
633C:  BNZ   634A
633E:  BTFSC  x32.3
6340:  BRA    634A
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
6342:  MOVLW  64
6344:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
6346:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B12 = 1; 
634A:  BSF    x3A.3
....................       if(Ack.B12 == 0) 
634C:  BTFSC  x32.3
634E:  BRA    637E
....................       { 
....................          if(FlashingFlag == 0) 
6350:  BTFSC  1A.1
6352:  BRA    6358
....................             { 
....................                Output.B12 = 0;           //Flash output1 
6354:  BCF    x1A.3
....................             } 
6356:  BRA    635A
....................             else 
....................             { 
....................                Output.B12 = 1; 
6358:  BSF    x1A.3
....................             } 
....................          if (~AutoTestFlag) 
635A:  BTFSC  1A.4
635C:  BRA    637E
....................          { 
....................             if(AlarmIndicator.B12 == 1){ 
635E:  BTFSS  x2E.3
6360:  BRA    637E
....................                 if(OutputBoth.B12 == 0)        //Both output 
6362:  BTFSC  x2A.3
6364:  BRA    6370
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
6366:  BSF    F89.4
6368:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
636A:  BSF    F89.3
636C:  BCF    F92.3
....................                 } 
636E:  BRA    637E
....................                 else 
....................                 { 
....................                   if(OutputType.B12 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
6370:  BTFSS  x26.3
6372:  BRA    637A
6374:  BSF    F89.4
6376:  BCF    F92.4
6378:  BRA    637E
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
637A:  BSF    F89.3
637C:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
637E:  MOVLW  01
6380:  MOVWF  xE4
....................    } 
6382:  BRA    6430
....................    else if(FaultType.B12 == 0) 
6384:  MOVLB  1
6386:  BTFSC  x22.3
6388:  BRA    6430
....................    { 
....................       In2.B12 = 0x00; 
638A:  BCF    x3A.3
....................       Ack.B12 = 0; 
638C:  BCF    x32.3
....................       Output.B12 = 1;      //Off LED 
638E:  BSF    x1A.3
....................  
....................       if((OutputType.B12 == 1 || OutputBoth.B12 == 0)&& inputflag ==0)      //If Buzzer or Both 
6390:  BTFSC  x26.3
6392:  BRA    6398
6394:  BTFSC  x2A.3
6396:  BRA    63B2
6398:  MOVF   xE4,F
639A:  BNZ   63B2
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
639C:  MOVLW  01
639E:  MOVWF  xEF
63A0:  MOVLB  0
63A2:  CALL   40E6
63A6:  DECFSZ 01,W
63A8:  BRA    63AC
63AA:  BRA    63B0
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
63AC:  BCF    F89.4
63AE:  BCF    F92.4
63B0:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B12 == 0 || OutputBoth.B12 == 0)&& inputflag ==0)  //If Bell or Both 
63B2:  BTFSS  x26.3
63B4:  BRA    63BA
63B6:  BTFSC  x2A.3
63B8:  BRA    63D8
63BA:  MOVF   xE4,F
63BC:  BNZ   63D8
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
63BE:  MOVLW  02
63C0:  MOVWF  xEF
63C2:  MOVLB  0
63C4:  CALL   40E6
63C8:  DECFSZ 01,W
63CA:  BRA    63CE
63CC:  BRA    63D6
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
63CE:  BCF    F89.3
63D0:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
63D2:  BCF    F89.4
63D4:  BCF    F92.4
63D6:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
63D8:  BTFSC  x39.0
63DA:  BRA    6430
63DC:  BTFSC  x39.1
63DE:  BRA    6430
63E0:  BTFSC  x39.2
63E2:  BRA    6430
63E4:  BTFSC  x39.3
63E6:  BRA    6430
63E8:  BTFSC  x39.4
63EA:  BRA    6430
63EC:  BTFSC  x39.5
63EE:  BRA    6430
63F0:  BTFSC  x39.6
63F2:  BRA    6430
63F4:  BTFSC  x39.7
63F6:  BRA    6430
63F8:  BTFSC  x3A.0
63FA:  BRA    6430
63FC:  BTFSC  x3A.1
63FE:  BRA    6430
6400:  BTFSC  x3A.2
6402:  BRA    6430
6404:  BTFSC  x3A.3
6406:  BRA    6430
6408:  BTFSC  x3A.4
640A:  BRA    6430
640C:  BTFSC  x3A.5
640E:  BRA    6430
6410:  BTFSC  x3A.6
6412:  BRA    6430
6414:  BTFSC  x3A.7
6416:  BRA    6430
6418:  BTFSC  x3B.0
641A:  BRA    6430
641C:  BTFSC  x3B.1
641E:  BRA    6430
6420:  BTFSC  x3B.2
6422:  BRA    6430
6424:  BTFSC  x3B.3
6426:  BRA    6430
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
6428:  BCF    F89.3
642A:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
642C:  BCF    F89.4
642E:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input13 
....................    if((((Inputt.B13 ^ InputType.B13) == 1) && (FaultType.B13 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
6430:  MOVLW  00
6432:  BTFSC  x16.4
6434:  MOVLW  01
6436:  MOVLB  2
6438:  MOVWF  x01
643A:  MOVLW  00
643C:  MOVLB  1
643E:  BTFSC  x1E.4
6440:  MOVLW  01
6442:  MOVLB  2
6444:  XORWF  x01,W
6446:  SUBLW  01
6448:  BNZ   6452
644A:  MOVLB  1
644C:  BTFSS  x22.4
644E:  BRA    6458
6450:  MOVLB  2
6452:  BTFSS  1A.5
6454:  BRA    64A8
6456:  MOVLB  1
....................    { 
....................       if(In2.B13 == 0 && AutoAck == 0x0F && Ack.B13 == 0)   //use auto acknowlegde 
6458:  BTFSC  x3A.4
645A:  BRA    646E
645C:  MOVF   60,W
645E:  SUBLW  0F
6460:  BNZ   646E
6462:  BTFSC  x32.4
6464:  BRA    646E
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
6466:  MOVLW  64
6468:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
646A:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B13 = 1; 
646E:  BSF    x3A.4
....................       if(Ack.B13 == 0) 
6470:  BTFSC  x32.4
6472:  BRA    64A2
....................       { 
....................          if(FlashingFlag == 0) 
6474:  BTFSC  1A.1
6476:  BRA    647C
....................             { 
....................                Output.B13 = 0;           //Flash output1 
6478:  BCF    x1A.4
....................             } 
647A:  BRA    647E
....................             else 
....................             { 
....................                Output.B13 = 1; 
647C:  BSF    x1A.4
....................             } 
....................          if (~AutoTestFlag) 
647E:  BTFSC  1A.4
6480:  BRA    64A2
....................          { 
....................             if(AlarmIndicator.B13 == 1){ 
6482:  BTFSS  x2E.4
6484:  BRA    64A2
....................                 if(OutputBoth.B13 == 0)        //Both output 
6486:  BTFSC  x2A.4
6488:  BRA    6494
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
648A:  BSF    F89.4
648C:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
648E:  BSF    F89.3
6490:  BCF    F92.3
....................                 } 
6492:  BRA    64A2
....................                 else 
....................                 { 
....................                   if(OutputType.B13 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
6494:  BTFSS  x26.4
6496:  BRA    649E
6498:  BSF    F89.4
649A:  BCF    F92.4
649C:  BRA    64A2
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
649E:  BSF    F89.3
64A0:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
64A2:  MOVLW  01
64A4:  MOVWF  xE4
....................    } 
64A6:  BRA    6554
....................    else if(FaultType.B13 == 0) 
64A8:  MOVLB  1
64AA:  BTFSC  x22.4
64AC:  BRA    6554
....................    { 
....................       In2.B13 = 0x00; 
64AE:  BCF    x3A.4
....................       Ack.B13 = 0; 
64B0:  BCF    x32.4
....................       Output.B13 = 1;      //Off LED 
64B2:  BSF    x1A.4
....................  
....................       if((OutputType.B13 == 1 || OutputBoth.B13 == 0)&& inputflag ==0)      //If Buzzer or Both 
64B4:  BTFSC  x26.4
64B6:  BRA    64BC
64B8:  BTFSC  x2A.4
64BA:  BRA    64D6
64BC:  MOVF   xE4,F
64BE:  BNZ   64D6
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
64C0:  MOVLW  01
64C2:  MOVWF  xEF
64C4:  MOVLB  0
64C6:  CALL   40E6
64CA:  DECFSZ 01,W
64CC:  BRA    64D0
64CE:  BRA    64D4
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
64D0:  BCF    F89.4
64D2:  BCF    F92.4
64D4:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B13 == 0 || OutputBoth.B13 == 0)&& inputflag ==0)  //If Bell or Both 
64D6:  BTFSS  x26.4
64D8:  BRA    64DE
64DA:  BTFSC  x2A.4
64DC:  BRA    64FC
64DE:  MOVF   xE4,F
64E0:  BNZ   64FC
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
64E2:  MOVLW  02
64E4:  MOVWF  xEF
64E6:  MOVLB  0
64E8:  CALL   40E6
64EC:  DECFSZ 01,W
64EE:  BRA    64F2
64F0:  BRA    64FA
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
64F2:  BCF    F89.3
64F4:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
64F6:  BCF    F89.4
64F8:  BCF    F92.4
64FA:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
64FC:  BTFSC  x39.0
64FE:  BRA    6554
6500:  BTFSC  x39.1
6502:  BRA    6554
6504:  BTFSC  x39.2
6506:  BRA    6554
6508:  BTFSC  x39.3
650A:  BRA    6554
650C:  BTFSC  x39.4
650E:  BRA    6554
6510:  BTFSC  x39.5
6512:  BRA    6554
6514:  BTFSC  x39.6
6516:  BRA    6554
6518:  BTFSC  x39.7
651A:  BRA    6554
651C:  BTFSC  x3A.0
651E:  BRA    6554
6520:  BTFSC  x3A.1
6522:  BRA    6554
6524:  BTFSC  x3A.2
6526:  BRA    6554
6528:  BTFSC  x3A.3
652A:  BRA    6554
652C:  BTFSC  x3A.4
652E:  BRA    6554
6530:  BTFSC  x3A.5
6532:  BRA    6554
6534:  BTFSC  x3A.6
6536:  BRA    6554
6538:  BTFSC  x3A.7
653A:  BRA    6554
653C:  BTFSC  x3B.0
653E:  BRA    6554
6540:  BTFSC  x3B.1
6542:  BRA    6554
6544:  BTFSC  x3B.2
6546:  BRA    6554
6548:  BTFSC  x3B.3
654A:  BRA    6554
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
654C:  BCF    F89.3
654E:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6550:  BCF    F89.4
6552:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input14 
....................    if((((Inputt.B14 ^ InputType.B14) == 1) && (FaultType.B14 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
6554:  MOVLW  00
6556:  BTFSC  x16.5
6558:  MOVLW  01
655A:  MOVLB  2
655C:  MOVWF  x01
655E:  MOVLW  00
6560:  MOVLB  1
6562:  BTFSC  x1E.5
6564:  MOVLW  01
6566:  MOVLB  2
6568:  XORWF  x01,W
656A:  SUBLW  01
656C:  BNZ   6576
656E:  MOVLB  1
6570:  BTFSS  x22.5
6572:  BRA    657C
6574:  MOVLB  2
6576:  BTFSS  1A.5
6578:  BRA    65CC
657A:  MOVLB  1
....................    { 
....................       if(In2.B14 == 0 && AutoAck == 0x0F && Ack.B14 == 0)   //use auto acknowlegde 
657C:  BTFSC  x3A.5
657E:  BRA    6592
6580:  MOVF   60,W
6582:  SUBLW  0F
6584:  BNZ   6592
6586:  BTFSC  x32.5
6588:  BRA    6592
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
658A:  MOVLW  64
658C:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
658E:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B14 = 1; 
6592:  BSF    x3A.5
....................       if(Ack.B14 == 0) 
6594:  BTFSC  x32.5
6596:  BRA    65C6
....................       { 
....................          if(FlashingFlag == 0) 
6598:  BTFSC  1A.1
659A:  BRA    65A0
....................             { 
....................                Output.B14 = 0;           //Flash output1 
659C:  BCF    x1A.5
....................             } 
659E:  BRA    65A2
....................             else 
....................             { 
....................                Output.B14 = 1; 
65A0:  BSF    x1A.5
....................             } 
....................          if (~AutoTestFlag) 
65A2:  BTFSC  1A.4
65A4:  BRA    65C6
....................          { 
....................             if(AlarmIndicator.B14 == 1){ 
65A6:  BTFSS  x2E.5
65A8:  BRA    65C6
....................                 if(OutputBoth.B14 == 0)        //Both output 
65AA:  BTFSC  x2A.5
65AC:  BRA    65B8
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
65AE:  BSF    F89.4
65B0:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
65B2:  BSF    F89.3
65B4:  BCF    F92.3
....................                 } 
65B6:  BRA    65C6
....................                 else 
....................                 { 
....................                   if(OutputType.B14 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
65B8:  BTFSS  x26.5
65BA:  BRA    65C2
65BC:  BSF    F89.4
65BE:  BCF    F92.4
65C0:  BRA    65C6
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
65C2:  BSF    F89.3
65C4:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
65C6:  MOVLW  01
65C8:  MOVWF  xE4
....................    } 
65CA:  BRA    6678
....................    else if(FaultType.B14 == 0) 
65CC:  MOVLB  1
65CE:  BTFSC  x22.5
65D0:  BRA    6678
....................    { 
....................       In2.B14 = 0x00; 
65D2:  BCF    x3A.5
....................       Ack.B14 = 0; 
65D4:  BCF    x32.5
....................       Output.B14 = 1;      //Off LED 
65D6:  BSF    x1A.5
....................  
....................       if((OutputType.B14 == 1 || OutputBoth.B14 == 0)&& inputflag ==0)      //If Buzzer or Both 
65D8:  BTFSC  x26.5
65DA:  BRA    65E0
65DC:  BTFSC  x2A.5
65DE:  BRA    65FA
65E0:  MOVF   xE4,F
65E2:  BNZ   65FA
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
65E4:  MOVLW  01
65E6:  MOVWF  xEF
65E8:  MOVLB  0
65EA:  CALL   40E6
65EE:  DECFSZ 01,W
65F0:  BRA    65F4
65F2:  BRA    65F8
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
65F4:  BCF    F89.4
65F6:  BCF    F92.4
65F8:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B14 == 0 || OutputBoth.B14 == 0)&& inputflag ==0)  //If Bell or Both 
65FA:  BTFSS  x26.5
65FC:  BRA    6602
65FE:  BTFSC  x2A.5
6600:  BRA    6620
6602:  MOVF   xE4,F
6604:  BNZ   6620
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
6606:  MOVLW  02
6608:  MOVWF  xEF
660A:  MOVLB  0
660C:  CALL   40E6
6610:  DECFSZ 01,W
6612:  BRA    6616
6614:  BRA    661E
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
6616:  BCF    F89.3
6618:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
661A:  BCF    F89.4
661C:  BCF    F92.4
661E:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
6620:  BTFSC  x39.0
6622:  BRA    6678
6624:  BTFSC  x39.1
6626:  BRA    6678
6628:  BTFSC  x39.2
662A:  BRA    6678
662C:  BTFSC  x39.3
662E:  BRA    6678
6630:  BTFSC  x39.4
6632:  BRA    6678
6634:  BTFSC  x39.5
6636:  BRA    6678
6638:  BTFSC  x39.6
663A:  BRA    6678
663C:  BTFSC  x39.7
663E:  BRA    6678
6640:  BTFSC  x3A.0
6642:  BRA    6678
6644:  BTFSC  x3A.1
6646:  BRA    6678
6648:  BTFSC  x3A.2
664A:  BRA    6678
664C:  BTFSC  x3A.3
664E:  BRA    6678
6650:  BTFSC  x3A.4
6652:  BRA    6678
6654:  BTFSC  x3A.5
6656:  BRA    6678
6658:  BTFSC  x3A.6
665A:  BRA    6678
665C:  BTFSC  x3A.7
665E:  BRA    6678
6660:  BTFSC  x3B.0
6662:  BRA    6678
6664:  BTFSC  x3B.1
6666:  BRA    6678
6668:  BTFSC  x3B.2
666A:  BRA    6678
666C:  BTFSC  x3B.3
666E:  BRA    6678
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
6670:  BCF    F89.3
6672:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6674:  BCF    F89.4
6676:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input15 
....................    if((((Inputt.B15 ^ InputType.B15) == 1) && (FaultType.B15 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
6678:  MOVLW  00
667A:  BTFSC  x16.6
667C:  MOVLW  01
667E:  MOVLB  2
6680:  MOVWF  x01
6682:  MOVLW  00
6684:  MOVLB  1
6686:  BTFSC  x1E.6
6688:  MOVLW  01
668A:  MOVLB  2
668C:  XORWF  x01,W
668E:  SUBLW  01
6690:  BNZ   669A
6692:  MOVLB  1
6694:  BTFSS  x22.6
6696:  BRA    66A0
6698:  MOVLB  2
669A:  BTFSS  1A.5
669C:  BRA    66F0
669E:  MOVLB  1
....................    { 
....................       if(In2.B15 == 0 && AutoAck == 0x0F && Ack.B15 == 0)   //use auto acknowlegde 
66A0:  BTFSC  x3A.6
66A2:  BRA    66B6
66A4:  MOVF   60,W
66A6:  SUBLW  0F
66A8:  BNZ   66B6
66AA:  BTFSC  x32.6
66AC:  BRA    66B6
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
66AE:  MOVLW  64
66B0:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
66B2:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B15 = 1; 
66B6:  BSF    x3A.6
....................       if(Ack.B15 == 0) 
66B8:  BTFSC  x32.6
66BA:  BRA    66EA
....................       { 
....................          if(FlashingFlag == 0) 
66BC:  BTFSC  1A.1
66BE:  BRA    66C4
....................             { 
....................                Output.B15 = 0;           //Flash output1 
66C0:  BCF    x1A.6
....................             } 
66C2:  BRA    66C6
....................             else 
....................             { 
....................                Output.B15 = 1; 
66C4:  BSF    x1A.6
....................             } 
....................          if (~AutoTestFlag) 
66C6:  BTFSC  1A.4
66C8:  BRA    66EA
....................          { 
....................             if(AlarmIndicator.B15 == 1){ 
66CA:  BTFSS  x2E.6
66CC:  BRA    66EA
....................                 if(OutputBoth.B15 == 0)        //Both output 
66CE:  BTFSC  x2A.6
66D0:  BRA    66DC
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
66D2:  BSF    F89.4
66D4:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
66D6:  BSF    F89.3
66D8:  BCF    F92.3
....................                 } 
66DA:  BRA    66EA
....................                 else 
....................                 { 
....................                   if(OutputType.B15 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
66DC:  BTFSS  x26.6
66DE:  BRA    66E6
66E0:  BSF    F89.4
66E2:  BCF    F92.4
66E4:  BRA    66EA
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
66E6:  BSF    F89.3
66E8:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
66EA:  MOVLW  01
66EC:  MOVWF  xE4
....................    } 
66EE:  BRA    679C
....................    else if(FaultType.B15 == 0) 
66F0:  MOVLB  1
66F2:  BTFSC  x22.6
66F4:  BRA    679C
....................    { 
....................       In2.B15 = 0x00; 
66F6:  BCF    x3A.6
....................       Ack.B15 = 0; 
66F8:  BCF    x32.6
....................       Output.B15 = 1;      //Off LED 
66FA:  BSF    x1A.6
....................  
....................       if((OutputType.B15 == 1 || OutputBoth.B15 == 0)&& inputflag ==0)      //If Buzzer or Both 
66FC:  BTFSC  x26.6
66FE:  BRA    6704
6700:  BTFSC  x2A.6
6702:  BRA    671E
6704:  MOVF   xE4,F
6706:  BNZ   671E
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
6708:  MOVLW  01
670A:  MOVWF  xEF
670C:  MOVLB  0
670E:  CALL   40E6
6712:  DECFSZ 01,W
6714:  BRA    6718
6716:  BRA    671C
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6718:  BCF    F89.4
671A:  BCF    F92.4
671C:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B15 == 0 || OutputBoth.B15 == 0)&& inputflag ==0)  //If Bell or Both 
671E:  BTFSS  x26.6
6720:  BRA    6726
6722:  BTFSC  x2A.6
6724:  BRA    6744
6726:  MOVF   xE4,F
6728:  BNZ   6744
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
672A:  MOVLW  02
672C:  MOVWF  xEF
672E:  MOVLB  0
6730:  CALL   40E6
6734:  DECFSZ 01,W
6736:  BRA    673A
6738:  BRA    6742
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
673A:  BCF    F89.3
673C:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
673E:  BCF    F89.4
6740:  BCF    F92.4
6742:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
6744:  BTFSC  x39.0
6746:  BRA    679C
6748:  BTFSC  x39.1
674A:  BRA    679C
674C:  BTFSC  x39.2
674E:  BRA    679C
6750:  BTFSC  x39.3
6752:  BRA    679C
6754:  BTFSC  x39.4
6756:  BRA    679C
6758:  BTFSC  x39.5
675A:  BRA    679C
675C:  BTFSC  x39.6
675E:  BRA    679C
6760:  BTFSC  x39.7
6762:  BRA    679C
6764:  BTFSC  x3A.0
6766:  BRA    679C
6768:  BTFSC  x3A.1
676A:  BRA    679C
676C:  BTFSC  x3A.2
676E:  BRA    679C
6770:  BTFSC  x3A.3
6772:  BRA    679C
6774:  BTFSC  x3A.4
6776:  BRA    679C
6778:  BTFSC  x3A.5
677A:  BRA    679C
677C:  BTFSC  x3A.6
677E:  BRA    679C
6780:  BTFSC  x3A.7
6782:  BRA    679C
6784:  BTFSC  x3B.0
6786:  BRA    679C
6788:  BTFSC  x3B.1
678A:  BRA    679C
678C:  BTFSC  x3B.2
678E:  BRA    679C
6790:  BTFSC  x3B.3
6792:  BRA    679C
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
6794:  BCF    F89.3
6796:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6798:  BCF    F89.4
679A:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input16 
....................    if((((Inputt.B16 ^ InputType.B16) == 1) && (FaultType.B16 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
679C:  MOVLW  00
679E:  BTFSC  x16.7
67A0:  MOVLW  01
67A2:  MOVLB  2
67A4:  MOVWF  x01
67A6:  MOVLW  00
67A8:  MOVLB  1
67AA:  BTFSC  x1E.7
67AC:  MOVLW  01
67AE:  MOVLB  2
67B0:  XORWF  x01,W
67B2:  SUBLW  01
67B4:  BNZ   67BE
67B6:  MOVLB  1
67B8:  BTFSS  x22.7
67BA:  BRA    67C4
67BC:  MOVLB  2
67BE:  BTFSS  1A.5
67C0:  BRA    6814
67C2:  MOVLB  1
....................    { 
....................       if(In2.B16 == 0 && AutoAck == 0x0F && Ack.B16 == 0)   //use auto acknowlegde 
67C4:  BTFSC  x3A.7
67C6:  BRA    67DA
67C8:  MOVF   60,W
67CA:  SUBLW  0F
67CC:  BNZ   67DA
67CE:  BTFSC  x32.7
67D0:  BRA    67DA
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
67D2:  MOVLW  64
67D4:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
67D6:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B16 = 1; 
67DA:  BSF    x3A.7
....................       if(Ack.B16 == 0) 
67DC:  BTFSC  x32.7
67DE:  BRA    680E
....................       { 
....................          if(FlashingFlag == 0) 
67E0:  BTFSC  1A.1
67E2:  BRA    67E8
....................             { 
....................                Output.B16 = 0;         //Flash output1 
67E4:  BCF    x1A.7
....................             } 
67E6:  BRA    67EA
....................             else 
....................             { 
....................                Output.B16 = 1; 
67E8:  BSF    x1A.7
....................             } 
....................          if (~AutoTestFlag) 
67EA:  BTFSC  1A.4
67EC:  BRA    680E
....................          { 
....................             if(AlarmIndicator.B16 == 1){ 
67EE:  BTFSS  x2E.7
67F0:  BRA    680E
....................                 if(OutputBoth.B16 == 0)        //Both output 
67F2:  BTFSC  x2A.7
67F4:  BRA    6800
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
67F6:  BSF    F89.4
67F8:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
67FA:  BSF    F89.3
67FC:  BCF    F92.3
....................                 } 
67FE:  BRA    680E
....................                 else 
....................                 { 
....................                   if(OutputType.B16 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
6800:  BTFSS  x26.7
6802:  BRA    680A
6804:  BSF    F89.4
6806:  BCF    F92.4
6808:  BRA    680E
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
680A:  BSF    F89.3
680C:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
680E:  MOVLW  01
6810:  MOVWF  xE4
....................    } 
6812:  BRA    68C0
....................    else if(FaultType.B16 == 0) 
6814:  MOVLB  1
6816:  BTFSC  x22.7
6818:  BRA    68C0
....................    { 
....................       In2.B16 = 0x00; 
681A:  BCF    x3A.7
....................       Ack.B16 = 0; 
681C:  BCF    x32.7
....................       Output.B16 = 1;      //Off LED 
681E:  BSF    x1A.7
....................  
....................       if((OutputType.B16 == 1 || OutputBoth.B16 == 0)&& inputflag ==0)      //If Buzzer or Both 
6820:  BTFSC  x26.7
6822:  BRA    6828
6824:  BTFSC  x2A.7
6826:  BRA    6842
6828:  MOVF   xE4,F
682A:  BNZ   6842
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
682C:  MOVLW  01
682E:  MOVWF  xEF
6830:  MOVLB  0
6832:  CALL   40E6
6836:  DECFSZ 01,W
6838:  BRA    683C
683A:  BRA    6840
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
683C:  BCF    F89.4
683E:  BCF    F92.4
6840:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B16 == 0 || OutputBoth.B16 == 0)&& inputflag ==0)  //If Bell or Both 
6842:  BTFSS  x26.7
6844:  BRA    684A
6846:  BTFSC  x2A.7
6848:  BRA    6868
684A:  MOVF   xE4,F
684C:  BNZ   6868
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
684E:  MOVLW  02
6850:  MOVWF  xEF
6852:  MOVLB  0
6854:  CALL   40E6
6858:  DECFSZ 01,W
685A:  BRA    685E
685C:  BRA    6866
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
685E:  BCF    F89.3
6860:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6862:  BCF    F89.4
6864:  BCF    F92.4
6866:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
6868:  BTFSC  x39.0
686A:  BRA    68C0
686C:  BTFSC  x39.1
686E:  BRA    68C0
6870:  BTFSC  x39.2
6872:  BRA    68C0
6874:  BTFSC  x39.3
6876:  BRA    68C0
6878:  BTFSC  x39.4
687A:  BRA    68C0
687C:  BTFSC  x39.5
687E:  BRA    68C0
6880:  BTFSC  x39.6
6882:  BRA    68C0
6884:  BTFSC  x39.7
6886:  BRA    68C0
6888:  BTFSC  x3A.0
688A:  BRA    68C0
688C:  BTFSC  x3A.1
688E:  BRA    68C0
6890:  BTFSC  x3A.2
6892:  BRA    68C0
6894:  BTFSC  x3A.3
6896:  BRA    68C0
6898:  BTFSC  x3A.4
689A:  BRA    68C0
689C:  BTFSC  x3A.5
689E:  BRA    68C0
68A0:  BTFSC  x3A.6
68A2:  BRA    68C0
68A4:  BTFSC  x3A.7
68A6:  BRA    68C0
68A8:  BTFSC  x3B.0
68AA:  BRA    68C0
68AC:  BTFSC  x3B.1
68AE:  BRA    68C0
68B0:  BTFSC  x3B.2
68B2:  BRA    68C0
68B4:  BTFSC  x3B.3
68B6:  BRA    68C0
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
68B8:  BCF    F89.3
68BA:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
68BC:  BCF    F89.4
68BE:  BCF    F92.4
....................       } 
....................    } 
.................... //input17 
....................    if((((Inputt.B17 ^ InputType.B17) == 1) && (FaultType.B17 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
68C0:  MOVLW  00
68C2:  BTFSC  x17.0
68C4:  MOVLW  01
68C6:  MOVLB  2
68C8:  MOVWF  x01
68CA:  MOVLW  00
68CC:  MOVLB  1
68CE:  BTFSC  x1F.0
68D0:  MOVLW  01
68D2:  MOVLB  2
68D4:  XORWF  x01,W
68D6:  SUBLW  01
68D8:  BNZ   68E2
68DA:  MOVLB  1
68DC:  BTFSS  x23.0
68DE:  BRA    68E8
68E0:  MOVLB  2
68E2:  BTFSS  1A.5
68E4:  BRA    6938
68E6:  MOVLB  1
....................    { 
....................       if(In2.B17 == 0 && AutoAck == 0x0F && Ack.B17 == 0)   //use auto acknowlegde 
68E8:  BTFSC  x3B.0
68EA:  BRA    68FE
68EC:  MOVF   60,W
68EE:  SUBLW  0F
68F0:  BNZ   68FE
68F2:  BTFSC  x33.0
68F4:  BRA    68FE
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
68F6:  MOVLW  64
68F8:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
68FA:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B17 = 1; 
68FE:  BSF    x3B.0
....................       if(Ack.B17 == 0) 
6900:  BTFSC  x33.0
6902:  BRA    6932
....................       { 
....................          if(FlashingFlag == 0) 
6904:  BTFSC  1A.1
6906:  BRA    690C
....................             { 
....................                Output.B17 = 0;           //Flash output1 
6908:  BCF    x1B.0
....................             } 
690A:  BRA    690E
....................             else 
....................             { 
....................                Output.B17 = 1; 
690C:  BSF    x1B.0
....................             } 
....................          if (~AutoTestFlag) 
690E:  BTFSC  1A.4
6910:  BRA    6932
....................          { 
....................             if(AlarmIndicator.B17 == 1){ 
6912:  BTFSS  x2F.0
6914:  BRA    6932
....................                 if(OutputBoth.B17 == 0)        //Both output 
6916:  BTFSC  x2B.0
6918:  BRA    6924
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
691A:  BSF    F89.4
691C:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
691E:  BSF    F89.3
6920:  BCF    F92.3
....................                 } 
6922:  BRA    6932
....................                 else 
....................                 { 
....................                   if(OutputType.B17 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
6924:  BTFSS  x27.0
6926:  BRA    692E
6928:  BSF    F89.4
692A:  BCF    F92.4
692C:  BRA    6932
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
692E:  BSF    F89.3
6930:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
6932:  MOVLW  01
6934:  MOVWF  xE4
....................    } 
6936:  BRA    69E4
....................    else if(FaultType.B17 == 0) 
6938:  MOVLB  1
693A:  BTFSC  x23.0
693C:  BRA    69E4
....................    { 
....................       In2.B17 = 0x00; 
693E:  BCF    x3B.0
....................       Ack.B17 = 0; 
6940:  BCF    x33.0
....................       Output.B17 = 1;      //Off LED 
6942:  BSF    x1B.0
....................  
....................       if((OutputType.B17 == 1 || OutputBoth.B17 == 0)&& inputflag ==0)      //If Buzzer or Both 
6944:  BTFSC  x27.0
6946:  BRA    694C
6948:  BTFSC  x2B.0
694A:  BRA    6966
694C:  MOVF   xE4,F
694E:  BNZ   6966
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
6950:  MOVLW  01
6952:  MOVWF  xEF
6954:  MOVLB  0
6956:  CALL   40E6
695A:  DECFSZ 01,W
695C:  BRA    6960
695E:  BRA    6964
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6960:  BCF    F89.4
6962:  BCF    F92.4
6964:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B17 == 0 || OutputBoth.B17 == 0)&& inputflag ==0)  //If Bell or Both 
6966:  BTFSS  x27.0
6968:  BRA    696E
696A:  BTFSC  x2B.0
696C:  BRA    698C
696E:  MOVF   xE4,F
6970:  BNZ   698C
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
6972:  MOVLW  02
6974:  MOVWF  xEF
6976:  MOVLB  0
6978:  CALL   40E6
697C:  DECFSZ 01,W
697E:  BRA    6982
6980:  BRA    698A
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
6982:  BCF    F89.3
6984:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6986:  BCF    F89.4
6988:  BCF    F92.4
698A:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
698C:  BTFSC  x39.0
698E:  BRA    69E4
6990:  BTFSC  x39.1
6992:  BRA    69E4
6994:  BTFSC  x39.2
6996:  BRA    69E4
6998:  BTFSC  x39.3
699A:  BRA    69E4
699C:  BTFSC  x39.4
699E:  BRA    69E4
69A0:  BTFSC  x39.5
69A2:  BRA    69E4
69A4:  BTFSC  x39.6
69A6:  BRA    69E4
69A8:  BTFSC  x39.7
69AA:  BRA    69E4
69AC:  BTFSC  x3A.0
69AE:  BRA    69E4
69B0:  BTFSC  x3A.1
69B2:  BRA    69E4
69B4:  BTFSC  x3A.2
69B6:  BRA    69E4
69B8:  BTFSC  x3A.3
69BA:  BRA    69E4
69BC:  BTFSC  x3A.4
69BE:  BRA    69E4
69C0:  BTFSC  x3A.5
69C2:  BRA    69E4
69C4:  BTFSC  x3A.6
69C6:  BRA    69E4
69C8:  BTFSC  x3A.7
69CA:  BRA    69E4
69CC:  BTFSC  x3B.0
69CE:  BRA    69E4
69D0:  BTFSC  x3B.1
69D2:  BRA    69E4
69D4:  BTFSC  x3B.2
69D6:  BRA    69E4
69D8:  BTFSC  x3B.3
69DA:  BRA    69E4
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
69DC:  BCF    F89.3
69DE:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
69E0:  BCF    F89.4
69E2:  BCF    F92.4
....................       } 
....................    } 
.................... //input18 
....................    if((((Inputt.B18 ^ InputType.B18) == 1) && (FaultType.B18 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
69E4:  MOVLW  00
69E6:  BTFSC  x17.1
69E8:  MOVLW  01
69EA:  MOVLB  2
69EC:  MOVWF  x01
69EE:  MOVLW  00
69F0:  MOVLB  1
69F2:  BTFSC  x1F.1
69F4:  MOVLW  01
69F6:  MOVLB  2
69F8:  XORWF  x01,W
69FA:  SUBLW  01
69FC:  BNZ   6A06
69FE:  MOVLB  1
6A00:  BTFSS  x23.1
6A02:  BRA    6A0C
6A04:  MOVLB  2
6A06:  BTFSS  1A.5
6A08:  BRA    6A5C
6A0A:  MOVLB  1
....................    { 
....................       if(In2.B18 == 0 && AutoAck == 0x0F && Ack.B18 == 0)   //use auto acknowlegde 
6A0C:  BTFSC  x3B.1
6A0E:  BRA    6A22
6A10:  MOVF   60,W
6A12:  SUBLW  0F
6A14:  BNZ   6A22
6A16:  BTFSC  x33.1
6A18:  BRA    6A22
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
6A1A:  MOVLW  64
6A1C:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
6A1E:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B18 = 1; 
6A22:  BSF    x3B.1
....................       if(Ack.B18 == 0) 
6A24:  BTFSC  x33.1
6A26:  BRA    6A56
....................       { 
....................          if(FlashingFlag == 0) 
6A28:  BTFSC  1A.1
6A2A:  BRA    6A30
....................             { 
....................                Output.B18 = 0;           //Flash output1 
6A2C:  BCF    x1B.1
....................             } 
6A2E:  BRA    6A32
....................             else 
....................             { 
....................                Output.B18 = 1; 
6A30:  BSF    x1B.1
....................             } 
....................          if (~AutoTestFlag) 
6A32:  BTFSC  1A.4
6A34:  BRA    6A56
....................          { 
....................             if(AlarmIndicator.B18 == 1){ 
6A36:  BTFSS  x2F.1
6A38:  BRA    6A56
....................                 if(OutputBoth.B18 == 0)        //Both output 
6A3A:  BTFSC  x2B.1
6A3C:  BRA    6A48
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
6A3E:  BSF    F89.4
6A40:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
6A42:  BSF    F89.3
6A44:  BCF    F92.3
....................                 } 
6A46:  BRA    6A56
....................                 else 
....................                 { 
....................                   if(OutputType.B18 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
6A48:  BTFSS  x27.1
6A4A:  BRA    6A52
6A4C:  BSF    F89.4
6A4E:  BCF    F92.4
6A50:  BRA    6A56
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
6A52:  BSF    F89.3
6A54:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
6A56:  MOVLW  01
6A58:  MOVWF  xE4
....................    } 
6A5A:  BRA    6B08
....................    else if(FaultType.B18 == 0) 
6A5C:  MOVLB  1
6A5E:  BTFSC  x23.1
6A60:  BRA    6B08
....................    { 
....................       In2.B18 = 0x00; 
6A62:  BCF    x3B.1
....................       Ack.B18 = 0; 
6A64:  BCF    x33.1
....................       Output.B18 = 1;      //Off LED 
6A66:  BSF    x1B.1
....................  
....................       if((OutputType.B18== 1 || OutputBoth.B18 == 0)&& inputflag ==0)      //If Buzzer or Both 
6A68:  BTFSC  x27.1
6A6A:  BRA    6A70
6A6C:  BTFSC  x2B.1
6A6E:  BRA    6A8A
6A70:  MOVF   xE4,F
6A72:  BNZ   6A8A
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
6A74:  MOVLW  01
6A76:  MOVWF  xEF
6A78:  MOVLB  0
6A7A:  CALL   40E6
6A7E:  DECFSZ 01,W
6A80:  BRA    6A84
6A82:  BRA    6A88
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6A84:  BCF    F89.4
6A86:  BCF    F92.4
6A88:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B18 == 0 || OutputBoth.B18 == 0)&& inputflag ==0)  //If Bell or Both 
6A8A:  BTFSS  x27.1
6A8C:  BRA    6A92
6A8E:  BTFSC  x2B.1
6A90:  BRA    6AB0
6A92:  MOVF   xE4,F
6A94:  BNZ   6AB0
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
6A96:  MOVLW  02
6A98:  MOVWF  xEF
6A9A:  MOVLB  0
6A9C:  CALL   40E6
6AA0:  DECFSZ 01,W
6AA2:  BRA    6AA6
6AA4:  BRA    6AAE
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
6AA6:  BCF    F89.3
6AA8:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6AAA:  BCF    F89.4
6AAC:  BCF    F92.4
6AAE:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
6AB0:  BTFSC  x39.0
6AB2:  BRA    6B08
6AB4:  BTFSC  x39.1
6AB6:  BRA    6B08
6AB8:  BTFSC  x39.2
6ABA:  BRA    6B08
6ABC:  BTFSC  x39.3
6ABE:  BRA    6B08
6AC0:  BTFSC  x39.4
6AC2:  BRA    6B08
6AC4:  BTFSC  x39.5
6AC6:  BRA    6B08
6AC8:  BTFSC  x39.6
6ACA:  BRA    6B08
6ACC:  BTFSC  x39.7
6ACE:  BRA    6B08
6AD0:  BTFSC  x3A.0
6AD2:  BRA    6B08
6AD4:  BTFSC  x3A.1
6AD6:  BRA    6B08
6AD8:  BTFSC  x3A.2
6ADA:  BRA    6B08
6ADC:  BTFSC  x3A.3
6ADE:  BRA    6B08
6AE0:  BTFSC  x3A.4
6AE2:  BRA    6B08
6AE4:  BTFSC  x3A.5
6AE6:  BRA    6B08
6AE8:  BTFSC  x3A.6
6AEA:  BRA    6B08
6AEC:  BTFSC  x3A.7
6AEE:  BRA    6B08
6AF0:  BTFSC  x3B.0
6AF2:  BRA    6B08
6AF4:  BTFSC  x3B.1
6AF6:  BRA    6B08
6AF8:  BTFSC  x3B.2
6AFA:  BRA    6B08
6AFC:  BTFSC  x3B.3
6AFE:  BRA    6B08
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
6B00:  BCF    F89.3
6B02:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6B04:  BCF    F89.4
6B06:  BCF    F92.4
....................       } 
....................    } 
.................... //input19 
....................    if((((Inputt.B19 ^ InputType.B19) == 1) && (FaultType.B19 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
6B08:  MOVLW  00
6B0A:  BTFSC  x17.2
6B0C:  MOVLW  01
6B0E:  MOVLB  2
6B10:  MOVWF  x01
6B12:  MOVLW  00
6B14:  MOVLB  1
6B16:  BTFSC  x1F.2
6B18:  MOVLW  01
6B1A:  MOVLB  2
6B1C:  XORWF  x01,W
6B1E:  SUBLW  01
6B20:  BNZ   6B2A
6B22:  MOVLB  1
6B24:  BTFSS  x23.2
6B26:  BRA    6B30
6B28:  MOVLB  2
6B2A:  BTFSS  1A.5
6B2C:  BRA    6B80
6B2E:  MOVLB  1
....................    { 
....................       if(In2.B19 == 0 && AutoAck == 0x0F && Ack.B19 == 0)   //use auto acknowlegde 
6B30:  BTFSC  x3B.2
6B32:  BRA    6B46
6B34:  MOVF   60,W
6B36:  SUBLW  0F
6B38:  BNZ   6B46
6B3A:  BTFSC  x33.2
6B3C:  BRA    6B46
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
6B3E:  MOVLW  64
6B40:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
6B42:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B19 = 1; 
6B46:  BSF    x3B.2
....................       if(Ack.B19 == 0) 
6B48:  BTFSC  x33.2
6B4A:  BRA    6B7A
....................       { 
....................          if(FlashingFlag == 0) 
6B4C:  BTFSC  1A.1
6B4E:  BRA    6B54
....................             { 
....................                Output.B19 = 0;           //Flash output1 
6B50:  BCF    x1B.2
....................             } 
6B52:  BRA    6B56
....................             else 
....................             { 
....................                Output.B19 = 1; 
6B54:  BSF    x1B.2
....................             } 
....................          if (~AutoTestFlag) 
6B56:  BTFSC  1A.4
6B58:  BRA    6B7A
....................          { 
....................             if(AlarmIndicator.B19 == 1){ 
6B5A:  BTFSS  x2F.2
6B5C:  BRA    6B7A
....................                 if(OutputBoth.B19 == 0)        //Both output 
6B5E:  BTFSC  x2B.2
6B60:  BRA    6B6C
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
6B62:  BSF    F89.4
6B64:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
6B66:  BSF    F89.3
6B68:  BCF    F92.3
....................                 } 
6B6A:  BRA    6B7A
....................                 else 
....................                 { 
....................                   if(OutputType.B19 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
6B6C:  BTFSS  x27.2
6B6E:  BRA    6B76
6B70:  BSF    F89.4
6B72:  BCF    F92.4
6B74:  BRA    6B7A
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
6B76:  BSF    F89.3
6B78:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
6B7A:  MOVLW  01
6B7C:  MOVWF  xE4
....................    } 
6B7E:  BRA    6C2C
....................    else if(FaultType.B19 == 0) 
6B80:  MOVLB  1
6B82:  BTFSC  x23.2
6B84:  BRA    6C2C
....................    { 
....................       In2.B19 = 0x00; 
6B86:  BCF    x3B.2
....................       Ack.B19 = 0; 
6B88:  BCF    x33.2
....................       Output.B19 = 1;      //Off LED 
6B8A:  BSF    x1B.2
....................  
....................       if((OutputType.B19== 1 || OutputBoth.B19 == 0)&& inputflag ==0)      //If Buzzer or Both 
6B8C:  BTFSC  x27.2
6B8E:  BRA    6B94
6B90:  BTFSC  x2B.2
6B92:  BRA    6BAE
6B94:  MOVF   xE4,F
6B96:  BNZ   6BAE
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
6B98:  MOVLW  01
6B9A:  MOVWF  xEF
6B9C:  MOVLB  0
6B9E:  CALL   40E6
6BA2:  DECFSZ 01,W
6BA4:  BRA    6BA8
6BA6:  BRA    6BAC
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6BA8:  BCF    F89.4
6BAA:  BCF    F92.4
6BAC:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B19 == 0 || OutputBoth.B19== 0)&& inputflag ==0)  //If Bell or Both 
6BAE:  BTFSS  x27.2
6BB0:  BRA    6BB6
6BB2:  BTFSC  x2B.2
6BB4:  BRA    6BD4
6BB6:  MOVF   xE4,F
6BB8:  BNZ   6BD4
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
6BBA:  MOVLW  02
6BBC:  MOVWF  xEF
6BBE:  MOVLB  0
6BC0:  CALL   40E6
6BC4:  DECFSZ 01,W
6BC6:  BRA    6BCA
6BC8:  BRA    6BD2
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
6BCA:  BCF    F89.3
6BCC:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6BCE:  BCF    F89.4
6BD0:  BCF    F92.4
6BD2:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
6BD4:  BTFSC  x39.0
6BD6:  BRA    6C2C
6BD8:  BTFSC  x39.1
6BDA:  BRA    6C2C
6BDC:  BTFSC  x39.2
6BDE:  BRA    6C2C
6BE0:  BTFSC  x39.3
6BE2:  BRA    6C2C
6BE4:  BTFSC  x39.4
6BE6:  BRA    6C2C
6BE8:  BTFSC  x39.5
6BEA:  BRA    6C2C
6BEC:  BTFSC  x39.6
6BEE:  BRA    6C2C
6BF0:  BTFSC  x39.7
6BF2:  BRA    6C2C
6BF4:  BTFSC  x3A.0
6BF6:  BRA    6C2C
6BF8:  BTFSC  x3A.1
6BFA:  BRA    6C2C
6BFC:  BTFSC  x3A.2
6BFE:  BRA    6C2C
6C00:  BTFSC  x3A.3
6C02:  BRA    6C2C
6C04:  BTFSC  x3A.4
6C06:  BRA    6C2C
6C08:  BTFSC  x3A.5
6C0A:  BRA    6C2C
6C0C:  BTFSC  x3A.6
6C0E:  BRA    6C2C
6C10:  BTFSC  x3A.7
6C12:  BRA    6C2C
6C14:  BTFSC  x3B.0
6C16:  BRA    6C2C
6C18:  BTFSC  x3B.1
6C1A:  BRA    6C2C
6C1C:  BTFSC  x3B.2
6C1E:  BRA    6C2C
6C20:  BTFSC  x3B.3
6C22:  BRA    6C2C
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
6C24:  BCF    F89.3
6C26:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6C28:  BCF    F89.4
6C2A:  BCF    F92.4
....................       } 
....................    } 
....................        
....................    //input20 
....................    if((((Inputt.B20 ^ InputType.B20) == 1) && (FaultType.B20 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
6C2C:  MOVLW  00
6C2E:  BTFSC  x17.3
6C30:  MOVLW  01
6C32:  MOVLB  2
6C34:  MOVWF  x01
6C36:  MOVLW  00
6C38:  MOVLB  1
6C3A:  BTFSC  x1F.3
6C3C:  MOVLW  01
6C3E:  MOVLB  2
6C40:  XORWF  x01,W
6C42:  SUBLW  01
6C44:  BNZ   6C4E
6C46:  MOVLB  1
6C48:  BTFSS  x23.3
6C4A:  BRA    6C54
6C4C:  MOVLB  2
6C4E:  BTFSS  1A.5
6C50:  BRA    6CA4
6C52:  MOVLB  1
....................    { 
....................       if(In2.B20 == 0 && AutoAck == 0x0F && Ack.B20 == 0)   //use auto acknowlegde 
6C54:  BTFSC  x3B.3
6C56:  BRA    6C6A
6C58:  MOVF   60,W
6C5A:  SUBLW  0F
6C5C:  BNZ   6C6A
6C5E:  BTFSC  x33.3
6C60:  BRA    6C6A
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
6C62:  MOVLW  64
6C64:  MOVWF  1C
....................             AutoAckDelayTime = AutoAckTime ; 
6C66:  MOVFF  61,1D
....................       } 
....................  
....................       In2.B20 = 1; 
6C6A:  BSF    x3B.3
....................       if(Ack.B20 == 0) 
6C6C:  BTFSC  x33.3
6C6E:  BRA    6C9E
....................       { 
....................          if(FlashingFlag == 0) 
6C70:  BTFSC  1A.1
6C72:  BRA    6C78
....................             { 
....................                Output.B20 = 0;           //Flash output1 
6C74:  BCF    x1B.3
....................             } 
6C76:  BRA    6C7A
....................             else 
....................             { 
....................                Output.B20 = 1; 
6C78:  BSF    x1B.3
....................             } 
....................          if (~AutoTestFlag) 
6C7A:  BTFSC  1A.4
6C7C:  BRA    6C9E
....................          { 
....................             if(AlarmIndicator.B20 == 1){ 
6C7E:  BTFSS  x2F.3
6C80:  BRA    6C9E
....................                 if(OutputBoth.B20 == 0)        //Both output 
6C82:  BTFSC  x2B.3
6C84:  BRA    6C90
....................                 { 
....................                   output_bit(Pbuzzer,OnRelay);   //Buzzer 
6C86:  BSF    F89.4
6C88:  BCF    F92.4
....................                   output_bit(Pbell,OnRelay);     //Bell 
6C8A:  BSF    F89.3
6C8C:  BCF    F92.3
....................                 } 
6C8E:  BRA    6C9E
....................                 else 
....................                 { 
....................                   if(OutputType.B20 == 1) output_bit(Pbuzzer,OnRelay);     //Buzzer 
6C90:  BTFSS  x27.3
6C92:  BRA    6C9A
6C94:  BSF    F89.4
6C96:  BCF    F92.4
6C98:  BRA    6C9E
....................                   else output_bit(Pbell,OnRelay);                          //Bell 
6C9A:  BSF    F89.3
6C9C:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................     inputflag =1; 
6C9E:  MOVLW  01
6CA0:  MOVWF  xE4
....................    } 
6CA2:  BRA    6D50
....................    else if(FaultType.B20 == 0) 
6CA4:  MOVLB  1
6CA6:  BTFSC  x23.3
6CA8:  BRA    6D50
....................    { 
....................       In2.B20 = 0x00; 
6CAA:  BCF    x3B.3
....................       Ack.B20 = 0; 
6CAC:  BCF    x33.3
....................       Output.B20 = 1;      //Off LED 
6CAE:  BSF    x1B.3
....................  
....................       if((OutputType.B20== 1 || OutputBoth.B20 == 0)&& inputflag ==0)      //If Buzzer or Both 
6CB0:  BTFSC  x27.3
6CB2:  BRA    6CB8
6CB4:  BTFSC  x2B.3
6CB6:  BRA    6CD2
6CB8:  MOVF   xE4,F
6CBA:  BNZ   6CD2
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing 
6CBC:  MOVLW  01
6CBE:  MOVWF  xEF
6CC0:  MOVLB  0
6CC2:  CALL   40E6
6CC6:  DECFSZ 01,W
6CC8:  BRA    6CCC
6CCA:  BRA    6CD0
....................          else 
....................          { 
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6CCC:  BCF    F89.4
6CCE:  BCF    F92.4
6CD0:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B20 == 0 || OutputBoth.B20 == 0)&& inputflag ==0)  //If Bell or Both 
6CD2:  BTFSS  x27.3
6CD4:  BRA    6CDA
6CD6:  BTFSC  x2B.3
6CD8:  BRA    6CF8
6CDA:  MOVF   xE4,F
6CDC:  BNZ   6CF8
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
6CDE:  MOVLW  02
6CE0:  MOVWF  xEF
6CE2:  MOVLB  0
6CE4:  CALL   40E6
6CE8:  DECFSZ 01,W
6CEA:  BRA    6CEE
6CEC:  BRA    6CF6
....................          else 
....................          { 
....................             output_bit(Pbell,OffRelay);      //Clear Bell 
6CEE:  BCF    F89.3
6CF0:  BCF    F92.3
....................             output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6CF2:  BCF    F89.4
6CF4:  BCF    F92.4
6CF6:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0 && In2.B11 ==0 && In2.B12 ==0 && In2.B13 ==0 && In2.B14 ==0 && In2.B15 ==0 && In2.B16 ==0 && In2.B17 ==0 && In2.B18 ==0 && In2.B19 ==0 && In2.B20 ==0 ) 
6CF8:  BTFSC  x39.0
6CFA:  BRA    6D50
6CFC:  BTFSC  x39.1
6CFE:  BRA    6D50
6D00:  BTFSC  x39.2
6D02:  BRA    6D50
6D04:  BTFSC  x39.3
6D06:  BRA    6D50
6D08:  BTFSC  x39.4
6D0A:  BRA    6D50
6D0C:  BTFSC  x39.5
6D0E:  BRA    6D50
6D10:  BTFSC  x39.6
6D12:  BRA    6D50
6D14:  BTFSC  x39.7
6D16:  BRA    6D50
6D18:  BTFSC  x3A.0
6D1A:  BRA    6D50
6D1C:  BTFSC  x3A.1
6D1E:  BRA    6D50
6D20:  BTFSC  x3A.2
6D22:  BRA    6D50
6D24:  BTFSC  x3A.3
6D26:  BRA    6D50
6D28:  BTFSC  x3A.4
6D2A:  BRA    6D50
6D2C:  BTFSC  x3A.5
6D2E:  BRA    6D50
6D30:  BTFSC  x3A.6
6D32:  BRA    6D50
6D34:  BTFSC  x3A.7
6D36:  BRA    6D50
6D38:  BTFSC  x3B.0
6D3A:  BRA    6D50
6D3C:  BTFSC  x3B.1
6D3E:  BRA    6D50
6D40:  BTFSC  x3B.2
6D42:  BRA    6D50
6D44:  BTFSC  x3B.3
6D46:  BRA    6D50
....................       { 
....................          output_bit(Pbell,OffRelay);      //Clear Bell 
6D48:  BCF    F89.3
6D4A:  BCF    F92.3
....................          output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
6D4C:  BCF    F89.4
6D4E:  BCF    F92.4
....................       } 
....................    } 
6D50:  MOVLB  0
6D52:  RETURN 0
....................     
....................     
....................  //} 
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void Send_Ouput(void) 
.................... { 
....................  
....................    if(T_test == 0x00) 
*
6E50:  MOVF   2F,F
6E52:  BTFSS  FD8.2
6E54:  BRA    72F0
....................    { 
....................       //if(NoOfPoint >= 10) 
....................       //{ 
....................        
....................       
....................            if(Output.B1)//++++++++++++B1+++++++++++++++++++++ 
6E56:  MOVLB  1
6E58:  BTFSS  x19.0
6E5A:  BRA    6E62
....................            { 
....................              bit_clear(Green1_8,0); bit_clear(Red1_8,0); 
6E5C:  BCF    54.0
6E5E:  BCF    50.0
....................            } 
6E60:  BRA    6E8A
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B1 )&&(GREEN_Colour.B1 ==0 ))//Red 
6E62:  BTFSS  x45.0
6E64:  BRA    6E70
6E66:  BTFSC  x49.0
6E68:  BRA    6E70
....................              { 
....................                bit_set(Red1_8,0); bit_clear(Green1_8,0); 
6E6A:  BSF    50.0
6E6C:  BCF    54.0
....................              } 
6E6E:  BRA    6E8A
....................              else if((RED_Colour.B1==0 )&&(GREEN_Colour.B1))//Green 
6E70:  BTFSC  x45.0
6E72:  BRA    6E7E
6E74:  BTFSS  x49.0
6E76:  BRA    6E7E
....................              { 
....................                bit_clear(Red1_8,0); bit_set(Green1_8,0);  
6E78:  BCF    50.0
6E7A:  BSF    54.0
....................              } 
6E7C:  BRA    6E8A
....................              else if((RED_Colour.B1)&&(GREEN_Colour.B1))//Ambian 
6E7E:  BTFSS  x45.0
6E80:  BRA    6E8A
6E82:  BTFSS  x49.0
6E84:  BRA    6E8A
....................              { 
....................                bit_set(Red1_8,0); bit_set(Green1_8,0) ;  
6E86:  BSF    50.0
6E88:  BSF    54.0
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B2)//++++++++++++B2+++++++++++++++++++++ 
6E8A:  BTFSS  x19.1
6E8C:  BRA    6E94
....................            { 
....................              bit_clear(Green1_8,1); bit_clear(Red1_8,1); 
6E8E:  BCF    54.1
6E90:  BCF    50.1
....................            } 
6E92:  BRA    6EBC
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B2 )&&(GREEN_Colour.B2 ==0 ))//Red 
6E94:  BTFSS  x45.1
6E96:  BRA    6EA2
6E98:  BTFSC  x49.1
6E9A:  BRA    6EA2
....................              { 
....................                bit_set(Red1_8,1); bit_clear(Green1_8,1); 
6E9C:  BSF    50.1
6E9E:  BCF    54.1
....................              } 
6EA0:  BRA    6EBC
....................              else if((RED_Colour.B2==0 )&&(GREEN_Colour.B2))//Green 
6EA2:  BTFSC  x45.1
6EA4:  BRA    6EB0
6EA6:  BTFSS  x49.1
6EA8:  BRA    6EB0
....................              { 
....................                bit_clear(Red1_8,1); bit_set(Green1_8,1);  
6EAA:  BCF    50.1
6EAC:  BSF    54.1
....................              } 
6EAE:  BRA    6EBC
....................              else if((RED_Colour.B2)&&(GREEN_Colour.B2))//Ambian 
6EB0:  BTFSS  x45.1
6EB2:  BRA    6EBC
6EB4:  BTFSS  x49.1
6EB6:  BRA    6EBC
....................              { 
....................                bit_set(Red1_8,1); bit_set(Green1_8,1) ;  
6EB8:  BSF    50.1
6EBA:  BSF    54.1
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B3)//++++++++++++B3+++++++++++++++++++++ 
6EBC:  BTFSS  x19.2
6EBE:  BRA    6EC6
....................            { 
....................              bit_clear(Green1_8,2); bit_clear(Red1_8,2); 
6EC0:  BCF    54.2
6EC2:  BCF    50.2
....................            } 
6EC4:  BRA    6EEE
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B3 )&&(GREEN_Colour.B3 ==0 ))//Red 
6EC6:  BTFSS  x45.2
6EC8:  BRA    6ED4
6ECA:  BTFSC  x49.2
6ECC:  BRA    6ED4
....................              { 
....................                bit_set(Red1_8,2); bit_clear(Green1_8,2); 
6ECE:  BSF    50.2
6ED0:  BCF    54.2
....................              } 
6ED2:  BRA    6EEE
....................              else if((RED_Colour.B3==0 )&&(GREEN_Colour.B3))//Green 
6ED4:  BTFSC  x45.2
6ED6:  BRA    6EE2
6ED8:  BTFSS  x49.2
6EDA:  BRA    6EE2
....................              { 
....................                bit_clear(Red1_8,2); bit_set(Green1_8,2);  
6EDC:  BCF    50.2
6EDE:  BSF    54.2
....................              } 
6EE0:  BRA    6EEE
....................              else if((RED_Colour.B3)&&(GREEN_Colour.B3))//Ambian 
6EE2:  BTFSS  x45.2
6EE4:  BRA    6EEE
6EE6:  BTFSS  x49.2
6EE8:  BRA    6EEE
....................              { 
....................                bit_set(Red1_8,2); bit_set(Green1_8,2) ;  
6EEA:  BSF    50.2
6EEC:  BSF    54.2
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B4)//++++++++++++B4+++++++++++++++++++++ 
6EEE:  BTFSS  x19.3
6EF0:  BRA    6EF8
....................            { 
....................              bit_clear(Green1_8,3); bit_clear(Red1_8,3); 
6EF2:  BCF    54.3
6EF4:  BCF    50.3
....................            } 
6EF6:  BRA    6F20
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B4 )&&(GREEN_Colour.B4 ==0 ))//Red 
6EF8:  BTFSS  x45.3
6EFA:  BRA    6F06
6EFC:  BTFSC  x49.3
6EFE:  BRA    6F06
....................              { 
....................                bit_set(Red1_8,3); bit_clear(Green1_8,3); 
6F00:  BSF    50.3
6F02:  BCF    54.3
....................              } 
6F04:  BRA    6F20
....................              else if((RED_Colour.B4==0 )&&(GREEN_Colour.B4))//Green 
6F06:  BTFSC  x45.3
6F08:  BRA    6F14
6F0A:  BTFSS  x49.3
6F0C:  BRA    6F14
....................              { 
....................                bit_clear(Red1_8,3); bit_set(Green1_8,3);  
6F0E:  BCF    50.3
6F10:  BSF    54.3
....................              } 
6F12:  BRA    6F20
....................              else if((RED_Colour.B4)&&(GREEN_Colour.B4))//Ambian 
6F14:  BTFSS  x45.3
6F16:  BRA    6F20
6F18:  BTFSS  x49.3
6F1A:  BRA    6F20
....................              { 
....................                bit_set(Red1_8,3); bit_set(Green1_8,3) ;  
6F1C:  BSF    50.3
6F1E:  BSF    54.3
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B5)//++++++++++++B5+++++++++++++++++++++ 
6F20:  BTFSS  x19.4
6F22:  BRA    6F2A
....................            { 
....................              bit_clear(Green1_8,4); bit_clear(Red1_8,4); 
6F24:  BCF    54.4
6F26:  BCF    50.4
....................            } 
6F28:  BRA    6F52
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B5 )&&(GREEN_Colour.B5 ==0 ))//Red 
6F2A:  BTFSS  x45.4
6F2C:  BRA    6F38
6F2E:  BTFSC  x49.4
6F30:  BRA    6F38
....................              { 
....................                bit_set(Red1_8,4); bit_clear(Green1_8,4); 
6F32:  BSF    50.4
6F34:  BCF    54.4
....................              } 
6F36:  BRA    6F52
....................              else if((RED_Colour.B5==0 )&&(GREEN_Colour.B5))//Green 
6F38:  BTFSC  x45.4
6F3A:  BRA    6F46
6F3C:  BTFSS  x49.4
6F3E:  BRA    6F46
....................              { 
....................                bit_clear(Red1_8,4); bit_set(Green1_8,4);  
6F40:  BCF    50.4
6F42:  BSF    54.4
....................              } 
6F44:  BRA    6F52
....................              else if((RED_Colour.B5)&&(GREEN_Colour.B5))//Ambian 
6F46:  BTFSS  x45.4
6F48:  BRA    6F52
6F4A:  BTFSS  x49.4
6F4C:  BRA    6F52
....................              { 
....................                bit_set(Red1_8,4); bit_set(Green1_8,4) ;  
6F4E:  BSF    50.4
6F50:  BSF    54.4
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B6)//++++++++++++B6+++++++++++++++++++++ 
6F52:  BTFSS  x19.5
6F54:  BRA    6F5C
....................            { 
....................              bit_clear(Green1_8,5); bit_clear(Red1_8,5); 
6F56:  BCF    54.5
6F58:  BCF    50.5
....................            } 
6F5A:  BRA    6F84
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B6 )&&(GREEN_Colour.B6 ==0 ))//Red 
6F5C:  BTFSS  x45.5
6F5E:  BRA    6F6A
6F60:  BTFSC  x49.5
6F62:  BRA    6F6A
....................              { 
....................                bit_set(Red1_8,5); bit_clear(Green1_8,5); 
6F64:  BSF    50.5
6F66:  BCF    54.5
....................              } 
6F68:  BRA    6F84
....................              else if((RED_Colour.B6==0 )&&(GREEN_Colour.B6))//Green 
6F6A:  BTFSC  x45.5
6F6C:  BRA    6F78
6F6E:  BTFSS  x49.5
6F70:  BRA    6F78
....................              { 
....................                bit_clear(Red1_8,5); bit_set(Green1_8,5);  
6F72:  BCF    50.5
6F74:  BSF    54.5
....................              } 
6F76:  BRA    6F84
....................              else if((RED_Colour.B6)&&(GREEN_Colour.B6))//Ambian 
6F78:  BTFSS  x45.5
6F7A:  BRA    6F84
6F7C:  BTFSS  x49.5
6F7E:  BRA    6F84
....................              { 
....................                bit_set(Red1_8,5); bit_set(Green1_8,5) ;  
6F80:  BSF    50.5
6F82:  BSF    54.5
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B7)//++++++++++++B7+++++++++++++++++++++ 
6F84:  BTFSS  x19.6
6F86:  BRA    6F8E
....................            { 
....................              bit_clear(Green1_8,6); bit_clear(Red1_8,6); 
6F88:  BCF    54.6
6F8A:  BCF    50.6
....................            } 
6F8C:  BRA    6FB6
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B7 )&&(GREEN_Colour.B7 ==0 ))//Red 
6F8E:  BTFSS  x45.6
6F90:  BRA    6F9C
6F92:  BTFSC  x49.6
6F94:  BRA    6F9C
....................              { 
....................                bit_set(Red1_8,6); bit_clear(Green1_8,6); 
6F96:  BSF    50.6
6F98:  BCF    54.6
....................              } 
6F9A:  BRA    6FB6
....................              else if((RED_Colour.B7==0 )&&(GREEN_Colour.B7))//Green 
6F9C:  BTFSC  x45.6
6F9E:  BRA    6FAA
6FA0:  BTFSS  x49.6
6FA2:  BRA    6FAA
....................              { 
....................                bit_clear(Red1_8,6); bit_set(Green1_8,6);  
6FA4:  BCF    50.6
6FA6:  BSF    54.6
....................              } 
6FA8:  BRA    6FB6
....................              else if((RED_Colour.B7)&&(GREEN_Colour.B7))//Ambian 
6FAA:  BTFSS  x45.6
6FAC:  BRA    6FB6
6FAE:  BTFSS  x49.6
6FB0:  BRA    6FB6
....................              { 
....................                bit_set(Red1_8,6); bit_set(Green1_8,6) ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
6FB2:  BSF    50.6
6FB4:  BSF    54.6
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B8)//++++++++++++B8+++++++++++++++++++++ 
6FB6:  BTFSS  x19.7
6FB8:  BRA    6FC0
....................            { 
....................              bit_clear(Green1_8,7); bit_clear(Red1_8,7); 
6FBA:  BCF    54.7
6FBC:  BCF    50.7
....................            } 
6FBE:  BRA    6FE8
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B8 )&&(GREEN_Colour.B8 ==0 ))//Red 
6FC0:  BTFSS  x45.7
6FC2:  BRA    6FCE
6FC4:  BTFSC  x49.7
6FC6:  BRA    6FCE
....................              { 
....................                bit_set(Red1_8,7); bit_clear(Green1_8,7); 
6FC8:  BSF    50.7
6FCA:  BCF    54.7
....................              } 
6FCC:  BRA    6FE8
....................              else if((RED_Colour.B8==0 )&&(GREEN_Colour.B8))//Green 
6FCE:  BTFSC  x45.7
6FD0:  BRA    6FDC
6FD2:  BTFSS  x49.7
6FD4:  BRA    6FDC
....................              { 
....................                bit_clear(Red1_8,7); bit_set(Green1_8,7);  
6FD6:  BCF    50.7
6FD8:  BSF    54.7
....................              } 
6FDA:  BRA    6FE8
....................              else if((RED_Colour.B8)&&(GREEN_Colour.B8))//Ambian 
6FDC:  BTFSS  x45.7
6FDE:  BRA    6FE8
6FE0:  BTFSS  x49.7
6FE2:  BRA    6FE8
....................              { 
....................                bit_set(Red1_8,7); bit_set(Green1_8,7) ;  
6FE4:  BSF    50.7
6FE6:  BSF    54.7
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B9)//++++++++++++B9+++++++++++++++++++++ 
6FE8:  BTFSS  x1A.0
6FEA:  BRA    6FF2
....................            { 
....................              bit_clear(Green9_10,0); bit_clear(Red9_10,0); 
6FEC:  BCF    55.0
6FEE:  BCF    51.0
....................            } 
6FF0:  BRA    701A
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B9 )&&(GREEN_Colour.B9 ==0 ))//Red 
6FF2:  BTFSS  x46.0
6FF4:  BRA    7000
6FF6:  BTFSC  x4A.0
6FF8:  BRA    7000
....................              { 
....................                bit_set(Red9_10,0); bit_clear(Green9_10,0); 
6FFA:  BSF    51.0
6FFC:  BCF    55.0
....................              } 
6FFE:  BRA    701A
....................              else if((RED_Colour.B9==0 )&&(GREEN_Colour.B9))//Green 
7000:  BTFSC  x46.0
7002:  BRA    700E
7004:  BTFSS  x4A.0
7006:  BRA    700E
....................              { 
....................                bit_clear(Red9_10,0); bit_set(Green9_10,0);  
7008:  BCF    51.0
700A:  BSF    55.0
....................              } 
700C:  BRA    701A
....................              else if((RED_Colour.B9)&&(GREEN_Colour.B9))//Ambian 
700E:  BTFSS  x46.0
7010:  BRA    701A
7012:  BTFSS  x4A.0
7014:  BRA    701A
....................              { 
....................                bit_set(Red9_10,0); bit_set(Green9_10,0) ;  
7016:  BSF    51.0
7018:  BSF    55.0
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................             if(Output.B10)//++++++++++++B10+++++++++++++++++++++ 
701A:  BTFSS  x1A.1
701C:  BRA    7024
....................            { 
....................              bit_clear(Green9_10,1); bit_clear(Red9_10,1); 
701E:  BCF    55.1
7020:  BCF    51.1
....................            } 
7022:  BRA    704C
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B10 )&&(GREEN_Colour.B10 ==0 ))//Red 
7024:  BTFSS  x46.1
7026:  BRA    7032
7028:  BTFSC  x4A.1
702A:  BRA    7032
....................              { 
....................                bit_set(Red9_10,1); bit_clear(Green9_10,1); 
702C:  BSF    51.1
702E:  BCF    55.1
....................              } 
7030:  BRA    704C
....................              else if((RED_Colour.B10==0 )&&(GREEN_Colour.B10))//Green 
7032:  BTFSC  x46.1
7034:  BRA    7040
7036:  BTFSS  x4A.1
7038:  BRA    7040
....................              { 
....................                bit_clear(Red9_10,1); bit_set(Green9_10,1);  
703A:  BCF    51.1
703C:  BSF    55.1
....................              } 
703E:  BRA    704C
....................              else if((RED_Colour.B10)&&(GREEN_Colour.B10))//Ambian 
7040:  BTFSS  x46.1
7042:  BRA    704C
7044:  BTFSS  x4A.1
7046:  BRA    704C
....................              { 
....................                bit_set(Red9_10,1); bit_set(Green9_10,1) ;  
7048:  BSF    51.1
704A:  BSF    55.1
....................              }   
....................            } 
....................             
....................        // } 
....................          
....................        // if(NoOfPoint >= 20) 
....................       //{    
....................            //////////////////////////////////////////////////////// 
....................             if(Output.B11)//++++++++++++B11+++++++++++++++++++++ 
704C:  BTFSS  x1A.2
704E:  BRA    7056
....................            { 
....................              bit_clear(Green11_18,0); bit_clear(Red11_18,0); 
7050:  BCF    56.0
7052:  BCF    52.0
....................            } 
7054:  BRA    707E
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B11 )&&(GREEN_Colour.B11 ==0 ))//Red 
7056:  BTFSS  x46.2
7058:  BRA    7064
705A:  BTFSC  x4A.2
705C:  BRA    7064
....................              { 
....................                bit_set(Red11_18,0); bit_clear(Green11_18,0); 
705E:  BSF    52.0
7060:  BCF    56.0
....................              } 
7062:  BRA    707E
....................              else if((RED_Colour.B11==0 )&&(GREEN_Colour.B11))//Green 
7064:  BTFSC  x46.2
7066:  BRA    7072
7068:  BTFSS  x4A.2
706A:  BRA    7072
....................              { 
....................                bit_clear(Red11_18,0); bit_set(Green11_18,0);  
706C:  BCF    52.0
706E:  BSF    56.0
....................              } 
7070:  BRA    707E
....................              else if((RED_Colour.B11)&&(GREEN_Colour.B11))//Ambian 
7072:  BTFSS  x46.2
7074:  BRA    707E
7076:  BTFSS  x4A.2
7078:  BRA    707E
....................              { 
....................                bit_set(Red11_18,0); bit_set(Green11_18,0) ;  
707A:  BSF    52.0
707C:  BSF    56.0
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................             if(Output.B11)//++++++++++++B11+++++++++++++++++++++ 
707E:  BTFSS  x1A.2
7080:  BRA    7088
....................            { 
....................              bit_clear(Green11_18,0); bit_clear(Red11_18,0); 
7082:  BCF    56.0
7084:  BCF    52.0
....................            } 
7086:  BRA    70B0
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B11 )&&(GREEN_Colour.B11 ==0 ))//Red 
7088:  BTFSS  x46.2
708A:  BRA    7096
708C:  BTFSC  x4A.2
708E:  BRA    7096
....................              { 
....................                bit_set(Red11_18,0); bit_clear(Green11_18,0); 
7090:  BSF    52.0
7092:  BCF    56.0
....................              } 
7094:  BRA    70B0
....................              else if((RED_Colour.B11==0 )&&(GREEN_Colour.B11))//Green 
7096:  BTFSC  x46.2
7098:  BRA    70A4
709A:  BTFSS  x4A.2
709C:  BRA    70A4
....................              { 
....................                bit_clear(Red11_18,0); bit_set(Green11_18,0);  
709E:  BCF    52.0
70A0:  BSF    56.0
....................              } 
70A2:  BRA    70B0
....................              else if((RED_Colour.B11)&&(GREEN_Colour.B11))//Ambian 
70A4:  BTFSS  x46.2
70A6:  BRA    70B0
70A8:  BTFSS  x4A.2
70AA:  BRA    70B0
....................              { 
....................                bit_set(Red11_18,0); bit_set(Green11_18,0) ;  
70AC:  BSF    52.0
70AE:  BSF    56.0
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B12)//++++++++++++B12+++++++++++++++++++++ 
70B0:  BTFSS  x1A.3
70B2:  BRA    70BA
....................            { 
....................              bit_clear(Green11_18,1); bit_clear(Red11_18,1); 
70B4:  BCF    56.1
70B6:  BCF    52.1
....................            } 
70B8:  BRA    70E2
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B12 )&&(GREEN_Colour.B12 ==0 ))//Red 
70BA:  BTFSS  x46.3
70BC:  BRA    70C8
70BE:  BTFSC  x4A.3
70C0:  BRA    70C8
....................              { 
....................                bit_set(Red11_18,1); bit_clear(Green11_18,1); 
70C2:  BSF    52.1
70C4:  BCF    56.1
....................              } 
70C6:  BRA    70E2
....................              else if((RED_Colour.B12==0 )&&(GREEN_Colour.B12))//Green 
70C8:  BTFSC  x46.3
70CA:  BRA    70D6
70CC:  BTFSS  x4A.3
70CE:  BRA    70D6
....................              { 
....................                bit_clear(Red11_18,1); bit_set(Green11_18,1);  
70D0:  BCF    52.1
70D2:  BSF    56.1
....................              } 
70D4:  BRA    70E2
....................              else if((RED_Colour.B12)&&(GREEN_Colour.B12))//Ambian 
70D6:  BTFSS  x46.3
70D8:  BRA    70E2
70DA:  BTFSS  x4A.3
70DC:  BRA    70E2
....................              { 
....................                bit_set(Red11_18,1); bit_set(Green11_18,1) ;  
70DE:  BSF    52.1
70E0:  BSF    56.1
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B13)//++++++++++++B13+++++++++++++++++++++ 
70E2:  BTFSS  x1A.4
70E4:  BRA    70EC
....................            { 
....................              bit_clear(Green11_18,2); bit_clear(Red11_18,2); 
70E6:  BCF    56.2
70E8:  BCF    52.2
....................            } 
70EA:  BRA    7114
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B13 )&&(GREEN_Colour.B13 ==0 ))//Red 
70EC:  BTFSS  x46.4
70EE:  BRA    70FA
70F0:  BTFSC  x4A.4
70F2:  BRA    70FA
....................              { 
....................                bit_set(Red11_18,2); bit_clear(Green11_18,2); 
70F4:  BSF    52.2
70F6:  BCF    56.2
....................              } 
70F8:  BRA    7114
....................              else if((RED_Colour.B13==0 )&&(GREEN_Colour.B13))//Green 
70FA:  BTFSC  x46.4
70FC:  BRA    7108
70FE:  BTFSS  x4A.4
7100:  BRA    7108
....................              { 
....................                bit_clear(Red11_18,2); bit_set(Green11_18,2);  
7102:  BCF    52.2
7104:  BSF    56.2
....................              } 
7106:  BRA    7114
....................              else if((RED_Colour.B13)&&(GREEN_Colour.B13))//Ambian 
7108:  BTFSS  x46.4
710A:  BRA    7114
710C:  BTFSS  x4A.4
710E:  BRA    7114
....................              { 
....................                bit_set(Red11_18,2); bit_set(Green11_18,2) ;  
7110:  BSF    52.2
7112:  BSF    56.2
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B14)//++++++++++++B14+++++++++++++++++++++ 
7114:  BTFSS  x1A.5
7116:  BRA    711E
....................            { 
....................              bit_clear(Green11_18,3); bit_clear(Red11_18,3); 
7118:  BCF    56.3
711A:  BCF    52.3
....................            } 
711C:  BRA    7146
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B14 )&&(GREEN_Colour.B14 ==0 ))//Red 
711E:  BTFSS  x46.5
7120:  BRA    712C
7122:  BTFSC  x4A.5
7124:  BRA    712C
....................              { 
....................                bit_set(Red11_18,3); bit_clear(Green11_18,3); 
7126:  BSF    52.3
7128:  BCF    56.3
....................              } 
712A:  BRA    7146
....................              else if((RED_Colour.B14==0 )&&(GREEN_Colour.B14))//Green 
712C:  BTFSC  x46.5
712E:  BRA    713A
7130:  BTFSS  x4A.5
7132:  BRA    713A
....................              { 
....................                bit_clear(Red11_18,3); bit_set(Green11_18,3);  
7134:  BCF    52.3
7136:  BSF    56.3
....................              } 
7138:  BRA    7146
....................              else if((RED_Colour.B14)&&(GREEN_Colour.B14))//Ambian 
713A:  BTFSS  x46.5
713C:  BRA    7146
713E:  BTFSS  x4A.5
7140:  BRA    7146
....................              { 
....................                bit_set(Red11_18,3); bit_set(Green11_18,3) ;  
7142:  BSF    52.3
7144:  BSF    56.3
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B15)//++++++++++++B15+++++++++++++++++++++ 
7146:  BTFSS  x1A.6
7148:  BRA    7150
....................            { 
....................              bit_clear(Green11_18,4); bit_clear(Red11_18,4); 
714A:  BCF    56.4
714C:  BCF    52.4
....................            } 
714E:  BRA    7178
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B15 )&&(GREEN_Colour.B15 ==0 ))//Red 
7150:  BTFSS  x46.6
7152:  BRA    715E
7154:  BTFSC  x4A.6
7156:  BRA    715E
....................              { 
....................                bit_set(Red11_18,4); bit_clear(Green11_18,4); 
7158:  BSF    52.4
715A:  BCF    56.4
....................              } 
715C:  BRA    7178
....................              else if((RED_Colour.B15==0 )&&(GREEN_Colour.B15))//Green 
715E:  BTFSC  x46.6
7160:  BRA    716C
7162:  BTFSS  x4A.6
7164:  BRA    716C
....................              { 
....................                bit_clear(Red11_18,4); bit_set(Green11_18,4);  
7166:  BCF    52.4
7168:  BSF    56.4
....................              } 
716A:  BRA    7178
....................              else if((RED_Colour.B15)&&(GREEN_Colour.B15))//Ambian 
716C:  BTFSS  x46.6
716E:  BRA    7178
7170:  BTFSS  x4A.6
7172:  BRA    7178
....................              { 
....................                bit_set(Red11_18,4); bit_set(Green11_18,4) ;  
7174:  BSF    52.4
7176:  BSF    56.4
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B16)//++++++++++++B16+++++++++++++++++++++ 
7178:  BTFSS  x1A.7
717A:  BRA    7182
....................            { 
....................              bit_clear(Green11_18,5); bit_clear(Red11_18,5); 
717C:  BCF    56.5
717E:  BCF    52.5
....................            } 
7180:  BRA    71AA
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B16 )&&(GREEN_Colour.B16 ==0 ))//Red 
7182:  BTFSS  x46.7
7184:  BRA    7190
7186:  BTFSC  x4A.7
7188:  BRA    7190
....................              { 
....................                bit_set(Red11_18,5); bit_clear(Green11_18,5); 
718A:  BSF    52.5
718C:  BCF    56.5
....................              } 
718E:  BRA    71AA
....................              else if((RED_Colour.B16==0 )&&(GREEN_Colour.B16))//Green 
7190:  BTFSC  x46.7
7192:  BRA    719E
7194:  BTFSS  x4A.7
7196:  BRA    719E
....................              { 
....................                bit_clear(Red11_18,5); bit_set(Green11_18,5);  
7198:  BCF    52.5
719A:  BSF    56.5
....................              } 
719C:  BRA    71AA
....................              else if((RED_Colour.B16)&&(GREEN_Colour.B16))//Ambian 
719E:  BTFSS  x46.7
71A0:  BRA    71AA
71A2:  BTFSS  x4A.7
71A4:  BRA    71AA
....................              { 
....................                bit_set(Red11_18,5); bit_set(Green11_18,5) ;  
71A6:  BSF    52.5
71A8:  BSF    56.5
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B17)//++++++++++++B17+++++++++++++++++++++ 
71AA:  BTFSS  x1B.0
71AC:  BRA    71B4
....................            { 
....................              bit_clear(Green11_18,6); bit_clear(Red11_18,6); 
71AE:  BCF    56.6
71B0:  BCF    52.6
....................            } 
71B2:  BRA    71DC
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B17 )&&(GREEN_Colour.B17 ==0 ))//Red 
71B4:  BTFSS  x47.0
71B6:  BRA    71C2
71B8:  BTFSC  x4B.0
71BA:  BRA    71C2
....................              { 
....................                bit_set(Red11_18,6); bit_clear(Green11_18,6); 
71BC:  BSF    52.6
71BE:  BCF    56.6
....................              } 
71C0:  BRA    71DC
....................              else if((RED_Colour.B17==0 )&&(GREEN_Colour.B17))//Green 
71C2:  BTFSC  x47.0
71C4:  BRA    71D0
71C6:  BTFSS  x4B.0
71C8:  BRA    71D0
....................              { 
....................                bit_clear(Red11_18,6); bit_set(Green11_18,6);  
71CA:  BCF    52.6
71CC:  BSF    56.6
....................              } 
71CE:  BRA    71DC
....................              else if((RED_Colour.B17)&&(GREEN_Colour.B17))//Ambian 
71D0:  BTFSS  x47.0
71D2:  BRA    71DC
71D4:  BTFSS  x4B.0
71D6:  BRA    71DC
....................              { 
....................                bit_set(Red11_18,6); bit_set(Green11_18,6) ;  
71D8:  BSF    52.6
71DA:  BSF    56.6
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B18)//++++++++++++B18+++++++++++++++++++++ 
71DC:  BTFSS  x1B.1
71DE:  BRA    71E6
....................            { 
....................              bit_clear(Green11_18,7); bit_clear(Red11_18,7); 
71E0:  BCF    56.7
71E2:  BCF    52.7
....................            } 
71E4:  BRA    720E
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B18 )&&(GREEN_Colour.B18 ==0 ))//Red 
71E6:  BTFSS  x47.1
71E8:  BRA    71F4
71EA:  BTFSC  x4B.1
71EC:  BRA    71F4
....................              { 
....................                bit_set(Red11_18,7); bit_clear(Green11_18,7); 
71EE:  BSF    52.7
71F0:  BCF    56.7
....................              } 
71F2:  BRA    720E
....................              else if((RED_Colour.B18==0 )&&(GREEN_Colour.B18))//Green 
71F4:  BTFSC  x47.1
71F6:  BRA    7202
71F8:  BTFSS  x4B.1
71FA:  BRA    7202
....................              { 
....................                bit_clear(Red11_18,7); bit_set(Green11_18,7);  
71FC:  BCF    52.7
71FE:  BSF    56.7
....................              } 
7200:  BRA    720E
....................              else if((RED_Colour.B18)&&(GREEN_Colour.B18))//Ambian 
7202:  BTFSS  x47.1
7204:  BRA    720E
7206:  BTFSS  x4B.1
7208:  BRA    720E
....................              { 
....................                bit_set(Red11_18,7); bit_set(Green11_18,7) ;  
720A:  BSF    52.7
720C:  BSF    56.7
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B19)//++++++++++++B19+++++++++++++++++++++ 
720E:  BTFSS  x1B.2
7210:  BRA    7218
....................            { 
....................              bit_clear(Green19_20,0); bit_clear(Red19_20,0); 
7212:  BCF    57.0
7214:  BCF    53.0
....................            } 
7216:  BRA    7240
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B19 )&&(GREEN_Colour.B19 ==0 ))//Red 
7218:  BTFSS  x47.2
721A:  BRA    7226
721C:  BTFSC  x4B.2
721E:  BRA    7226
....................              { 
....................                bit_set(Red19_20,0); bit_clear(Green19_20,0); 
7220:  BSF    53.0
7222:  BCF    57.0
....................              } 
7224:  BRA    7240
....................              else if((RED_Colour.B19==0 )&&(GREEN_Colour.B19))//Green 
7226:  BTFSC  x47.2
7228:  BRA    7234
722A:  BTFSS  x4B.2
722C:  BRA    7234
....................              { 
....................                bit_clear(Red19_20,0); bit_set(Green19_20,0);  
722E:  BCF    53.0
7230:  BSF    57.0
....................              } 
7232:  BRA    7240
....................              else if((RED_Colour.B19)&&(GREEN_Colour.B19))//Ambian 
7234:  BTFSS  x47.2
7236:  BRA    7240
7238:  BTFSS  x4B.2
723A:  BRA    7240
....................              { 
....................                bit_set(Red19_20,0); bit_set(Green19_20,0) ;  
723C:  BSF    53.0
723E:  BSF    57.0
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B20)//++++++++++++B20+++++++++++++++++++++ 
7240:  BTFSS  x1B.3
7242:  BRA    724A
....................            { 
....................              bit_clear(Green19_20,1); bit_clear(Red19_20,1); 
7244:  BCF    57.1
7246:  BCF    53.1
....................            } 
7248:  BRA    7272
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B20 )&&(GREEN_Colour.B20 ==0 ))//Red 
724A:  BTFSS  x47.3
724C:  BRA    7258
724E:  BTFSC  x4B.3
7250:  BRA    7258
....................              { 
....................                bit_set(Red19_20,1); bit_clear(Green19_20,1); 
7252:  BSF    53.1
7254:  BCF    57.1
....................              } 
7256:  BRA    7272
....................              else if((RED_Colour.B20==0 )&&(GREEN_Colour.B20))//Green 
7258:  BTFSC  x47.3
725A:  BRA    7266
725C:  BTFSS  x4B.3
725E:  BRA    7266
....................              { 
....................                bit_clear(Red19_20,1); bit_set(Green19_20,1);  
7260:  BCF    53.1
7262:  BSF    57.1
....................              } 
7264:  BRA    7272
....................              else if((RED_Colour.B20)&&(GREEN_Colour.B20))//Ambian 
7266:  BTFSS  x47.3
7268:  BRA    7272
726A:  BTFSS  x4B.3
726C:  BRA    7272
....................              { 
....................                bit_set(Red19_20,1); bit_set(Green19_20,1) ;  
726E:  BSF    53.1
7270:  BSF    57.1
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................           
....................       //}  
....................            
....................          
....................            IO_OUTPUT_A(IO_DEVICE_2, Red1_8); 
7272:  MOVLW  04
7274:  MOVWF  xEF
7276:  MOVFF  50,1F0
727A:  MOVLB  0
727C:  CALL   14C2
....................            IO_OUTPUT_B(IO_DEVICE_2, Red9_10); 
7280:  MOVLW  04
7282:  MOVLB  1
7284:  MOVWF  xEF
7286:  MOVFF  51,1F0
728A:  MOVLB  0
728C:  CALL   14D8
....................                       
....................            IO_OUTPUT_A(IO_DEVICE_3, Green1_8); 
7290:  MOVLW  06
7292:  MOVLB  1
7294:  MOVWF  xEF
7296:  MOVFF  54,1F0
729A:  MOVLB  0
729C:  CALL   14C2
....................            IO_OUTPUT_B(IO_DEVICE_3, Green9_10); 
72A0:  MOVLW  06
72A2:  MOVLB  1
72A4:  MOVWF  xEF
72A6:  MOVFF  55,1F0
72AA:  MOVLB  0
72AC:  CALL   14D8
....................             
....................            IO_OUTPUT_A(IO_DEVICE_5, Red11_18);   
72B0:  MOVLW  0A
72B2:  MOVLB  1
72B4:  MOVWF  xEF
72B6:  MOVFF  52,1F0
72BA:  MOVLB  0
72BC:  CALL   14C2
....................            IO_OUTPUT_B(IO_DEVICE_5, Red19_20); 
72C0:  MOVLW  0A
72C2:  MOVLB  1
72C4:  MOVWF  xEF
72C6:  MOVFF  53,1F0
72CA:  MOVLB  0
72CC:  CALL   14D8
....................                       
....................            IO_OUTPUT_A(IO_DEVICE_4, Green11_18); 
72D0:  MOVLW  08
72D2:  MOVLB  1
72D4:  MOVWF  xEF
72D6:  MOVFF  56,1F0
72DA:  MOVLB  0
72DC:  CALL   14C2
....................            IO_OUTPUT_B(IO_DEVICE_4, Green19_20); 
72E0:  MOVLW  08
72E2:  MOVLB  1
72E4:  MOVWF  xEF
72E6:  MOVFF  57,1F0
72EA:  MOVLB  0
72EC:  CALL   14D8
....................             
....................                                  
....................            //IO_OUTPUT_A(IO_DEVICE_4, Red1_8); //jj test 
....................            //IO_OUTPUT_B(IO_DEVICE_4, Red9_10); //jj test 
....................             
....................            //IO_OUTPUT_A(IO_DEVICE_5, Green1_8);  //jj test 
....................            //IO_OUTPUT_B(IO_DEVICE_5, Green9_10); //jj test 
....................                                             
....................             
....................    } 
72F0:  GOTO   7D2E (RETURN)
....................  
.................... } 
.................... ////////////////////////////////////////////////////////////////// 
.................... void ForceAllAlarm(void) 
.................... { 
....................    if(NoOfPoint >= 10) 
*
402A:  MOVF   63,W
402C:  SUBLW  09
402E:  BC    4070
....................    { 
....................       Inputt.B1 = ~InputType.B1; 
4030:  MOVLB  1
4032:  BCF    x15.0
4034:  BTFSS  x1D.0
4036:  BSF    x15.0
....................       Inputt.B2 = ~InputType.B2; 
4038:  BCF    x15.1
403A:  BTFSS  x1D.1
403C:  BSF    x15.1
....................       Inputt.B3 = ~InputType.B3; 
403E:  BCF    x15.2
4040:  BTFSS  x1D.2
4042:  BSF    x15.2
....................       Inputt.B4 = ~InputType.B4; 
4044:  BCF    x15.3
4046:  BTFSS  x1D.3
4048:  BSF    x15.3
....................       Inputt.B5 = ~InputType.B5; 
404A:  BCF    x15.4
404C:  BTFSS  x1D.4
404E:  BSF    x15.4
....................       Inputt.B6 = ~InputType.B6; 
4050:  BCF    x15.5
4052:  BTFSS  x1D.5
4054:  BSF    x15.5
....................       Inputt.B7 = ~InputType.B7; 
4056:  BCF    x15.6
4058:  BTFSS  x1D.6
405A:  BSF    x15.6
....................       Inputt.B8 = ~InputType.B8; 
405C:  BCF    x15.7
405E:  BTFSS  x1D.7
4060:  BSF    x15.7
....................       Inputt.B9 = ~InputType.B9; 
4062:  BCF    x16.0
4064:  BTFSS  x1E.0
4066:  BSF    x16.0
....................       Inputt.B10 = ~InputType.B10; 
4068:  BCF    x16.1
406A:  BTFSS  x1E.1
406C:  BSF    x16.1
406E:  MOVLB  0
....................    } 
....................    if(NoOfPoint >= 20) 
4070:  MOVF   63,W
4072:  SUBLW  13
4074:  BC    40B6
....................    { 
....................       Inputt.B11 = ~InputType.B11; 
4076:  MOVLB  1
4078:  BCF    x16.2
407A:  BTFSS  x1E.2
407C:  BSF    x16.2
....................       Inputt.B12 = ~InputType.B12; 
407E:  BCF    x16.3
4080:  BTFSS  x1E.3
4082:  BSF    x16.3
....................       Inputt.B13 = ~InputType.B13; 
4084:  BCF    x16.4
4086:  BTFSS  x1E.4
4088:  BSF    x16.4
....................       Inputt.B14 = ~InputType.B14; 
408A:  BCF    x16.5
408C:  BTFSS  x1E.5
408E:  BSF    x16.5
....................       Inputt.B15 = ~InputType.B15; 
4090:  BCF    x16.6
4092:  BTFSS  x1E.6
4094:  BSF    x16.6
....................       Inputt.B16 = ~InputType.B16; 
4096:  BCF    x16.7
4098:  BTFSS  x1E.7
409A:  BSF    x16.7
....................       Inputt.B17 = ~InputType.B11; 
409C:  BCF    x17.0
409E:  BTFSS  x1E.2
40A0:  BSF    x17.0
....................       Inputt.B18 = ~InputType.B12; 
40A2:  BCF    x17.1
40A4:  BTFSS  x1E.3
40A6:  BSF    x17.1
....................       Inputt.B19 = ~InputType.B13; 
40A8:  BCF    x17.2
40AA:  BTFSS  x1E.4
40AC:  BSF    x17.2
....................       Inputt.B20 = ~InputType.B14; 
40AE:  BCF    x17.3
40B0:  BTFSS  x1E.5
40B2:  BSF    x17.3
40B4:  MOVLB  0
....................    } 
....................        
....................  
....................    Ack.B1 = 0; 
40B6:  MOVLB  1
40B8:  BCF    x31.0
....................    Ack.B2 = 0; 
40BA:  BCF    x31.1
....................    Ack.B3 = 0; 
40BC:  BCF    x31.2
....................    Ack.B4 = 0; 
40BE:  BCF    x31.3
....................    Ack.B5 = 0; 
40C0:  BCF    x31.4
....................    Ack.B6 = 0; 
40C2:  BCF    x31.5
....................    Ack.B7 = 0; 
40C4:  BCF    x31.6
....................    Ack.B8 = 0; 
40C6:  BCF    x31.7
....................    Ack.B9 = 0; 
40C8:  BCF    x32.0
....................    Ack.B10 = 0; 
40CA:  BCF    x32.1
....................    Ack.B11 = 0; 
40CC:  BCF    x32.2
....................    Ack.B12 = 0; 
40CE:  BCF    x32.3
....................    Ack.B13 = 0; 
40D0:  BCF    x32.4
....................    Ack.B14 = 0; 
40D2:  BCF    x32.5
....................    Ack.B15 = 0; 
40D4:  BCF    x32.6
....................    Ack.B16 = 0; 
40D6:  BCF    x32.7
....................    Ack.B17 = 0; 
40D8:  BCF    x33.0
....................    Ack.B18 = 0; 
40DA:  BCF    x33.1
....................    Ack.B19 = 0; 
40DC:  BCF    x33.2
....................    Ack.B20 = 0;   
40DE:  BCF    x33.3
40E0:  MOVLB  0
40E2:  GOTO   6E28 (RETURN)
....................     
....................    // Debug   
....................      
.................... } 
....................  
....................  //////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ///////////// Check Test //////////////// 
.................... void check_test(void) 
.................... { 
....................    int8 output_temp[8]; 
....................     
....................    output_temp[0] = Output1_8; 
*
6D54:  MOVFF  32,1E7
....................    output_temp[1] = output9_16; 
6D58:  MOVFF  33,1E8
....................  
....................  
....................        if((Input(Ptest) == 0 && Test == 0)|| AutoTestFlag == 1) delay_ms(50); 
6D5C:  BSF    F94.2
6D5E:  BTFSC  F82.2
6D60:  BRA    6D66
6D62:  BTFSS  1A.6
6D64:  BRA    6D6A
6D66:  BTFSS  1A.4
6D68:  BRA    6D76
6D6A:  MOVLW  32
6D6C:  MOVLB  1
6D6E:  MOVWF  xEF
6D70:  MOVLB  0
6D72:  CALL   05BE
....................        if((Input(Ptest) == 0 && Test == 0)|| AutoTestFlag == 1) 
6D76:  BSF    F94.2
6D78:  BTFSC  F82.2
6D7A:  BRA    6D80
6D7C:  BTFSS  1A.6
6D7E:  BRA    6D84
6D80:  BTFSS  1A.4
6D82:  BRA    6E10
....................        { 
....................            if((Input(Ptest) == 0 && Test == 0)|| AutoTestFlag ==1) 
6D84:  BSF    F94.2
6D86:  BTFSC  F82.2
6D88:  BRA    6D8E
6D8A:  BTFSS  1A.6
6D8C:  BRA    6D92
6D8E:  BTFSS  1A.4
6D90:  BRA    6E0E
....................            { 
....................              restart_wdt(); 
6D92:  CLRWDT
....................              if(T_test == 0) T_test = 0x06;    //3 second for time base 500 ms 
6D94:  MOVF   2F,F
6D96:  BNZ   6D9C
6D98:  MOVLW  06
6D9A:  MOVWF  2F
....................               Test = 1; 
6D9C:  BSF    1A.6
....................               //if(NoOfPoint >= 16) 
....................              // { 
....................               
....................                  IO_OUTPUT_A(IO_DEVICE_2, 0xFF); 
6D9E:  MOVLW  04
6DA0:  MOVLB  1
6DA2:  MOVWF  xEF
6DA4:  SETF   xF0
6DA6:  MOVLB  0
6DA8:  CALL   14C2
....................                  IO_OUTPUT_B(IO_DEVICE_2, 0xFF); 
6DAC:  MOVLW  04
6DAE:  MOVLB  1
6DB0:  MOVWF  xEF
6DB2:  SETF   xF0
6DB4:  MOVLB  0
6DB6:  CALL   14D8
....................                              
....................                  IO_OUTPUT_A(IO_DEVICE_3, 0xFF); 
6DBA:  MOVLW  06
6DBC:  MOVLB  1
6DBE:  MOVWF  xEF
6DC0:  SETF   xF0
6DC2:  MOVLB  0
6DC4:  CALL   14C2
....................                  IO_OUTPUT_B(IO_DEVICE_3, 0xFF); 
6DC8:  MOVLW  06
6DCA:  MOVLB  1
6DCC:  MOVWF  xEF
6DCE:  SETF   xF0
6DD0:  MOVLB  0
6DD2:  CALL   14D8
....................                   
....................                  IO_OUTPUT_A(IO_DEVICE_4, 0xFF); 
6DD6:  MOVLW  08
6DD8:  MOVLB  1
6DDA:  MOVWF  xEF
6DDC:  SETF   xF0
6DDE:  MOVLB  0
6DE0:  CALL   14C2
....................                  IO_OUTPUT_B(IO_DEVICE_4, 0xFF); 
6DE4:  MOVLW  08
6DE6:  MOVLB  1
6DE8:  MOVWF  xEF
6DEA:  SETF   xF0
6DEC:  MOVLB  0
6DEE:  CALL   14D8
....................                             
....................                  IO_OUTPUT_A(IO_DEVICE_5, 0xFF); 
6DF2:  MOVLW  0A
6DF4:  MOVLB  1
6DF6:  MOVWF  xEF
6DF8:  SETF   xF0
6DFA:  MOVLB  0
6DFC:  CALL   14C2
....................                  IO_OUTPUT_B(IO_DEVICE_5, 0xFF); 
6E00:  MOVLW  0A
6E02:  MOVLB  1
6E04:  MOVWF  xEF
6E06:  SETF   xF0
6E08:  MOVLB  0
6E0A:  CALL   14D8
....................                  //PCF8575_write(0xFF,0x00,Input1_8_Wr_addr); 
....................                  //PCF8575_write(0xFF,0x00,Input9_16_Wr_addr); 
....................                  //IO_OUTPUT_B(IO_DEVICE_0, 0x00); 
....................                  //IO_OUTPUT_B(IO_DEVICE_1, 0x00); 
....................              // } 
....................               
....................            } 
....................        } 
6E0E:  BRA    6E20
....................        else if(Input(Ptest) == 1 && Test == 1) 
6E10:  BSF    F94.2
6E12:  BTFSS  F82.2
6E14:  BRA    6E20
6E16:  BTFSS  1A.6
6E18:  BRA    6E20
....................        { 
....................            T_test = 0x00; 
6E1A:  CLRF   2F
....................            Test = 0; 
6E1C:  BCF    1A.6
....................            Test_fault = 0; 
6E1E:  BCF    1A.5
....................        } 
....................  
....................        if(Test_fault == 1) 
6E20:  BTFSS  1A.5
6E22:  BRA    6E36
....................        { 
....................           ForceAllAlarm(); 
6E24:  GOTO   402A
....................           Anal_Function(); 
6E28:  CALL   4A4E
....................           // jj 26/7/60 
....................           if(Input(Ptest) == 1) 
6E2C:  BSF    F94.2
6E2E:  BTFSS  F82.2
6E30:  BRA    6E34
....................           { 
....................             Test_fault = 0; 
6E32:  BCF    1A.5
....................           } 
....................        } 
6E34:  BRA    6E4C
....................        else if(Input(Ptest) == 1 && Test == 1) 
6E36:  BSF    F94.2
6E38:  BTFSS  F82.2
6E3A:  BRA    6E4C
6E3C:  BTFSS  1A.6
6E3E:  BRA    6E4C
....................        { 
....................           if(NoOfPoint >= 16) 
6E40:  MOVF   63,W
6E42:  SUBLW  0F
6E44:  BC    6E46
....................           { 
....................              //PCF8575_write(0xFF,output_temp[0],Input1_8_Wr_addr); 
....................              //PCF8575_write(0xFF,output_temp[1],Input9_16_Wr_addr); 
....................              //IO_OUTPUT_B(IO_DEVICE_0, output_temp[0]); 
....................              //IO_OUTPUT_B(IO_DEVICE_1, output_temp[1]);  
....................           } 
....................            
....................  
....................           T_test = 0x00; 
6E46:  CLRF   2F
....................           Test = 0; 
6E48:  BCF    1A.6
....................           Test_fault = 0; 
6E4A:  BCF    1A.5
....................        } 
6E4C:  GOTO   7D18 (RETURN)
.................... } 
....................  
....................  
.................... /////////////// Check acknowledge //////////////////////////// 
....................  
.................... void check_ack(void) 
.................... { 
....................  
....................    if((Input(Pack) == 0 && Ack_F == 0) || AutoAckFlag == 1) delay_ms(50); //Acknowledge function 
*
2516:  BSF    F94.0
2518:  BTFSC  F82.0
251A:  BRA    2520
251C:  BTFSS  1A.7
251E:  BRA    2524
2520:  BTFSS  1A.2
2522:  BRA    2530
2524:  MOVLW  32
2526:  MOVLB  1
2528:  MOVWF  xEF
252A:  MOVLB  0
252C:  CALL   05BE
....................    if((Input(Pack) == 0 && Ack_F == 0) || AutoAckFlag == 1) 
2530:  BSF    F94.0
2532:  BTFSC  F82.0
2534:  BRA    253A
2536:  BTFSS  1A.7
2538:  BRA    253E
253A:  BTFSS  1A.2
253C:  BRA    2692
....................    { 
....................             AutoAckFlag = 0; 
253E:  BCF    1A.2
....................             AutoAckDelayTime = 0x00; 
2540:  CLRF   1D
....................        
....................                //if(In.B1 == 1 || ((Inputt.B1 ^ InputType.B1) == 1)) 
....................            if((In.B1 == 1 )||(In2.B1 == 1 )) 
2542:  MOVLB  1
2544:  BTFSC  x35.0
2546:  BRA    254C
2548:  BTFSS  x39.0
254A:  BRA    2554
....................            { 
....................              Ack.B1 = 1; 
254C:  BSF    x31.0
....................              In.B1 = 0; 
254E:  BCF    x35.0
....................              In2.B1 = 0;      //for auto reset 
2550:  BCF    x39.0
....................              Output.B1 = 0; 
2552:  BCF    x19.0
....................            } 
....................            //if(In.B2 == 1 || ((Inputt.B2 ^ InputType.B2) == 1)) 
....................            if((In.B2 == 1)||(In2.B2 == 1)) 
2554:  BTFSC  x35.1
2556:  BRA    255C
2558:  BTFSS  x39.1
255A:  BRA    2564
....................            { 
....................              Ack.B2 = 1; 
255C:  BSF    x31.1
....................              In.B2 = 0; 
255E:  BCF    x35.1
....................              In2.B2 = 0;      //for auto reset 
2560:  BCF    x39.1
....................              Output.B2 = 0; 
2562:  BCF    x19.1
....................            } 
....................            //if(In.B3 == 1 || ((Inputt.B3 ^ InputType.B3) == 1)) 
....................            if((In.B3 == 1)||(In2.B3 == 1)) 
2564:  BTFSC  x35.2
2566:  BRA    256C
2568:  BTFSS  x39.2
256A:  BRA    2574
....................            { 
....................              Ack.B3 = 1; 
256C:  BSF    x31.2
....................              In.B3 = 0; 
256E:  BCF    x35.2
....................              In2.B3 = 0;      //for auto reset 
2570:  BCF    x39.2
....................              Output.B3 = 0; 
2572:  BCF    x19.2
....................            } 
....................            //if(In.B4 == 1 || ((Inputt.B4 ^ InputType.B4) == 1)) 
....................            if((In.B4 == 1)||(In2.B4 == 1)) 
2574:  BTFSC  x35.3
2576:  BRA    257C
2578:  BTFSS  x39.3
257A:  BRA    2584
....................            { 
....................              Ack.B4 = 1; 
257C:  BSF    x31.3
....................              In.B4 = 0; 
257E:  BCF    x35.3
....................              In2.B4 = 0;      //for auto reset 
2580:  BCF    x39.3
....................              Output.B4 = 0; 
2582:  BCF    x19.3
....................            } 
....................            //if(In.B5 == 1 || ((Inputt.B5 ^ InputType.B5) == 1)) 
....................            if((In.B5 == 1)||(In2.B5 == 1)) 
2584:  BTFSC  x35.4
2586:  BRA    258C
2588:  BTFSS  x39.4
258A:  BRA    2594
....................            { 
....................              Ack.B5 = 1; 
258C:  BSF    x31.4
....................              In.B5 = 0; 
258E:  BCF    x35.4
....................              In2.B5 = 0;      //for auto reset 
2590:  BCF    x39.4
....................              Output.B5 = 0; 
2592:  BCF    x19.4
....................            } 
....................            //if(In.B6 == 1 || ((Inputt.B6 ^ InputType.B6) == 1)) 
....................            if((In.B6 == 1 )||(In2.B6 == 1 )) 
2594:  BTFSC  x35.5
2596:  BRA    259C
2598:  BTFSS  x39.5
259A:  BRA    25A4
....................            { 
....................              Ack.B6 = 1; 
259C:  BSF    x31.5
....................              In.B6 = 0; 
259E:  BCF    x35.5
....................              In2.B6 = 0;      //for auto reset 
25A0:  BCF    x39.5
....................              Output.B6 = 0; 
25A2:  BCF    x19.5
....................            } 
....................            //if(In.B7 == 1 || ((Inputt.B7 ^ InputType.B7) == 1)) 
....................            if((In.B7 == 1 )||(In2.B7 == 1 )) 
25A4:  BTFSC  x35.6
25A6:  BRA    25AC
25A8:  BTFSS  x39.6
25AA:  BRA    25B4
....................            { 
....................              Ack.B7 = 1; 
25AC:  BSF    x31.6
....................              In.B7 = 0; 
25AE:  BCF    x35.6
....................              In2.B7 = 0;      //for auto reset 
25B0:  BCF    x39.6
....................              Output.B7 = 0; 
25B2:  BCF    x19.6
....................            } 
....................            //if(In.B8 == 1 || ((Inputt.B8 ^ InputType.B8) == 1)) 
....................            if((In.B8 == 1 )||(In2.B8 == 1 )) 
25B4:  BTFSC  x35.7
25B6:  BRA    25BC
25B8:  BTFSS  x39.7
25BA:  BRA    25C4
....................            { 
....................              Ack.B8 = 1; 
25BC:  BSF    x31.7
....................              In.B8 = 0; 
25BE:  BCF    x35.7
....................              In2.B8 = 0;      //for auto reset 
25C0:  BCF    x39.7
....................              Output.B8 = 0; 
25C2:  BCF    x19.7
....................            } 
....................           // if(In.B9 == 1 || ((Inputt.B9 ^ InputType.B9) == 1)) 
....................            if((In.B9 == 1 )||(In2.B9 == 1 )) 
25C4:  BTFSC  x36.0
25C6:  BRA    25CC
25C8:  BTFSS  x3A.0
25CA:  BRA    25D4
....................            { 
....................              Ack.B9 = 1; 
25CC:  BSF    x32.0
....................              In.B9 = 0; 
25CE:  BCF    x36.0
....................              In2.B9 = 0;      //for auto reset 
25D0:  BCF    x3A.0
....................              Output.B9 = 0; 
25D2:  BCF    x1A.0
....................            } 
....................            //if(In.B10 == 1 || ((Inputt.B10 ^ InputType.B10) == 1)) 
....................            if((In.B10 == 1)||(In2.B10 == 1)) 
25D4:  BTFSC  x36.1
25D6:  BRA    25DC
25D8:  BTFSS  x3A.1
25DA:  BRA    25E4
....................            { 
....................              Ack.B10 = 1; 
25DC:  BSF    x32.1
....................              In.B10 = 0; 
25DE:  BCF    x36.1
....................              In2.B10 = 0;      //for auto reset 
25E0:  BCF    x3A.1
....................              Output.B10 = 0; 
25E2:  BCF    x1A.1
....................            } 
....................            //if(In.B11 == 1 || ((Inputt.B11 ^ InputType.B11) == 1)) 
....................            if((In.B11 == 1)||(In2.B11 == 1)) 
25E4:  BTFSC  x36.2
25E6:  BRA    25EC
25E8:  BTFSS  x3A.2
25EA:  BRA    25F4
....................            { 
....................              Ack.B11 = 1; 
25EC:  BSF    x32.2
....................              In.B11 = 0; 
25EE:  BCF    x36.2
....................              In2.B11 = 0;      //for auto reset 
25F0:  BCF    x3A.2
....................              Output.B11 = 0; 
25F2:  BCF    x1A.2
....................            } 
....................            //if(In.B12 == 1 || ((Inputt.B12 ^ InputType.B12) == 1)) 
....................            if((In.B12 == 1)||(In2.B12 == 1)) 
25F4:  BTFSC  x36.3
25F6:  BRA    25FC
25F8:  BTFSS  x3A.3
25FA:  BRA    2604
....................            { 
....................              Ack.B12 = 1; 
25FC:  BSF    x32.3
....................              In.B12 = 0; 
25FE:  BCF    x36.3
....................              In2.B12 = 0;      //for auto reset 
2600:  BCF    x3A.3
....................              Output.B12 = 0; 
2602:  BCF    x1A.3
....................            } 
....................            //if(In.B13 == 1 || ((Inputt.B13 ^ InputType.B13) == 1)) 
....................            if((In.B13 == 1 )||(In2.B13 == 1 )) 
2604:  BTFSC  x36.4
2606:  BRA    260C
2608:  BTFSS  x3A.4
260A:  BRA    2614
....................            { 
....................              Ack.B13 = 1; 
260C:  BSF    x32.4
....................              In.B13 = 0; 
260E:  BCF    x36.4
....................              In2.B13 = 0;      //for auto reset 
2610:  BCF    x3A.4
....................              Output.B13 = 0; 
2612:  BCF    x1A.4
....................            } 
....................            //if(In.B14 == 1 || ((Inputt.B14 ^ InputType.B14) == 1)) 
....................            if((In.B14 == 1)||(In2.B14 == 1)) 
2614:  BTFSC  x36.5
2616:  BRA    261C
2618:  BTFSS  x3A.5
261A:  BRA    2624
....................            { 
....................              Ack.B14 = 1; 
261C:  BSF    x32.5
....................              In.B14 = 0; 
261E:  BCF    x36.5
....................              In2.B14 = 0;      //for auto reset 
2620:  BCF    x3A.5
....................              Output.B14 = 0; 
2622:  BCF    x1A.5
....................            } 
....................            //if(In.B15 == 1 || ((Inputt.B15 ^ InputType.B15) == 1)) 
....................            if((In.B15 == 1)||(In2.B15 == 1)) 
2624:  BTFSC  x36.6
2626:  BRA    262C
2628:  BTFSS  x3A.6
262A:  BRA    2634
....................            { 
....................              Ack.B15 = 1; 
262C:  BSF    x32.6
....................              In.B15 = 0; 
262E:  BCF    x36.6
....................              In2.B15 = 0;      //for auto reset 
2630:  BCF    x3A.6
....................              Output.B15 = 0; 
2632:  BCF    x1A.6
....................            } 
....................            //if(In.B16 == 1 || ((Inputt.B16 ^ InputType.B16) == 1)) 
....................            if((In.B16 == 1)||(In2.B16 == 1)) 
2634:  BTFSC  x36.7
2636:  BRA    263C
2638:  BTFSS  x3A.7
263A:  BRA    2644
....................            { 
....................              Ack.B16 = 1; 
263C:  BSF    x32.7
....................              In.B16 = 0; 
263E:  BCF    x36.7
....................              In2.B16 = 0;      //for auto reset 
2640:  BCF    x3A.7
....................              Output.B16 = 0; 
2642:  BCF    x1A.7
....................            } 
....................          
....................            //if(In.B17 == 1 || ((Inputt.B17 ^ InputType.B17) == 1)) 
....................            if((In.B17 == 1)||(In2.B17 == 1)) 
2644:  BTFSC  x37.0
2646:  BRA    264C
2648:  BTFSS  x3B.0
264A:  BRA    2654
....................            { 
....................              Ack.B17 = 1; 
264C:  BSF    x33.0
....................              In.B17 = 0; 
264E:  BCF    x37.0
....................              In2.B17 = 0;      //for auto reset 
2650:  BCF    x3B.0
....................              Output.B17 = 0; 
2652:  BCF    x1B.0
....................            } 
....................            //if(In.B18 == 1 || ((Inputt.B18 ^ InputType.B18) == 1)) 
....................            if((In.B18 == 1)||(In2.B18 == 1)) 
2654:  BTFSC  x37.1
2656:  BRA    265C
2658:  BTFSS  x3B.1
265A:  BRA    2664
....................            { 
....................              Ack.B18 = 1; 
265C:  BSF    x33.1
....................              In.B18 = 0; 
265E:  BCF    x37.1
....................              In2.B18 = 0;      //for auto reset 
2660:  BCF    x3B.1
....................              Output.B18 = 0; 
2662:  BCF    x1B.1
....................            } 
....................            //if(In.B19 == 1 || ((Inputt.B19 ^ InputType.B19) == 1)) 
....................            if((In.B19 == 1)||(In2.B19 == 1)) 
2664:  BTFSC  x37.2
2666:  BRA    266C
2668:  BTFSS  x3B.2
266A:  BRA    2674
....................            { 
....................              Ack.B19 = 1; 
266C:  BSF    x33.2
....................              In.B19 = 0; 
266E:  BCF    x37.2
....................              In2.B19 = 0;      //for auto reset 
2670:  BCF    x3B.2
....................              Output.B19 = 0; 
2672:  BCF    x1B.2
....................            } 
....................            if((In.B20 == 1)||(In2.B20 == 1)) 
2674:  BTFSC  x37.3
2676:  BRA    267C
2678:  BTFSS  x3B.3
267A:  BRA    2684
....................            { 
....................              Ack.B20 = 1; 
267C:  BSF    x33.3
....................              In.B20 = 0; 
267E:  BCF    x37.3
....................              In2.B20 = 0;      //for auto reset 
2680:  BCF    x3B.3
....................              Output.B20 = 0; 
2682:  BCF    x1B.3
....................            } 
....................            /////////////////////////////////////////////////////////// 
....................            
....................        
....................        
....................             Ack_F = 1; 
2684:  BSF    1A.7
....................             output_bit(Pbuzzer,OffRelay);   //Buzzer 
2686:  BCF    F89.4
2688:  BCF    F92.4
....................             output_bit(Pbell,OffRelay);     //Bell 
268A:  BCF    F89.3
268C:  BCF    F92.3
....................    } 
268E:  BRA    26A0
2690:  MOVLB  0
....................    else if(Input(Pack) == 1 && Ack_F == 1) 
2692:  BSF    F94.0
2694:  BTFSS  F82.0
2696:  BRA    269E
2698:  BTFSS  1A.7
269A:  BRA    269E
....................    { 
....................       Ack_F = 0; 
269C:  BCF    1A.7
269E:  MOVLB  1
....................    } 
26A0:  MOVLB  0
26A2:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... ///////////////////// Check Reset /////////////////////////////////// 
.................... void check_reset(void) 
.................... { 
....................     if((Input(Preset) == 0 && Reset_F == 0)|| AutoResetFlag ==1) delay_ms(50); 
26A4:  BSF    F94.1
26A6:  BTFSC  F82.1
26A8:  BRA    26AE
26AA:  BTFSS  30.0
26AC:  BRA    26B2
26AE:  BTFSS  1A.3
26B0:  BRA    26BE
26B2:  MOVLW  32
26B4:  MOVLB  1
26B6:  MOVWF  xEF
26B8:  MOVLB  0
26BA:  CALL   05BE
....................     if((Input(Preset) == 0 && Reset_F == 0)|| AutoResetFlag ==1) 
26BE:  BSF    F94.1
26C0:  BTFSC  F82.1
26C2:  BRA    26C8
26C4:  BTFSS  30.0
26C6:  BRA    26CC
26C8:  BTFSS  1A.3
26CA:  BRA    28B6
....................     { 
....................        AutoResetFlag = 0; 
26CC:  BCF    1A.3
....................         
....................        if((Inputt.B1 ^ InputType.B1) == 0 && In.B1 == 0) Output.B1 = 1; 
26CE:  MOVLW  00
26D0:  MOVLB  1
26D2:  BTFSC  x15.0
26D4:  MOVLW  01
26D6:  MOVWF  xE8
26D8:  MOVLW  00
26DA:  BTFSC  x1D.0
26DC:  MOVLW  01
26DE:  XORWF  xE8,W
26E0:  BNZ   26E8
26E2:  BTFSC  x35.0
26E4:  BRA    26E8
26E6:  BSF    x19.0
....................        if((Inputt.B2 ^ InputType.B2) == 0 && In.B2 == 0) Output.B2 = 1; 
26E8:  MOVLW  00
26EA:  BTFSC  x15.1
26EC:  MOVLW  01
26EE:  MOVWF  xE8
26F0:  MOVLW  00
26F2:  BTFSC  x1D.1
26F4:  MOVLW  01
26F6:  XORWF  xE8,W
26F8:  BNZ   2700
26FA:  BTFSC  x35.1
26FC:  BRA    2700
26FE:  BSF    x19.1
....................        if((Inputt.B3 ^ InputType.B3) == 0 && In.B3 == 0) Output.B3 = 1; 
2700:  MOVLW  00
2702:  BTFSC  x15.2
2704:  MOVLW  01
2706:  MOVWF  xE8
2708:  MOVLW  00
270A:  BTFSC  x1D.2
270C:  MOVLW  01
270E:  XORWF  xE8,W
2710:  BNZ   2718
2712:  BTFSC  x35.2
2714:  BRA    2718
2716:  BSF    x19.2
....................        if((Inputt.B4 ^ InputType.B4) == 0 && In.B4 == 0) Output.B4 = 1; 
2718:  MOVLW  00
271A:  BTFSC  x15.3
271C:  MOVLW  01
271E:  MOVWF  xE8
2720:  MOVLW  00
2722:  BTFSC  x1D.3
2724:  MOVLW  01
2726:  XORWF  xE8,W
2728:  BNZ   2730
272A:  BTFSC  x35.3
272C:  BRA    2730
272E:  BSF    x19.3
....................        if((Inputt.B5 ^ InputType.B5) == 0 && In.B5 == 0) Output.B5 = 1; 
2730:  MOVLW  00
2732:  BTFSC  x15.4
2734:  MOVLW  01
2736:  MOVWF  xE8
2738:  MOVLW  00
273A:  BTFSC  x1D.4
273C:  MOVLW  01
273E:  XORWF  xE8,W
2740:  BNZ   2748
2742:  BTFSC  x35.4
2744:  BRA    2748
2746:  BSF    x19.4
....................        if((Inputt.B6 ^ InputType.B6) == 0 && In.B6 == 0) Output.B6 = 1; 
2748:  MOVLW  00
274A:  BTFSC  x15.5
274C:  MOVLW  01
274E:  MOVWF  xE8
2750:  MOVLW  00
2752:  BTFSC  x1D.5
2754:  MOVLW  01
2756:  XORWF  xE8,W
2758:  BNZ   2760
275A:  BTFSC  x35.5
275C:  BRA    2760
275E:  BSF    x19.5
....................        if((Inputt.B7 ^ InputType.B7) == 0 && In.B7 == 0) Output.B7 = 1; 
2760:  MOVLW  00
2762:  BTFSC  x15.6
2764:  MOVLW  01
2766:  MOVWF  xE8
2768:  MOVLW  00
276A:  BTFSC  x1D.6
276C:  MOVLW  01
276E:  XORWF  xE8,W
2770:  BNZ   2778
2772:  BTFSC  x35.6
2774:  BRA    2778
2776:  BSF    x19.6
....................        if((Inputt.B8 ^ InputType.B8) == 0 && In.B8 == 0) Output.B8 = 1; 
2778:  MOVLW  00
277A:  BTFSC  x15.7
277C:  MOVLW  01
277E:  MOVWF  xE8
2780:  MOVLW  00
2782:  BTFSC  x1D.7
2784:  MOVLW  01
2786:  XORWF  xE8,W
2788:  BNZ   2790
278A:  BTFSC  x35.7
278C:  BRA    2790
278E:  BSF    x19.7
....................        if((Inputt.B9 ^ InputType.B9) == 0 && In.B9 == 0) Output.B9 = 1; 
2790:  MOVLW  00
2792:  BTFSC  x16.0
2794:  MOVLW  01
2796:  MOVWF  xE8
2798:  MOVLW  00
279A:  BTFSC  x1E.0
279C:  MOVLW  01
279E:  XORWF  xE8,W
27A0:  BNZ   27A8
27A2:  BTFSC  x36.0
27A4:  BRA    27A8
27A6:  BSF    x1A.0
....................        if((Inputt.B10 ^ InputType.B10) == 0 && In.B10 == 0) Output.B10 = 1; 
27A8:  MOVLW  00
27AA:  BTFSC  x16.1
27AC:  MOVLW  01
27AE:  MOVWF  xE8
27B0:  MOVLW  00
27B2:  BTFSC  x1E.1
27B4:  MOVLW  01
27B6:  XORWF  xE8,W
27B8:  BNZ   27C0
27BA:  BTFSC  x36.1
27BC:  BRA    27C0
27BE:  BSF    x1A.1
....................        if((Inputt.B11 ^ InputType.B11) == 0 && In.B11 == 0) Output.B11 = 1; 
27C0:  MOVLW  00
27C2:  BTFSC  x16.2
27C4:  MOVLW  01
27C6:  MOVWF  xE8
27C8:  MOVLW  00
27CA:  BTFSC  x1E.2
27CC:  MOVLW  01
27CE:  XORWF  xE8,W
27D0:  BNZ   27D8
27D2:  BTFSC  x36.2
27D4:  BRA    27D8
27D6:  BSF    x1A.2
....................        if((Inputt.B12 ^ InputType.B12) == 0 && In.B12 == 0) Output.B12 = 1; 
27D8:  MOVLW  00
27DA:  BTFSC  x16.3
27DC:  MOVLW  01
27DE:  MOVWF  xE8
27E0:  MOVLW  00
27E2:  BTFSC  x1E.3
27E4:  MOVLW  01
27E6:  XORWF  xE8,W
27E8:  BNZ   27F0
27EA:  BTFSC  x36.3
27EC:  BRA    27F0
27EE:  BSF    x1A.3
....................        if((Inputt.B13 ^ InputType.B13) == 0 && In.B13 == 0) Output.B13 = 1; 
27F0:  MOVLW  00
27F2:  BTFSC  x16.4
27F4:  MOVLW  01
27F6:  MOVWF  xE8
27F8:  MOVLW  00
27FA:  BTFSC  x1E.4
27FC:  MOVLW  01
27FE:  XORWF  xE8,W
2800:  BNZ   2808
2802:  BTFSC  x36.4
2804:  BRA    2808
2806:  BSF    x1A.4
....................        if((Inputt.B14 ^ InputType.B14) == 0 && In.B14 == 0) Output.B14 = 1; 
2808:  MOVLW  00
280A:  BTFSC  x16.5
280C:  MOVLW  01
280E:  MOVWF  xE8
2810:  MOVLW  00
2812:  BTFSC  x1E.5
2814:  MOVLW  01
2816:  XORWF  xE8,W
2818:  BNZ   2820
281A:  BTFSC  x36.5
281C:  BRA    2820
281E:  BSF    x1A.5
....................        if((Inputt.B15 ^ InputType.B15) == 0 && In.B15 == 0) Output.B15 = 1; 
2820:  MOVLW  00
2822:  BTFSC  x16.6
2824:  MOVLW  01
2826:  MOVWF  xE8
2828:  MOVLW  00
282A:  BTFSC  x1E.6
282C:  MOVLW  01
282E:  XORWF  xE8,W
2830:  BNZ   2838
2832:  BTFSC  x36.6
2834:  BRA    2838
2836:  BSF    x1A.6
....................        if((Inputt.B16 ^ InputType.B16) == 0 && In.B16 == 0) Output.B16 = 1; 
2838:  MOVLW  00
283A:  BTFSC  x16.7
283C:  MOVLW  01
283E:  MOVWF  xE8
2840:  MOVLW  00
2842:  BTFSC  x1E.7
2844:  MOVLW  01
2846:  XORWF  xE8,W
2848:  BNZ   2850
284A:  BTFSC  x36.7
284C:  BRA    2850
284E:  BSF    x1A.7
....................        if((Inputt.B17 ^ InputType.B17) == 0 && In.B17 == 0) Output.B17 = 1; 
2850:  MOVLW  00
2852:  BTFSC  x17.0
2854:  MOVLW  01
2856:  MOVWF  xE8
2858:  MOVLW  00
285A:  BTFSC  x1F.0
285C:  MOVLW  01
285E:  XORWF  xE8,W
2860:  BNZ   2868
2862:  BTFSC  x37.0
2864:  BRA    2868
2866:  BSF    x1B.0
....................        if((Inputt.B18 ^ InputType.B18) == 0 && In.B18 == 0) Output.B18 = 1; 
2868:  MOVLW  00
286A:  BTFSC  x17.1
286C:  MOVLW  01
286E:  MOVWF  xE8
2870:  MOVLW  00
2872:  BTFSC  x1F.1
2874:  MOVLW  01
2876:  XORWF  xE8,W
2878:  BNZ   2880
287A:  BTFSC  x37.1
287C:  BRA    2880
287E:  BSF    x1B.1
....................        if((Inputt.B19 ^ InputType.B19) == 0 && In.B19 == 0) Output.B19 = 1; 
2880:  MOVLW  00
2882:  BTFSC  x17.2
2884:  MOVLW  01
2886:  MOVWF  xE8
2888:  MOVLW  00
288A:  BTFSC  x1F.2
288C:  MOVLW  01
288E:  XORWF  xE8,W
2890:  BNZ   2898
2892:  BTFSC  x37.2
2894:  BRA    2898
2896:  BSF    x1B.2
....................        if((Inputt.B20 ^ InputType.B20) == 0 && In.B20 == 0) Output.B20 = 1; 
2898:  MOVLW  00
289A:  BTFSC  x17.3
289C:  MOVLW  01
289E:  MOVWF  xE8
28A0:  MOVLW  00
28A2:  BTFSC  x1F.3
28A4:  MOVLW  01
28A6:  XORWF  xE8,W
28A8:  BNZ   28B0
28AA:  BTFSC  x37.3
28AC:  BRA    28B0
28AE:  BSF    x1B.3
....................         
....................  
....................        Reset_F = 1; 
28B0:  BSF    30.0
....................     } 
28B2:  BRA    28C4
28B4:  MOVLB  0
....................     else if(Input(Preset) == 1 && Reset_F == 1) 
28B6:  BSF    F94.1
28B8:  BTFSS  F82.1
28BA:  BRA    28C2
28BC:  BTFSS  30.0
28BE:  BRA    28C2
....................     { 
....................        Reset_F = 0; 
28C0:  BCF    30.0
28C2:  MOVLB  1
....................     } 
28C4:  MOVLB  0
28C6:  RETURN 0
.................... } 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///////////////////////Check Auto Reset function /////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... int1 CheckAutoReset(unsigned char DatType) 
.................... { 
....................    int1 check;     /// "1" = true  //Other Alarm active or not "ACK" 
....................  
....................    if(DatType == 0x01) // Buzzer 
*
40E6:  MOVLB  1
40E8:  DECFSZ xEF,W
40EA:  BRA    4594
....................    { 
....................       check = (In.B1 | In2.B1) & ~Ack.B1 & (OutputType.B1 | OutputBoth.B1); 
40EC:  MOVLW  00
40EE:  BTFSC  x35.0
40F0:  MOVLW  01
40F2:  MOVWF  xF2
40F4:  MOVLW  00
40F6:  BTFSC  x39.0
40F8:  MOVLW  01
40FA:  IORWF  xF2,W
40FC:  MOVWF  xF1
40FE:  MOVLW  00
4100:  BTFSS  x31.0
4102:  MOVLW  01
4104:  ANDWF  xF1,F
4106:  MOVLW  00
4108:  BTFSC  x25.0
410A:  MOVLW  01
410C:  MOVWF  xF4
410E:  MOVLW  00
4110:  BTFSC  x29.0
4112:  MOVLW  01
4114:  IORWF  xF4,W
4116:  ANDWF  xF1,W
4118:  BCF    xF0.0
411A:  BTFSC  FE8.0
411C:  BSF    xF0.0
....................       check = check | ((In.B2 | In2.B2) & ~Ack.B2 & (OutputType.B2 | OutputBoth.B2)); 
411E:  MOVLW  00
4120:  BTFSC  xF0.0
4122:  MOVLW  01
4124:  MOVWF  xF1
4126:  MOVLW  00
4128:  BTFSC  x35.1
412A:  MOVLW  01
412C:  MOVWF  xF3
412E:  MOVLW  00
4130:  BTFSC  x39.1
4132:  MOVLW  01
4134:  IORWF  xF3,W
4136:  MOVWF  xF2
4138:  MOVLW  00
413A:  BTFSS  x31.1
413C:  MOVLW  01
413E:  ANDWF  xF2,F
4140:  MOVLW  00
4142:  BTFSC  x25.1
4144:  MOVLW  01
4146:  MOVWF  xF5
4148:  MOVLW  00
414A:  BTFSC  x29.1
414C:  MOVLW  01
414E:  IORWF  xF5,W
4150:  ANDWF  xF2,W
4152:  IORWF  xF1,W
4154:  BCF    xF0.0
4156:  BTFSC  FE8.0
4158:  BSF    xF0.0
....................       check = check | ((In.B3 | In2.B3) & ~Ack.B3 & (OutputType.B3 | OutputBoth.B3)); 
415A:  MOVLW  00
415C:  BTFSC  xF0.0
415E:  MOVLW  01
4160:  MOVWF  xF1
4162:  MOVLW  00
4164:  BTFSC  x35.2
4166:  MOVLW  01
4168:  MOVWF  xF3
416A:  MOVLW  00
416C:  BTFSC  x39.2
416E:  MOVLW  01
4170:  IORWF  xF3,W
4172:  MOVWF  xF2
4174:  MOVLW  00
4176:  BTFSS  x31.2
4178:  MOVLW  01
417A:  ANDWF  xF2,F
417C:  MOVLW  00
417E:  BTFSC  x25.2
4180:  MOVLW  01
4182:  MOVWF  xF5
4184:  MOVLW  00
4186:  BTFSC  x29.2
4188:  MOVLW  01
418A:  IORWF  xF5,W
418C:  ANDWF  xF2,W
418E:  IORWF  xF1,W
4190:  BCF    xF0.0
4192:  BTFSC  FE8.0
4194:  BSF    xF0.0
....................       check = check | ((In.B4 | In2.B4) & ~Ack.B4 & (OutputType.B4 | OutputBoth.B4)); 
4196:  MOVLW  00
4198:  BTFSC  xF0.0
419A:  MOVLW  01
419C:  MOVWF  xF1
419E:  MOVLW  00
41A0:  BTFSC  x35.3
41A2:  MOVLW  01
41A4:  MOVWF  xF3
41A6:  MOVLW  00
41A8:  BTFSC  x39.3
41AA:  MOVLW  01
41AC:  IORWF  xF3,W
41AE:  MOVWF  xF2
41B0:  MOVLW  00
41B2:  BTFSS  x31.3
41B4:  MOVLW  01
41B6:  ANDWF  xF2,F
41B8:  MOVLW  00
41BA:  BTFSC  x25.3
41BC:  MOVLW  01
41BE:  MOVWF  xF5
41C0:  MOVLW  00
41C2:  BTFSC  x29.3
41C4:  MOVLW  01
41C6:  IORWF  xF5,W
41C8:  ANDWF  xF2,W
41CA:  IORWF  xF1,W
41CC:  BCF    xF0.0
41CE:  BTFSC  FE8.0
41D0:  BSF    xF0.0
....................       check = check | ((In.B5 | In2.B5) & ~Ack.B5 & (OutputType.B5 | OutputBoth.B5)); 
41D2:  MOVLW  00
41D4:  BTFSC  xF0.0
41D6:  MOVLW  01
41D8:  MOVWF  xF1
41DA:  MOVLW  00
41DC:  BTFSC  x35.4
41DE:  MOVLW  01
41E0:  MOVWF  xF3
41E2:  MOVLW  00
41E4:  BTFSC  x39.4
41E6:  MOVLW  01
41E8:  IORWF  xF3,W
41EA:  MOVWF  xF2
41EC:  MOVLW  00
41EE:  BTFSS  x31.4
41F0:  MOVLW  01
41F2:  ANDWF  xF2,F
41F4:  MOVLW  00
41F6:  BTFSC  x25.4
41F8:  MOVLW  01
41FA:  MOVWF  xF5
41FC:  MOVLW  00
41FE:  BTFSC  x29.4
4200:  MOVLW  01
4202:  IORWF  xF5,W
4204:  ANDWF  xF2,W
4206:  IORWF  xF1,W
4208:  BCF    xF0.0
420A:  BTFSC  FE8.0
420C:  BSF    xF0.0
....................       check = check | ((In.B6 | In2.B6) & ~Ack.B6 & (OutputType.B6 | OutputBoth.B6)); 
420E:  MOVLW  00
4210:  BTFSC  xF0.0
4212:  MOVLW  01
4214:  MOVWF  xF1
4216:  MOVLW  00
4218:  BTFSC  x35.5
421A:  MOVLW  01
421C:  MOVWF  xF3
421E:  MOVLW  00
4220:  BTFSC  x39.5
4222:  MOVLW  01
4224:  IORWF  xF3,W
4226:  MOVWF  xF2
4228:  MOVLW  00
422A:  BTFSS  x31.5
422C:  MOVLW  01
422E:  ANDWF  xF2,F
4230:  MOVLW  00
4232:  BTFSC  x25.5
4234:  MOVLW  01
4236:  MOVWF  xF5
4238:  MOVLW  00
423A:  BTFSC  x29.5
423C:  MOVLW  01
423E:  IORWF  xF5,W
4240:  ANDWF  xF2,W
4242:  IORWF  xF1,W
4244:  BCF    xF0.0
4246:  BTFSC  FE8.0
4248:  BSF    xF0.0
....................       check = check | ((In.B7 | In2.B7) & ~Ack.B7 & (OutputType.B7 | OutputBoth.B7)); 
424A:  MOVLW  00
424C:  BTFSC  xF0.0
424E:  MOVLW  01
4250:  MOVWF  xF1
4252:  MOVLW  00
4254:  BTFSC  x35.6
4256:  MOVLW  01
4258:  MOVWF  xF3
425A:  MOVLW  00
425C:  BTFSC  x39.6
425E:  MOVLW  01
4260:  IORWF  xF3,W
4262:  MOVWF  xF2
4264:  MOVLW  00
4266:  BTFSS  x31.6
4268:  MOVLW  01
426A:  ANDWF  xF2,F
426C:  MOVLW  00
426E:  BTFSC  x25.6
4270:  MOVLW  01
4272:  MOVWF  xF5
4274:  MOVLW  00
4276:  BTFSC  x29.6
4278:  MOVLW  01
427A:  IORWF  xF5,W
427C:  ANDWF  xF2,W
427E:  IORWF  xF1,W
4280:  BCF    xF0.0
4282:  BTFSC  FE8.0
4284:  BSF    xF0.0
....................       check = check | ((In.B8 | In2.B8) & ~Ack.B8 & (OutputType.B8 | OutputBoth.B8)); 
4286:  MOVLW  00
4288:  BTFSC  xF0.0
428A:  MOVLW  01
428C:  MOVWF  xF1
428E:  MOVLW  00
4290:  BTFSC  x35.7
4292:  MOVLW  01
4294:  MOVWF  xF3
4296:  MOVLW  00
4298:  BTFSC  x39.7
429A:  MOVLW  01
429C:  IORWF  xF3,W
429E:  MOVWF  xF2
42A0:  MOVLW  00
42A2:  BTFSS  x31.7
42A4:  MOVLW  01
42A6:  ANDWF  xF2,F
42A8:  MOVLW  00
42AA:  BTFSC  x25.7
42AC:  MOVLW  01
42AE:  MOVWF  xF5
42B0:  MOVLW  00
42B2:  BTFSC  x29.7
42B4:  MOVLW  01
42B6:  IORWF  xF5,W
42B8:  ANDWF  xF2,W
42BA:  IORWF  xF1,W
42BC:  BCF    xF0.0
42BE:  BTFSC  FE8.0
42C0:  BSF    xF0.0
....................       check = check | ((In.B9 | In2.B9) & ~Ack.B9 & (OutputType.B9 | OutputBoth.B9)); 
42C2:  MOVLW  00
42C4:  BTFSC  xF0.0
42C6:  MOVLW  01
42C8:  MOVWF  xF1
42CA:  MOVLW  00
42CC:  BTFSC  x36.0
42CE:  MOVLW  01
42D0:  MOVWF  xF3
42D2:  MOVLW  00
42D4:  BTFSC  x3A.0
42D6:  MOVLW  01
42D8:  IORWF  xF3,W
42DA:  MOVWF  xF2
42DC:  MOVLW  00
42DE:  BTFSS  x32.0
42E0:  MOVLW  01
42E2:  ANDWF  xF2,F
42E4:  MOVLW  00
42E6:  BTFSC  x26.0
42E8:  MOVLW  01
42EA:  MOVWF  xF5
42EC:  MOVLW  00
42EE:  BTFSC  x2A.0
42F0:  MOVLW  01
42F2:  IORWF  xF5,W
42F4:  ANDWF  xF2,W
42F6:  IORWF  xF1,W
42F8:  BCF    xF0.0
42FA:  BTFSC  FE8.0
42FC:  BSF    xF0.0
....................       check = check | ((In.B10 | In2.B10) & ~Ack.B10 & (OutputType.B10 | OutputBoth.B10)); 
42FE:  MOVLW  00
4300:  BTFSC  xF0.0
4302:  MOVLW  01
4304:  MOVWF  xF1
4306:  MOVLW  00
4308:  BTFSC  x36.1
430A:  MOVLW  01
430C:  MOVWF  xF3
430E:  MOVLW  00
4310:  BTFSC  x3A.1
4312:  MOVLW  01
4314:  IORWF  xF3,W
4316:  MOVWF  xF2
4318:  MOVLW  00
431A:  BTFSS  x32.1
431C:  MOVLW  01
431E:  ANDWF  xF2,F
4320:  MOVLW  00
4322:  BTFSC  x26.1
4324:  MOVLW  01
4326:  MOVWF  xF5
4328:  MOVLW  00
432A:  BTFSC  x2A.1
432C:  MOVLW  01
432E:  IORWF  xF5,W
4330:  ANDWF  xF2,W
4332:  IORWF  xF1,W
4334:  BCF    xF0.0
4336:  BTFSC  FE8.0
4338:  BSF    xF0.0
....................       check = check | ((In.B11 | In2.B11) & ~Ack.B11 & (OutputType.B11 | OutputBoth.B11)); 
433A:  MOVLW  00
433C:  BTFSC  xF0.0
433E:  MOVLW  01
4340:  MOVWF  xF1
4342:  MOVLW  00
4344:  BTFSC  x36.2
4346:  MOVLW  01
4348:  MOVWF  xF3
434A:  MOVLW  00
434C:  BTFSC  x3A.2
434E:  MOVLW  01
4350:  IORWF  xF3,W
4352:  MOVWF  xF2
4354:  MOVLW  00
4356:  BTFSS  x32.2
4358:  MOVLW  01
435A:  ANDWF  xF2,F
435C:  MOVLW  00
435E:  BTFSC  x26.2
4360:  MOVLW  01
4362:  MOVWF  xF5
4364:  MOVLW  00
4366:  BTFSC  x2A.2
4368:  MOVLW  01
436A:  IORWF  xF5,W
436C:  ANDWF  xF2,W
436E:  IORWF  xF1,W
4370:  BCF    xF0.0
4372:  BTFSC  FE8.0
4374:  BSF    xF0.0
....................       check = check | ((In.B12 | In2.B12) & ~Ack.B12 & (OutputType.B12 | OutputBoth.B12)); 
4376:  MOVLW  00
4378:  BTFSC  xF0.0
437A:  MOVLW  01
437C:  MOVWF  xF1
437E:  MOVLW  00
4380:  BTFSC  x36.3
4382:  MOVLW  01
4384:  MOVWF  xF3
4386:  MOVLW  00
4388:  BTFSC  x3A.3
438A:  MOVLW  01
438C:  IORWF  xF3,W
438E:  MOVWF  xF2
4390:  MOVLW  00
4392:  BTFSS  x32.3
4394:  MOVLW  01
4396:  ANDWF  xF2,F
4398:  MOVLW  00
439A:  BTFSC  x26.3
439C:  MOVLW  01
439E:  MOVWF  xF5
43A0:  MOVLW  00
43A2:  BTFSC  x2A.3
43A4:  MOVLW  01
43A6:  IORWF  xF5,W
43A8:  ANDWF  xF2,W
43AA:  IORWF  xF1,W
43AC:  BCF    xF0.0
43AE:  BTFSC  FE8.0
43B0:  BSF    xF0.0
....................       check = check | ((In.B13 | In2.B13) & ~Ack.B13 & (OutputType.B13 | OutputBoth.B13)); 
43B2:  MOVLW  00
43B4:  BTFSC  xF0.0
43B6:  MOVLW  01
43B8:  MOVWF  xF1
43BA:  MOVLW  00
43BC:  BTFSC  x36.4
43BE:  MOVLW  01
43C0:  MOVWF  xF3
43C2:  MOVLW  00
43C4:  BTFSC  x3A.4
43C6:  MOVLW  01
43C8:  IORWF  xF3,W
43CA:  MOVWF  xF2
43CC:  MOVLW  00
43CE:  BTFSS  x32.4
43D0:  MOVLW  01
43D2:  ANDWF  xF2,F
43D4:  MOVLW  00
43D6:  BTFSC  x26.4
43D8:  MOVLW  01
43DA:  MOVWF  xF5
43DC:  MOVLW  00
43DE:  BTFSC  x2A.4
43E0:  MOVLW  01
43E2:  IORWF  xF5,W
43E4:  ANDWF  xF2,W
43E6:  IORWF  xF1,W
43E8:  BCF    xF0.0
43EA:  BTFSC  FE8.0
43EC:  BSF    xF0.0
....................       check = check | ((In.B14 | In2.B14) & ~Ack.B14 & (OutputType.B14 | OutputBoth.B14)); 
43EE:  MOVLW  00
43F0:  BTFSC  xF0.0
43F2:  MOVLW  01
43F4:  MOVWF  xF1
43F6:  MOVLW  00
43F8:  BTFSC  x36.5
43FA:  MOVLW  01
43FC:  MOVWF  xF3
43FE:  MOVLW  00
4400:  BTFSC  x3A.5
4402:  MOVLW  01
4404:  IORWF  xF3,W
4406:  MOVWF  xF2
4408:  MOVLW  00
440A:  BTFSS  x32.5
440C:  MOVLW  01
440E:  ANDWF  xF2,F
4410:  MOVLW  00
4412:  BTFSC  x26.5
4414:  MOVLW  01
4416:  MOVWF  xF5
4418:  MOVLW  00
441A:  BTFSC  x2A.5
441C:  MOVLW  01
441E:  IORWF  xF5,W
4420:  ANDWF  xF2,W
4422:  IORWF  xF1,W
4424:  BCF    xF0.0
4426:  BTFSC  FE8.0
4428:  BSF    xF0.0
....................       check = check | ((In.B15 | In2.B15) & ~Ack.B15 & (OutputType.B15 | OutputBoth.B15)); 
442A:  MOVLW  00
442C:  BTFSC  xF0.0
442E:  MOVLW  01
4430:  MOVWF  xF1
4432:  MOVLW  00
4434:  BTFSC  x36.6
4436:  MOVLW  01
4438:  MOVWF  xF3
443A:  MOVLW  00
443C:  BTFSC  x3A.6
443E:  MOVLW  01
4440:  IORWF  xF3,W
4442:  MOVWF  xF2
4444:  MOVLW  00
4446:  BTFSS  x32.6
4448:  MOVLW  01
444A:  ANDWF  xF2,F
444C:  MOVLW  00
444E:  BTFSC  x26.6
4450:  MOVLW  01
4452:  MOVWF  xF5
4454:  MOVLW  00
4456:  BTFSC  x2A.6
4458:  MOVLW  01
445A:  IORWF  xF5,W
445C:  ANDWF  xF2,W
445E:  IORWF  xF1,W
4460:  BCF    xF0.0
4462:  BTFSC  FE8.0
4464:  BSF    xF0.0
....................       check = check | ((In.B16 | In2.B16) & ~Ack.B16 & (OutputType.B16 | OutputBoth.B16)); 
4466:  MOVLW  00
4468:  BTFSC  xF0.0
446A:  MOVLW  01
446C:  MOVWF  xF1
446E:  MOVLW  00
4470:  BTFSC  x36.7
4472:  MOVLW  01
4474:  MOVWF  xF3
4476:  MOVLW  00
4478:  BTFSC  x3A.7
447A:  MOVLW  01
447C:  IORWF  xF3,W
447E:  MOVWF  xF2
4480:  MOVLW  00
4482:  BTFSS  x32.7
4484:  MOVLW  01
4486:  ANDWF  xF2,F
4488:  MOVLW  00
448A:  BTFSC  x26.7
448C:  MOVLW  01
448E:  MOVWF  xF5
4490:  MOVLW  00
4492:  BTFSC  x2A.7
4494:  MOVLW  01
4496:  IORWF  xF5,W
4498:  ANDWF  xF2,W
449A:  IORWF  xF1,W
449C:  BCF    xF0.0
449E:  BTFSC  FE8.0
44A0:  BSF    xF0.0
....................       check = check | ((In.B17 | In2.B17) & ~Ack.B17 & (OutputType.B17 | OutputBoth.B17)); 
44A2:  MOVLW  00
44A4:  BTFSC  xF0.0
44A6:  MOVLW  01
44A8:  MOVWF  xF1
44AA:  MOVLW  00
44AC:  BTFSC  x37.0
44AE:  MOVLW  01
44B0:  MOVWF  xF3
44B2:  MOVLW  00
44B4:  BTFSC  x3B.0
44B6:  MOVLW  01
44B8:  IORWF  xF3,W
44BA:  MOVWF  xF2
44BC:  MOVLW  00
44BE:  BTFSS  x33.0
44C0:  MOVLW  01
44C2:  ANDWF  xF2,F
44C4:  MOVLW  00
44C6:  BTFSC  x27.0
44C8:  MOVLW  01
44CA:  MOVWF  xF5
44CC:  MOVLW  00
44CE:  BTFSC  x2B.0
44D0:  MOVLW  01
44D2:  IORWF  xF5,W
44D4:  ANDWF  xF2,W
44D6:  IORWF  xF1,W
44D8:  BCF    xF0.0
44DA:  BTFSC  FE8.0
44DC:  BSF    xF0.0
....................       check = check | ((In.B18 | In2.B18) & ~Ack.B18 & (OutputType.B18 | OutputBoth.B18)); 
44DE:  MOVLW  00
44E0:  BTFSC  xF0.0
44E2:  MOVLW  01
44E4:  MOVWF  xF1
44E6:  MOVLW  00
44E8:  BTFSC  x37.1
44EA:  MOVLW  01
44EC:  MOVWF  xF3
44EE:  MOVLW  00
44F0:  BTFSC  x3B.1
44F2:  MOVLW  01
44F4:  IORWF  xF3,W
44F6:  MOVWF  xF2
44F8:  MOVLW  00
44FA:  BTFSS  x33.1
44FC:  MOVLW  01
44FE:  ANDWF  xF2,F
4500:  MOVLW  00
4502:  BTFSC  x27.1
4504:  MOVLW  01
4506:  MOVWF  xF5
4508:  MOVLW  00
450A:  BTFSC  x2B.1
450C:  MOVLW  01
450E:  IORWF  xF5,W
4510:  ANDWF  xF2,W
4512:  IORWF  xF1,W
4514:  BCF    xF0.0
4516:  BTFSC  FE8.0
4518:  BSF    xF0.0
....................       check = check | ((In.B19 | In2.B19) & ~Ack.B19 & (OutputType.B19 | OutputBoth.B19)); 
451A:  MOVLW  00
451C:  BTFSC  xF0.0
451E:  MOVLW  01
4520:  MOVWF  xF1
4522:  MOVLW  00
4524:  BTFSC  x37.2
4526:  MOVLW  01
4528:  MOVWF  xF3
452A:  MOVLW  00
452C:  BTFSC  x3B.2
452E:  MOVLW  01
4530:  IORWF  xF3,W
4532:  MOVWF  xF2
4534:  MOVLW  00
4536:  BTFSS  x33.2
4538:  MOVLW  01
453A:  ANDWF  xF2,F
453C:  MOVLW  00
453E:  BTFSC  x27.2
4540:  MOVLW  01
4542:  MOVWF  xF5
4544:  MOVLW  00
4546:  BTFSC  x2B.2
4548:  MOVLW  01
454A:  IORWF  xF5,W
454C:  ANDWF  xF2,W
454E:  IORWF  xF1,W
4550:  BCF    xF0.0
4552:  BTFSC  FE8.0
4554:  BSF    xF0.0
....................       check = check | ((In.B20 | In2.B20) & ~Ack.B20 & (OutputType.B20 | OutputBoth.B20)); 
4556:  MOVLW  00
4558:  BTFSC  xF0.0
455A:  MOVLW  01
455C:  MOVWF  xF1
455E:  MOVLW  00
4560:  BTFSC  x37.3
4562:  MOVLW  01
4564:  MOVWF  xF3
4566:  MOVLW  00
4568:  BTFSC  x3B.3
456A:  MOVLW  01
456C:  IORWF  xF3,W
456E:  MOVWF  xF2
4570:  MOVLW  00
4572:  BTFSS  x33.3
4574:  MOVLW  01
4576:  ANDWF  xF2,F
4578:  MOVLW  00
457A:  BTFSC  x27.3
457C:  MOVLW  01
457E:  MOVWF  xF5
4580:  MOVLW  00
4582:  BTFSC  x2B.3
4584:  MOVLW  01
4586:  IORWF  xF5,W
4588:  ANDWF  xF2,W
458A:  IORWF  xF1,W
458C:  BCF    xF0.0
458E:  BTFSC  FE8.0
4590:  BSF    xF0.0
....................       
....................    } 
4592:  BRA    4A42
....................    else if(DatType == 0x02)             //Bell 
4594:  MOVF   xEF,W
4596:  SUBLW  02
4598:  BTFSS  FD8.2
459A:  BRA    4A42
....................    { 
....................       check = (In.B1 | In2.B1) & ~Ack.B1 & (~OutputType.B1 | OutputBoth.B1); 
459C:  MOVLW  00
459E:  BTFSC  x35.0
45A0:  MOVLW  01
45A2:  MOVWF  xF2
45A4:  MOVLW  00
45A6:  BTFSC  x39.0
45A8:  MOVLW  01
45AA:  IORWF  xF2,W
45AC:  MOVWF  xF1
45AE:  MOVLW  00
45B0:  BTFSS  x31.0
45B2:  MOVLW  01
45B4:  ANDWF  xF1,F
45B6:  MOVLW  00
45B8:  BTFSS  x25.0
45BA:  MOVLW  01
45BC:  MOVWF  xF4
45BE:  MOVLW  00
45C0:  BTFSC  x29.0
45C2:  MOVLW  01
45C4:  IORWF  xF4,W
45C6:  ANDWF  xF1,W
45C8:  BCF    xF0.0
45CA:  BTFSC  FE8.0
45CC:  BSF    xF0.0
....................       check = check | ((In.B2 | In2.B2) & ~Ack.B2 & (~OutputType.B2 | OutputBoth.B2)); 
45CE:  MOVLW  00
45D0:  BTFSC  xF0.0
45D2:  MOVLW  01
45D4:  MOVWF  xF1
45D6:  MOVLW  00
45D8:  BTFSC  x35.1
45DA:  MOVLW  01
45DC:  MOVWF  xF3
45DE:  MOVLW  00
45E0:  BTFSC  x39.1
45E2:  MOVLW  01
45E4:  IORWF  xF3,W
45E6:  MOVWF  xF2
45E8:  MOVLW  00
45EA:  BTFSS  x31.1
45EC:  MOVLW  01
45EE:  ANDWF  xF2,F
45F0:  MOVLW  00
45F2:  BTFSS  x25.1
45F4:  MOVLW  01
45F6:  MOVWF  xF5
45F8:  MOVLW  00
45FA:  BTFSC  x29.1
45FC:  MOVLW  01
45FE:  IORWF  xF5,W
4600:  ANDWF  xF2,W
4602:  IORWF  xF1,W
4604:  BCF    xF0.0
4606:  BTFSC  FE8.0
4608:  BSF    xF0.0
....................       check = check | ((In.B3 | In2.B3) & ~Ack.B3 & (~OutputType.B3 | OutputBoth.B3)); 
460A:  MOVLW  00
460C:  BTFSC  xF0.0
460E:  MOVLW  01
4610:  MOVWF  xF1
4612:  MOVLW  00
4614:  BTFSC  x35.2
4616:  MOVLW  01
4618:  MOVWF  xF3
461A:  MOVLW  00
461C:  BTFSC  x39.2
461E:  MOVLW  01
4620:  IORWF  xF3,W
4622:  MOVWF  xF2
4624:  MOVLW  00
4626:  BTFSS  x31.2
4628:  MOVLW  01
462A:  ANDWF  xF2,F
462C:  MOVLW  00
462E:  BTFSS  x25.2
4630:  MOVLW  01
4632:  MOVWF  xF5
4634:  MOVLW  00
4636:  BTFSC  x29.2
4638:  MOVLW  01
463A:  IORWF  xF5,W
463C:  ANDWF  xF2,W
463E:  IORWF  xF1,W
4640:  BCF    xF0.0
4642:  BTFSC  FE8.0
4644:  BSF    xF0.0
....................       check = check | ((In.B4 | In2.B4) & ~Ack.B4 & (~OutputType.B4 | OutputBoth.B4)); 
4646:  MOVLW  00
4648:  BTFSC  xF0.0
464A:  MOVLW  01
464C:  MOVWF  xF1
464E:  MOVLW  00
4650:  BTFSC  x35.3
4652:  MOVLW  01
4654:  MOVWF  xF3
4656:  MOVLW  00
4658:  BTFSC  x39.3
465A:  MOVLW  01
465C:  IORWF  xF3,W
465E:  MOVWF  xF2
4660:  MOVLW  00
4662:  BTFSS  x31.3
4664:  MOVLW  01
4666:  ANDWF  xF2,F
4668:  MOVLW  00
466A:  BTFSS  x25.3
466C:  MOVLW  01
466E:  MOVWF  xF5
4670:  MOVLW  00
4672:  BTFSC  x29.3
4674:  MOVLW  01
4676:  IORWF  xF5,W
4678:  ANDWF  xF2,W
467A:  IORWF  xF1,W
467C:  BCF    xF0.0
467E:  BTFSC  FE8.0
4680:  BSF    xF0.0
....................       check = check | ((In.B5 | In2.B5) & ~Ack.B5 & (~OutputType.B5 | OutputBoth.B5)); 
4682:  MOVLW  00
4684:  BTFSC  xF0.0
4686:  MOVLW  01
4688:  MOVWF  xF1
468A:  MOVLW  00
468C:  BTFSC  x35.4
468E:  MOVLW  01
4690:  MOVWF  xF3
4692:  MOVLW  00
4694:  BTFSC  x39.4
4696:  MOVLW  01
4698:  IORWF  xF3,W
469A:  MOVWF  xF2
469C:  MOVLW  00
469E:  BTFSS  x31.4
46A0:  MOVLW  01
46A2:  ANDWF  xF2,F
46A4:  MOVLW  00
46A6:  BTFSS  x25.4
46A8:  MOVLW  01
46AA:  MOVWF  xF5
46AC:  MOVLW  00
46AE:  BTFSC  x29.4
46B0:  MOVLW  01
46B2:  IORWF  xF5,W
46B4:  ANDWF  xF2,W
46B6:  IORWF  xF1,W
46B8:  BCF    xF0.0
46BA:  BTFSC  FE8.0
46BC:  BSF    xF0.0
....................       check = check | ((In.B6 | In2.B6) & ~Ack.B6 & (~OutputType.B6 | OutputBoth.B6)); 
46BE:  MOVLW  00
46C0:  BTFSC  xF0.0
46C2:  MOVLW  01
46C4:  MOVWF  xF1
46C6:  MOVLW  00
46C8:  BTFSC  x35.5
46CA:  MOVLW  01
46CC:  MOVWF  xF3
46CE:  MOVLW  00
46D0:  BTFSC  x39.5
46D2:  MOVLW  01
46D4:  IORWF  xF3,W
46D6:  MOVWF  xF2
46D8:  MOVLW  00
46DA:  BTFSS  x31.5
46DC:  MOVLW  01
46DE:  ANDWF  xF2,F
46E0:  MOVLW  00
46E2:  BTFSS  x25.5
46E4:  MOVLW  01
46E6:  MOVWF  xF5
46E8:  MOVLW  00
46EA:  BTFSC  x29.5
46EC:  MOVLW  01
46EE:  IORWF  xF5,W
46F0:  ANDWF  xF2,W
46F2:  IORWF  xF1,W
46F4:  BCF    xF0.0
46F6:  BTFSC  FE8.0
46F8:  BSF    xF0.0
....................       check = check | ((In.B7 | In2.B7) & ~Ack.B7 & (~OutputType.B7 | OutputBoth.B7)); 
46FA:  MOVLW  00
46FC:  BTFSC  xF0.0
46FE:  MOVLW  01
4700:  MOVWF  xF1
4702:  MOVLW  00
4704:  BTFSC  x35.6
4706:  MOVLW  01
4708:  MOVWF  xF3
470A:  MOVLW  00
470C:  BTFSC  x39.6
470E:  MOVLW  01
4710:  IORWF  xF3,W
4712:  MOVWF  xF2
4714:  MOVLW  00
4716:  BTFSS  x31.6
4718:  MOVLW  01
471A:  ANDWF  xF2,F
471C:  MOVLW  00
471E:  BTFSS  x25.6
4720:  MOVLW  01
4722:  MOVWF  xF5
4724:  MOVLW  00
4726:  BTFSC  x29.6
4728:  MOVLW  01
472A:  IORWF  xF5,W
472C:  ANDWF  xF2,W
472E:  IORWF  xF1,W
4730:  BCF    xF0.0
4732:  BTFSC  FE8.0
4734:  BSF    xF0.0
....................       check = check | ((In.B8 | In2.B8) & ~Ack.B8 & (~OutputType.B8 | OutputBoth.B8)); 
4736:  MOVLW  00
4738:  BTFSC  xF0.0
473A:  MOVLW  01
473C:  MOVWF  xF1
473E:  MOVLW  00
4740:  BTFSC  x35.7
4742:  MOVLW  01
4744:  MOVWF  xF3
4746:  MOVLW  00
4748:  BTFSC  x39.7
474A:  MOVLW  01
474C:  IORWF  xF3,W
474E:  MOVWF  xF2
4750:  MOVLW  00
4752:  BTFSS  x31.7
4754:  MOVLW  01
4756:  ANDWF  xF2,F
4758:  MOVLW  00
475A:  BTFSS  x25.7
475C:  MOVLW  01
475E:  MOVWF  xF5
4760:  MOVLW  00
4762:  BTFSC  x29.7
4764:  MOVLW  01
4766:  IORWF  xF5,W
4768:  ANDWF  xF2,W
476A:  IORWF  xF1,W
476C:  BCF    xF0.0
476E:  BTFSC  FE8.0
4770:  BSF    xF0.0
....................       check = check | ((In.B9 | In2.B9) & ~Ack.B9 & (~OutputType.B9 | OutputBoth.B9)); 
4772:  MOVLW  00
4774:  BTFSC  xF0.0
4776:  MOVLW  01
4778:  MOVWF  xF1
477A:  MOVLW  00
477C:  BTFSC  x36.0
477E:  MOVLW  01
4780:  MOVWF  xF3
4782:  MOVLW  00
4784:  BTFSC  x3A.0
4786:  MOVLW  01
4788:  IORWF  xF3,W
478A:  MOVWF  xF2
478C:  MOVLW  00
478E:  BTFSS  x32.0
4790:  MOVLW  01
4792:  ANDWF  xF2,F
4794:  MOVLW  00
4796:  BTFSS  x26.0
4798:  MOVLW  01
479A:  MOVWF  xF5
479C:  MOVLW  00
479E:  BTFSC  x2A.0
47A0:  MOVLW  01
47A2:  IORWF  xF5,W
47A4:  ANDWF  xF2,W
47A6:  IORWF  xF1,W
47A8:  BCF    xF0.0
47AA:  BTFSC  FE8.0
47AC:  BSF    xF0.0
....................       check = check | ((In.B10 | In2.B10) & ~Ack.B10 & (~OutputType.B10 | OutputBoth.B10)); 
47AE:  MOVLW  00
47B0:  BTFSC  xF0.0
47B2:  MOVLW  01
47B4:  MOVWF  xF1
47B6:  MOVLW  00
47B8:  BTFSC  x36.1
47BA:  MOVLW  01
47BC:  MOVWF  xF3
47BE:  MOVLW  00
47C0:  BTFSC  x3A.1
47C2:  MOVLW  01
47C4:  IORWF  xF3,W
47C6:  MOVWF  xF2
47C8:  MOVLW  00
47CA:  BTFSS  x32.1
47CC:  MOVLW  01
47CE:  ANDWF  xF2,F
47D0:  MOVLW  00
47D2:  BTFSS  x26.1
47D4:  MOVLW  01
47D6:  MOVWF  xF5
47D8:  MOVLW  00
47DA:  BTFSC  x2A.1
47DC:  MOVLW  01
47DE:  IORWF  xF5,W
47E0:  ANDWF  xF2,W
47E2:  IORWF  xF1,W
47E4:  BCF    xF0.0
47E6:  BTFSC  FE8.0
47E8:  BSF    xF0.0
....................       check = check | ((In.B11 | In2.B11) & ~Ack.B11 & (~OutputType.B11 | OutputBoth.B11)); 
47EA:  MOVLW  00
47EC:  BTFSC  xF0.0
47EE:  MOVLW  01
47F0:  MOVWF  xF1
47F2:  MOVLW  00
47F4:  BTFSC  x36.2
47F6:  MOVLW  01
47F8:  MOVWF  xF3
47FA:  MOVLW  00
47FC:  BTFSC  x3A.2
47FE:  MOVLW  01
4800:  IORWF  xF3,W
4802:  MOVWF  xF2
4804:  MOVLW  00
4806:  BTFSS  x32.2
4808:  MOVLW  01
480A:  ANDWF  xF2,F
480C:  MOVLW  00
480E:  BTFSS  x26.2
4810:  MOVLW  01
4812:  MOVWF  xF5
4814:  MOVLW  00
4816:  BTFSC  x2A.2
4818:  MOVLW  01
481A:  IORWF  xF5,W
481C:  ANDWF  xF2,W
481E:  IORWF  xF1,W
4820:  BCF    xF0.0
4822:  BTFSC  FE8.0
4824:  BSF    xF0.0
....................       check = check | ((In.B12 | In2.B12) & ~Ack.B12 & (~OutputType.B12 | OutputBoth.B12)); 
4826:  MOVLW  00
4828:  BTFSC  xF0.0
482A:  MOVLW  01
482C:  MOVWF  xF1
482E:  MOVLW  00
4830:  BTFSC  x36.3
4832:  MOVLW  01
4834:  MOVWF  xF3
4836:  MOVLW  00
4838:  BTFSC  x3A.3
483A:  MOVLW  01
483C:  IORWF  xF3,W
483E:  MOVWF  xF2
4840:  MOVLW  00
4842:  BTFSS  x32.3
4844:  MOVLW  01
4846:  ANDWF  xF2,F
4848:  MOVLW  00
484A:  BTFSS  x26.3
484C:  MOVLW  01
484E:  MOVWF  xF5
4850:  MOVLW  00
4852:  BTFSC  x2A.3
4854:  MOVLW  01
4856:  IORWF  xF5,W
4858:  ANDWF  xF2,W
485A:  IORWF  xF1,W
485C:  BCF    xF0.0
485E:  BTFSC  FE8.0
4860:  BSF    xF0.0
....................       check = check | ((In.B13 | In2.B13) & ~Ack.B13 & (~OutputType.B13 | OutputBoth.B13)); 
4862:  MOVLW  00
4864:  BTFSC  xF0.0
4866:  MOVLW  01
4868:  MOVWF  xF1
486A:  MOVLW  00
486C:  BTFSC  x36.4
486E:  MOVLW  01
4870:  MOVWF  xF3
4872:  MOVLW  00
4874:  BTFSC  x3A.4
4876:  MOVLW  01
4878:  IORWF  xF3,W
487A:  MOVWF  xF2
487C:  MOVLW  00
487E:  BTFSS  x32.4
4880:  MOVLW  01
4882:  ANDWF  xF2,F
4884:  MOVLW  00
4886:  BTFSS  x26.4
4888:  MOVLW  01
488A:  MOVWF  xF5
488C:  MOVLW  00
488E:  BTFSC  x2A.4
4890:  MOVLW  01
4892:  IORWF  xF5,W
4894:  ANDWF  xF2,W
4896:  IORWF  xF1,W
4898:  BCF    xF0.0
489A:  BTFSC  FE8.0
489C:  BSF    xF0.0
....................       check = check | ((In.B14 | In2.B14) & ~Ack.B14 & (~OutputType.B14 | OutputBoth.B14)); 
489E:  MOVLW  00
48A0:  BTFSC  xF0.0
48A2:  MOVLW  01
48A4:  MOVWF  xF1
48A6:  MOVLW  00
48A8:  BTFSC  x36.5
48AA:  MOVLW  01
48AC:  MOVWF  xF3
48AE:  MOVLW  00
48B0:  BTFSC  x3A.5
48B2:  MOVLW  01
48B4:  IORWF  xF3,W
48B6:  MOVWF  xF2
48B8:  MOVLW  00
48BA:  BTFSS  x32.5
48BC:  MOVLW  01
48BE:  ANDWF  xF2,F
48C0:  MOVLW  00
48C2:  BTFSS  x26.5
48C4:  MOVLW  01
48C6:  MOVWF  xF5
48C8:  MOVLW  00
48CA:  BTFSC  x2A.5
48CC:  MOVLW  01
48CE:  IORWF  xF5,W
48D0:  ANDWF  xF2,W
48D2:  IORWF  xF1,W
48D4:  BCF    xF0.0
48D6:  BTFSC  FE8.0
48D8:  BSF    xF0.0
....................       check = check | ((In.B15 | In2.B15) & ~Ack.B15 & (~OutputType.B15 | OutputBoth.B15)); 
48DA:  MOVLW  00
48DC:  BTFSC  xF0.0
48DE:  MOVLW  01
48E0:  MOVWF  xF1
48E2:  MOVLW  00
48E4:  BTFSC  x36.6
48E6:  MOVLW  01
48E8:  MOVWF  xF3
48EA:  MOVLW  00
48EC:  BTFSC  x3A.6
48EE:  MOVLW  01
48F0:  IORWF  xF3,W
48F2:  MOVWF  xF2
48F4:  MOVLW  00
48F6:  BTFSS  x32.6
48F8:  MOVLW  01
48FA:  ANDWF  xF2,F
48FC:  MOVLW  00
48FE:  BTFSS  x26.6
4900:  MOVLW  01
4902:  MOVWF  xF5
4904:  MOVLW  00
4906:  BTFSC  x2A.6
4908:  MOVLW  01
490A:  IORWF  xF5,W
490C:  ANDWF  xF2,W
490E:  IORWF  xF1,W
4910:  BCF    xF0.0
4912:  BTFSC  FE8.0
4914:  BSF    xF0.0
....................       check = check | ((In.B16 | In2.B16) & ~Ack.B16 & (~OutputType.B16 | OutputBoth.B16)); 
4916:  MOVLW  00
4918:  BTFSC  xF0.0
491A:  MOVLW  01
491C:  MOVWF  xF1
491E:  MOVLW  00
4920:  BTFSC  x36.7
4922:  MOVLW  01
4924:  MOVWF  xF3
4926:  MOVLW  00
4928:  BTFSC  x3A.7
492A:  MOVLW  01
492C:  IORWF  xF3,W
492E:  MOVWF  xF2
4930:  MOVLW  00
4932:  BTFSS  x32.7
4934:  MOVLW  01
4936:  ANDWF  xF2,F
4938:  MOVLW  00
493A:  BTFSS  x26.7
493C:  MOVLW  01
493E:  MOVWF  xF5
4940:  MOVLW  00
4942:  BTFSC  x2A.7
4944:  MOVLW  01
4946:  IORWF  xF5,W
4948:  ANDWF  xF2,W
494A:  IORWF  xF1,W
494C:  BCF    xF0.0
494E:  BTFSC  FE8.0
4950:  BSF    xF0.0
....................       check = check | ((In.B17 | In2.B17) & ~Ack.B17 & (~OutputType.B17 | OutputBoth.B17)); 
4952:  MOVLW  00
4954:  BTFSC  xF0.0
4956:  MOVLW  01
4958:  MOVWF  xF1
495A:  MOVLW  00
495C:  BTFSC  x37.0
495E:  MOVLW  01
4960:  MOVWF  xF3
4962:  MOVLW  00
4964:  BTFSC  x3B.0
4966:  MOVLW  01
4968:  IORWF  xF3,W
496A:  MOVWF  xF2
496C:  MOVLW  00
496E:  BTFSS  x33.0
4970:  MOVLW  01
4972:  ANDWF  xF2,F
4974:  MOVLW  00
4976:  BTFSS  x27.0
4978:  MOVLW  01
497A:  MOVWF  xF5
497C:  MOVLW  00
497E:  BTFSC  x2B.0
4980:  MOVLW  01
4982:  IORWF  xF5,W
4984:  ANDWF  xF2,W
4986:  IORWF  xF1,W
4988:  BCF    xF0.0
498A:  BTFSC  FE8.0
498C:  BSF    xF0.0
....................       check = check | ((In.B18 | In2.B18) & ~Ack.B18 & (~OutputType.B18 | OutputBoth.B18)); 
498E:  MOVLW  00
4990:  BTFSC  xF0.0
4992:  MOVLW  01
4994:  MOVWF  xF1
4996:  MOVLW  00
4998:  BTFSC  x37.1
499A:  MOVLW  01
499C:  MOVWF  xF3
499E:  MOVLW  00
49A0:  BTFSC  x3B.1
49A2:  MOVLW  01
49A4:  IORWF  xF3,W
49A6:  MOVWF  xF2
49A8:  MOVLW  00
49AA:  BTFSS  x33.1
49AC:  MOVLW  01
49AE:  ANDWF  xF2,F
49B0:  MOVLW  00
49B2:  BTFSS  x27.1
49B4:  MOVLW  01
49B6:  MOVWF  xF5
49B8:  MOVLW  00
49BA:  BTFSC  x2B.1
49BC:  MOVLW  01
49BE:  IORWF  xF5,W
49C0:  ANDWF  xF2,W
49C2:  IORWF  xF1,W
49C4:  BCF    xF0.0
49C6:  BTFSC  FE8.0
49C8:  BSF    xF0.0
....................       check = check | ((In.B19 | In2.B19) & ~Ack.B19 & (~OutputType.B19 | OutputBoth.B19)); 
49CA:  MOVLW  00
49CC:  BTFSC  xF0.0
49CE:  MOVLW  01
49D0:  MOVWF  xF1
49D2:  MOVLW  00
49D4:  BTFSC  x37.2
49D6:  MOVLW  01
49D8:  MOVWF  xF3
49DA:  MOVLW  00
49DC:  BTFSC  x3B.2
49DE:  MOVLW  01
49E0:  IORWF  xF3,W
49E2:  MOVWF  xF2
49E4:  MOVLW  00
49E6:  BTFSS  x33.2
49E8:  MOVLW  01
49EA:  ANDWF  xF2,F
49EC:  MOVLW  00
49EE:  BTFSS  x27.2
49F0:  MOVLW  01
49F2:  MOVWF  xF5
49F4:  MOVLW  00
49F6:  BTFSC  x2B.2
49F8:  MOVLW  01
49FA:  IORWF  xF5,W
49FC:  ANDWF  xF2,W
49FE:  IORWF  xF1,W
4A00:  BCF    xF0.0
4A02:  BTFSC  FE8.0
4A04:  BSF    xF0.0
....................       check = check | ((In.B20 | In2.B20) & ~Ack.B20 & (~OutputType.B20 | OutputBoth.B20)); 
4A06:  MOVLW  00
4A08:  BTFSC  xF0.0
4A0A:  MOVLW  01
4A0C:  MOVWF  xF1
4A0E:  MOVLW  00
4A10:  BTFSC  x37.3
4A12:  MOVLW  01
4A14:  MOVWF  xF3
4A16:  MOVLW  00
4A18:  BTFSC  x3B.3
4A1A:  MOVLW  01
4A1C:  IORWF  xF3,W
4A1E:  MOVWF  xF2
4A20:  MOVLW  00
4A22:  BTFSS  x33.3
4A24:  MOVLW  01
4A26:  ANDWF  xF2,F
4A28:  MOVLW  00
4A2A:  BTFSS  x27.3
4A2C:  MOVLW  01
4A2E:  MOVWF  xF5
4A30:  MOVLW  00
4A32:  BTFSC  x2B.3
4A34:  MOVLW  01
4A36:  IORWF  xF5,W
4A38:  ANDWF  xF2,W
4A3A:  IORWF  xF1,W
4A3C:  BCF    xF0.0
4A3E:  BTFSC  FE8.0
4A40:  BSF    xF0.0
....................  
....................    } 
....................    return(check); 
4A42:  MOVLW  00
4A44:  BTFSC  xF0.0
4A46:  MOVLW  01
4A48:  MOVWF  01
4A4A:  MOVLB  0
4A4C:  RETURN 0
.................... } 
....................  
.................... void initialIC(void) 
.................... { 
....................  
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void main() 
*
7406:  CLRF   FF8
7408:  BCF    FD0.7
740A:  BSF    07.7
740C:  MOVLW  81
740E:  MOVWF  FAF
7410:  MOVLW  A6
7412:  MOVWF  FAC
7414:  MOVLW  90
7416:  MOVWF  FAB
7418:  CLRF   19
741A:  BCF    1A.0
741C:  MOVLW  19
741E:  MOVWF  1B
7420:  BCF    1A.1
7422:  MOVLW  64
7424:  MOVWF  1C
7426:  CLRF   1D
7428:  BCF    1A.2
742A:  BCF    1A.3
742C:  BCF    1A.4
742E:  CLRF   2E
7430:  BCF    1A.5
7432:  CLRF   2F
7434:  BCF    1A.6
7436:  BCF    1A.7
7438:  BCF    30.0
743A:  BCF    30.1
743C:  BCF    30.2
743E:  CLRF   31
7440:  BCF    30.3
7442:  BCF    30.4
7444:  MOVLW  11
7446:  MOVWF  66
7448:  MOVLW  12
744A:  MOVWF  67
744C:  MOVLW  13
744E:  MOVWF  68
7450:  MOVLW  14
7452:  MOVWF  69
7454:  MOVLW  16
7456:  MOVWF  6A
7458:  MOVLW  17
745A:  MOVWF  6B
745C:  MOVLW  19
745E:  MOVWF  6C
7460:  MOVLW  20
7462:  MOVWF  6D
7464:  BCF    30.5
7466:  CLRF   70
7468:  MOVLW  01
746A:  MOVWF  xEC
746C:  MOVLW  F4
746E:  MOVWF  xEB
7470:  CLRF   xEE
7472:  CLRF   xED
7474:  CLRF   xF0
7476:  CLRF   xEF
7478:  CLRF   xF1
747A:  MOVLB  1
747C:  CLRF   x13
747E:  CLRF   x14
7480:  CLRF   xD0
7482:  CLRF   xD1
7484:  CLRF   xD2
7486:  CLRF   xD3
7488:  CLRF   xD4
748A:  CLRF   xD5
748C:  CLRF   xD6
748E:  CLRF   xD7
7490:  CLRF   xD8
7492:  CLRF   xD9
7494:  CLRF   xDA
7496:  CLRF   xDB
7498:  CLRF   xDC
749A:  CLRF   xDD
749C:  CLRF   xDE
749E:  CLRF   xDF
74A0:  CLRF   xE0
74A2:  CLRF   xE1
74A4:  CLRF   xE2
74A6:  CLRF   xE3
74A8:  CLRF   xE4
74AA:  BSF    FC1.0
74AC:  BSF    FC1.1
74AE:  BSF    FC1.2
74B0:  BCF    FC1.3
.................... {   
....................    delay_ms(50); 
74B2:  MOVLW  32
74B4:  MOVWF  xEF
74B6:  MOVLB  0
74B8:  CALL   05BE
....................    output_bit(Pled,0);   //power on watchdog signal 
74BC:  BCF    F8A.5
74BE:  BCF    F93.5
....................     
....................    //jj 
....................    //setup_adc_ports(NO_ANALOGS|VSS_VDD); 
....................    //setup_adc(ADC_OFF|ADC_TAD_MUL_0); 
....................     
....................    //setup_spi(FALSE); 
....................     
....................    setup_timer_0(RTCC_INTERNAL); 
74C0:  MOVLW  80
74C2:  MOVWF  FD5
....................    //setup_timer_1(T1_DISABLED); 
....................    setup_timer_2(T2_DIV_BY_16,196,16);         //10ms 
74C4:  MOVLW  78
74C6:  IORLW  06
74C8:  MOVWF  FCA
74CA:  MOVLW  C4
74CC:  MOVWF  FCB
....................    //setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);    //104ms 
....................    //setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
....................    //setup_comparator(NC_NC_NC_NC); 
....................    //setup_vref(FALSE); 
....................    // enable_interrupts(INT_TIMER1); 
....................    enable_interrupts(INT_TIMER2); 
74CE:  BSF    F9D.1
....................    enable_interrupts(INT_RDA); 
74D0:  BSF    F9D.5
....................     
....................    //setup_oscillator(False); 
....................     
....................    //  set_tris_c (0b01010111); 
....................    //setup_spi(SPI_MASTER | SPI_XMIT_L_TO_H |SPI_SS_DISABLED|SPI_H_TO_L  | SPI_CLK_DIV_4  ); 
....................    //setup_spi(SPI_MASTER | SPI_H_TO_L  | SPI_CLK_DIV_4 |SPI_SS_DISABLED); // Initial SPI 
....................    //setup_spi(SPI_MASTER|SPI_H_TO_L|SPI_SS_DISABLED|SPI_CLK_DIV_16); 
....................    //setup_spi2( FALSE ); 
....................    //setup_spi( FALSE ); 
....................     
....................    // setup_spi(SPI_MASTER |SPI_SS_DISABLED | SPI_L_TO_H | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); //masterOK 
....................     
....................    //setup_spi(SPI_MASTER  | SPI_L_TO_H | SPI_XMIT_L_TO_H| SPI_CLK_DIV_16 ); //master1 jj 
....................    //setup_spi(SPI_MASTER  |SPI_SS_DISABLED| SPI_L_TO_H | SPI_XMIT_L_TO_H| SPI_CLK_DIV_16 ); 
....................    setup_spi(SPI_MASTER  | SPI_L_TO_H |SPI_SS_DISABLED | SPI_XMIT_L_TO_H| SPI_CLK_DIV_16 ); //master1 jj 
74D2:  BCF    FC6.5
74D4:  BCF    F94.5
74D6:  BSF    F94.4
74D8:  BCF    F94.3
74DA:  MOVLW  21
74DC:  MOVWF  FC6
74DE:  MOVLW  40
74E0:  MOVWF  FC7
....................  
....................    //setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4 ); //master2 
....................    //setup_spi(SPI_MASTER |SPI_SS_DISABLED |SPI_SAMPLE_AT_END | SPI_H_TO_L | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); //master1.1 
....................    //spi_init(SPI1_MODE0, TRUE); 
....................    //spi_init(250000); 
....................    //setup_spi(SPI_MASTER | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4 ); 
....................    //setup_spi(SPI_SS_DISABLED  | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4 ); 
....................    //setup_spi(SPI_MASTER | SPI_H_TO_L | SPI_CLK_T2 | SPI_XMIT_L_TO_H); 
....................    //setup_spi(SPI_MASTER | SPI_H_TO_L| SPI_SAMPLE_AT_END | SPI_CLK_DIV_64);//master3 
....................    //setup_spi(SPI_MASTER |SPI_SS_DISABLED| SPI_L_TO_H | SPI_SAMPLE_AT_END | SPI_CLK_DIV_4 ); 
....................    //setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
....................    //setup_spi(SPI_MASTER |SPI_SS_DISABLED | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); 
....................    //setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4); 
....................    //setup_spi(SPI_MASTER | SPI_H_TO_L | SPI_CLK_DIV_16); 
....................    //setup_spi(SPI_MASTER |SPI_SS_DISABLED| spi_L_to_H| SPI_XMIT_L_TO_H|SPI_CLK_DIV_4 ); 
....................    
....................    IO_INIT();   //initializes the MCP23S17 chip.//----------jj 
74E2:  GOTO   0620
....................    
....................    IO_SET_TRIS_A(IO_DEVICE_0, 0xFF); //addr.0 Set PortA As Inputt 
74E6:  MOVLB  1
74E8:  CLRF   xE7
74EA:  SETF   xE8
74EC:  MOVLB  0
74EE:  CALL   06B6
....................    IO_SET_TRIS_B(IO_DEVICE_0, 0xFF); //addr.0 Set PortB As Inputt 
74F2:  MOVLB  1
74F4:  CLRF   xE7
74F6:  SETF   xE8
74F8:  MOVLB  0
74FA:  CALL   06C8
....................    IO_SET_TRIS_A(IO_DEVICE_1, 0xFF); //addr.1 Set PortA As Inputt  
74FE:  MOVLW  02
7500:  MOVLB  1
7502:  MOVWF  xE7
7504:  SETF   xE8
7506:  MOVLB  0
7508:  CALL   06B6
....................    IO_SET_TRIS_B(IO_DEVICE_1, 0xFF); //addr.1 Set PortB As Inputt 
750C:  MOVLW  02
750E:  MOVLB  1
7510:  MOVWF  xE7
7512:  SETF   xE8
7514:  MOVLB  0
7516:  CALL   06C8
....................    //  jj 
....................    IO_WRITE_REGISTER(IO_DEVICE_0, GPPUA, 0xFF); // Input Pullup 
751A:  MOVLB  1
751C:  CLRF   xF1
751E:  MOVLW  06
7520:  MOVWF  xF2
7522:  SETF   xF3
7524:  MOVLB  0
7526:  CALL   05EE
....................    IO_WRITE_REGISTER(IO_DEVICE_0, GPPUB, 0xFF); // Input Pullup 
752A:  MOVLB  1
752C:  CLRF   xF1
752E:  MOVLW  16
7530:  MOVWF  xF2
7532:  SETF   xF3
7534:  MOVLB  0
7536:  CALL   05EE
....................    IO_WRITE_REGISTER(IO_DEVICE_1, GPPUA, 0xFF); // Input Pullup 
753A:  MOVLW  02
753C:  MOVLB  1
753E:  MOVWF  xF1
7540:  MOVLW  06
7542:  MOVWF  xF2
7544:  SETF   xF3
7546:  MOVLB  0
7548:  CALL   05EE
....................    IO_WRITE_REGISTER(IO_DEVICE_1, GPPUB, 0xFF); // Input Pullup 
754C:  MOVLW  02
754E:  MOVLB  1
7550:  MOVWF  xF1
7552:  MOVLW  16
7554:  MOVWF  xF2
7556:  SETF   xF3
7558:  MOVLB  0
755A:  CALL   05EE
....................    //  jj 
....................    IO_SET_TRIS_A(IO_DEVICE_2, 0x00); //addr.2 Set PortA As Output  
755E:  MOVLW  04
7560:  MOVLB  1
7562:  MOVWF  xE7
7564:  CLRF   xE8
7566:  MOVLB  0
7568:  CALL   06B6
....................    IO_SET_TRIS_B(IO_DEVICE_2, 0x00); //addr.2 Set PortB As Output 
756C:  MOVLW  04
756E:  MOVLB  1
7570:  MOVWF  xE7
7572:  CLRF   xE8
7574:  MOVLB  0
7576:  CALL   06C8
....................    IO_SET_TRIS_A(IO_DEVICE_3, 0x00); //addr.3 Set PortA As Output  
757A:  MOVLW  06
757C:  MOVLB  1
757E:  MOVWF  xE7
7580:  CLRF   xE8
7582:  MOVLB  0
7584:  CALL   06B6
....................    IO_SET_TRIS_B(IO_DEVICE_3, 0x00); //addr.3 Set PortB As Output 
7588:  MOVLW  06
758A:  MOVLB  1
758C:  MOVWF  xE7
758E:  CLRF   xE8
7590:  MOVLB  0
7592:  CALL   06C8
....................    IO_SET_TRIS_A(IO_DEVICE_4, 0x00); //addr.4 Set PortA As Output  
7596:  MOVLW  08
7598:  MOVLB  1
759A:  MOVWF  xE7
759C:  CLRF   xE8
759E:  MOVLB  0
75A0:  CALL   06B6
....................    IO_SET_TRIS_B(IO_DEVICE_4, 0x00); //addr.4 Set PortB As Output  
75A4:  MOVLW  08
75A6:  MOVLB  1
75A8:  MOVWF  xE7
75AA:  CLRF   xE8
75AC:  MOVLB  0
75AE:  CALL   06C8
....................    IO_SET_TRIS_A(IO_DEVICE_5, 0x00); //addr.5 Set PortA As Output  
75B2:  MOVLW  0A
75B4:  MOVLB  1
75B6:  MOVWF  xE7
75B8:  CLRF   xE8
75BA:  MOVLB  0
75BC:  CALL   06B6
....................    IO_SET_TRIS_B(IO_DEVICE_5, 0x00); //addr.5 Set PortB As Output 
75C0:  MOVLW  0A
75C2:  MOVLB  1
75C4:  MOVWF  xE7
75C6:  CLRF   xE8
75C8:  MOVLB  0
75CA:  CALL   06C8
....................     
....................    FlashingFlag = 1; 
75CE:  BSF    1A.1
....................    //output_bit(P485ctrl,0); 
....................    sequence = end_sq; 
75D0:  MOVFF  66,6E
....................    Address = 1; 
75D4:  MOVLW  01
75D6:  MOVWF  6F
....................  
....................    Output.B1 = 1; 
75D8:  MOVLB  1
75DA:  BSF    x19.0
....................    Output.B2 = 1; 
75DC:  BSF    x19.1
....................    Output.B3 = 1; 
75DE:  BSF    x19.2
....................    Output.B4 = 1; 
75E0:  BSF    x19.3
....................    Output.B5 = 1; 
75E2:  BSF    x19.4
....................    Output.B6 = 1; 
75E4:  BSF    x19.5
....................    Output.B7 = 1; 
75E6:  BSF    x19.6
....................    Output.B8 = 1; 
75E8:  BSF    x19.7
....................    Output.B9 = 1; 
75EA:  BSF    x1A.0
....................    Output.B10 = 1; 
75EC:  BSF    x1A.1
....................    Output.B11 = 1; 
75EE:  BSF    x1A.2
....................    Output.B12 = 1; 
75F0:  BSF    x1A.3
....................    Output.B13 = 1; 
75F2:  BSF    x1A.4
....................    Output.B14 = 1; 
75F4:  BSF    x1A.5
....................    Output.B15 = 1; 
75F6:  BSF    x1A.6
....................    Output.B16 = 1; 
75F8:  BSF    x1A.7
....................    Output.B17 = 1; 
75FA:  BSF    x1B.0
....................    Output.B18 = 1; 
75FC:  BSF    x1B.1
....................    Output.B19 = 1; 
75FE:  BSF    x1B.2
....................    Output.B20 = 1; 
7600:  BSF    x1B.3
....................     
....................    //////////////////// 
....................    In.B1 = 0; 
7602:  BCF    x35.0
....................    In.B2 = 0; 
7604:  BCF    x35.1
....................    In.B3 = 0; 
7606:  BCF    x35.2
....................    In.B4 = 0; 
7608:  BCF    x35.3
....................    In.B5 = 0; 
760A:  BCF    x35.4
....................    In.B6 = 0; 
760C:  BCF    x35.5
....................    In.B7 = 0; 
760E:  BCF    x35.6
....................    In.B8 = 0; 
7610:  BCF    x35.7
....................    In.B9 = 0; 
7612:  BCF    x36.0
....................    In.B10 = 0; 
7614:  BCF    x36.1
....................    In.B11 = 0; 
7616:  BCF    x36.2
....................    In.B12 = 0; 
7618:  BCF    x36.3
....................    In.B13 = 0; 
761A:  BCF    x36.4
....................    In.B14 = 0; 
761C:  BCF    x36.5
....................    In.B15 = 0; 
761E:  BCF    x36.6
....................    In.B16 = 0; 
7620:  BCF    x36.7
....................    In.B17 = 0; 
7622:  BCF    x37.0
....................    In.B18 = 0; 
7624:  BCF    x37.1
....................    In.B19 = 0; 
7626:  BCF    x37.2
....................    In.B20 = 0; 
7628:  BCF    x37.3
....................     
....................    //////////////////// 
....................    In2.B1 = 0; 
762A:  BCF    x39.0
....................    In2.B2 = 0; 
762C:  BCF    x39.1
....................    In2.B3 = 0; 
762E:  BCF    x39.2
....................    In2.B4 = 0; 
7630:  BCF    x39.3
....................    In2.B5 = 0; 
7632:  BCF    x39.4
....................    In2.B6 = 0; 
7634:  BCF    x39.5
....................    In2.B7 = 0; 
7636:  BCF    x39.6
....................    In2.B8 = 0; 
7638:  BCF    x39.7
....................    In2.B9 = 0; 
763A:  BCF    x3A.0
....................    In2.B10 = 0; 
763C:  BCF    x3A.1
....................    In2.B11 = 0; 
763E:  BCF    x3A.2
....................    In2.B12 = 0; 
7640:  BCF    x3A.3
....................    In2.B13 = 0; 
7642:  BCF    x3A.4
....................    In2.B14 = 0; 
7644:  BCF    x3A.5
....................    In2.B15 = 0; 
7646:  BCF    x3A.6
....................    In2.B16 = 0; 
7648:  BCF    x3A.7
....................    In2.B17 = 0; 
764A:  BCF    x3B.0
....................    In2.B18 = 0; 
764C:  BCF    x3B.1
....................    In2.B19 = 0; 
764E:  BCF    x3B.2
....................    In2.B20 = 0; 
7650:  BCF    x3B.3
....................     
....................    //////////////////////// 
....................    Ack.B1 = 0; 
7652:  BCF    x31.0
....................    Ack.B2 = 0; 
7654:  BCF    x31.1
....................    Ack.B3 = 0; 
7656:  BCF    x31.2
....................    Ack.B4 = 0; 
7658:  BCF    x31.3
....................    Ack.B5 = 0; 
765A:  BCF    x31.4
....................    Ack.B6 = 0; 
765C:  BCF    x31.5
....................    Ack.B7 = 0; 
765E:  BCF    x31.6
....................    Ack.B8 = 0; 
7660:  BCF    x31.7
....................    Ack.B9 = 0; 
7662:  BCF    x32.0
....................    Ack.B10 = 0; 
7664:  BCF    x32.1
....................    Ack.B11 = 0; 
7666:  BCF    x32.2
....................    Ack.B12 = 0; 
7668:  BCF    x32.3
....................    Ack.B13 = 0; 
766A:  BCF    x32.4
....................    Ack.B14 = 0; 
766C:  BCF    x32.5
....................    Ack.B15 = 0; 
766E:  BCF    x32.6
....................    Ack.B16 = 0; 
7670:  BCF    x32.7
....................    Ack.B17 = 0; 
7672:  BCF    x33.0
....................    Ack.B18 = 0; 
7674:  BCF    x33.1
....................    Ack.B19 = 0; 
7676:  BCF    x33.2
....................    Ack.B20 = 0; 
7678:  BCF    x33.3
....................   
....................    Inputt.B1 = 0; 
767A:  BCF    x15.0
....................    Inputt.B2 = 0; 
767C:  BCF    x15.1
....................    Inputt.B3 = 0; 
767E:  BCF    x15.2
....................    Inputt.B4 = 0; 
7680:  BCF    x15.3
....................    Inputt.B5 = 0; 
7682:  BCF    x15.4
....................    Inputt.B6 = 0; 
7684:  BCF    x15.5
....................    Inputt.B7 = 0; 
7686:  BCF    x15.6
....................    Inputt.B8 = 0; 
7688:  BCF    x15.7
....................    Inputt.B9 = 0; 
768A:  BCF    x16.0
....................    Inputt.B10 = 0; 
768C:  BCF    x16.1
....................    Inputt.B11 = 0; 
768E:  BCF    x16.2
....................    Inputt.B12 = 0; 
7690:  BCF    x16.3
....................    Inputt.B13 = 0; 
7692:  BCF    x16.4
....................    Inputt.B14 = 0; 
7694:  BCF    x16.5
....................    Inputt.B15 = 0; 
7696:  BCF    x16.6
....................    Inputt.B16 = 0; 
7698:  BCF    x16.7
....................    Inputt.B17 = 0; 
769A:  BCF    x17.0
....................    Inputt.B18 = 0; 
769C:  BCF    x17.1
....................    Inputt.B19 = 0; 
769E:  BCF    x17.2
....................    Inputt.B20 = 0; 
76A0:  BCF    x17.3
....................     
....................  
....................     /////// read setting ////////// 
....................  
....................    if(read_eeprom(0x00) == 0x0F) 
76A2:  MOVFF  FF2,1E7
76A6:  BCF    FF2.7
76A8:  CLRF   FA9
76AA:  BCF    FA6.6
76AC:  BCF    FA6.7
76AE:  BSF    FA6.0
76B0:  MOVF   FA8,W
76B2:  BTFSC  xE7.7
76B4:  BSF    FF2.7
76B6:  SUBLW  0F
76B8:  BNZ   76C4
....................    { 
....................       Read_Config(); 
76BA:  MOVLB  0
76BC:  CALL   06DC
....................    } 
76C0:  BRA    7AA8
76C2:  MOVLB  1
....................    else 
....................    { 
....................       FlashingRateTime = 25; 
76C4:  MOVLW  19
76C6:  MOVWF  1B
....................       AutoAck = 0xF0; //not use auto ack 
76C8:  MOVLW  F0
76CA:  MOVWF  60
....................       Address = 0x01; 
76CC:  MOVLW  01
76CE:  MOVWF  6F
....................  
....................       AutoAckTime = 5; 
76D0:  MOVLW  05
76D2:  MOVWF  61
....................       FlashingRate = 25; 
76D4:  MOVLW  19
76D6:  MOVWF  62
....................       NoOfPoint = 20; 
76D8:  MOVLW  14
76DA:  MOVWF  63
....................       char i; 
....................       for(i =0; i<=NoOfPoint; i++) 
76DC:  CLRF   xE5
76DE:  MOVF   xE5,W
76E0:  SUBWF  63,W
76E2:  BNC   76FE
....................       { 
....................          FaultDelayTime[i] = 0; 
76E4:  BCF    FD8.0
76E6:  RLCF   xE5,W
76E8:  CLRF   03
76EA:  ADDLW  91
76EC:  MOVWF  FE9
76EE:  MOVLW  01
76F0:  ADDWFC 03,W
76F2:  MOVWF  FEA
76F4:  CLRF   FEC
76F6:  MOVF   FED,F
76F8:  CLRF   FEF
76FA:  INCF   xE5,F
76FC:  BRA    76DE
....................       } 
....................  
....................  
....................       InputType.B1 = 1; 
76FE:  BSF    x1D.0
....................       InputType.B2 = 1; 
7700:  BSF    x1D.1
....................       InputType.B3 = 1; 
7702:  BSF    x1D.2
....................       InputType.B4 = 1; 
7704:  BSF    x1D.3
....................       InputType.B5 = 1; 
7706:  BSF    x1D.4
....................       InputType.B6 = 1; 
7708:  BSF    x1D.5
....................       InputType.B7 = 1; 
770A:  BSF    x1D.6
....................       InputType.B8 = 1; 
770C:  BSF    x1D.7
....................       InputType.B9 = 1; 
770E:  BSF    x1E.0
....................       InputType.B10 = 1; 
7710:  BSF    x1E.1
....................       InputType.B11 = 1; 
7712:  BSF    x1E.2
....................       InputType.B12 = 1; 
7714:  BSF    x1E.3
....................       InputType.B13 = 1; 
7716:  BSF    x1E.4
....................       InputType.B14 = 1; 
7718:  BSF    x1E.5
....................       InputType.B15 = 1; 
771A:  BSF    x1E.6
....................       InputType.B16 = 1; 
771C:  BSF    x1E.7
....................       InputType.B17 = 1; 
771E:  BSF    x1F.0
....................       InputType.B18 = 1; 
7720:  BSF    x1F.1
....................       InputType.B19 = 1; 
7722:  BSF    x1F.2
....................       InputType.B20 = 1; 
7724:  BSF    x1F.3
....................        
....................       FaultNCNO[1] = 1; 
7726:  BSF    xCD.1
....................       FaultNCNO[2] = 1; 
7728:  BSF    xCD.2
....................       FaultNCNO[3] = 1; 
772A:  BSF    xCD.3
....................       FaultNCNO[4] = 1; 
772C:  BSF    xCD.4
....................       FaultNCNO[5] = 1; 
772E:  BSF    xCD.5
....................       FaultNCNO[6] = 1; 
7730:  BSF    xCD.6
....................       FaultNCNO[7] = 1; 
7732:  BSF    xCD.7
....................       FaultNCNO[8] = 1; 
7734:  BSF    xCE.0
....................       FaultNCNO[9] = 1; 
7736:  BSF    xCE.1
....................       FaultNCNO[10] = 1; 
7738:  BSF    xCE.2
....................       FaultNCNO[11] = 1; 
773A:  BSF    xCE.3
....................       FaultNCNO[12] = 1; 
773C:  BSF    xCE.4
....................       FaultNCNO[13] = 1; 
773E:  BSF    xCE.5
....................       FaultNCNO[14] = 1; 
7740:  BSF    xCE.6
....................       FaultNCNO[15] = 1; 
7742:  BSF    xCE.7
....................       FaultNCNO[16] = 1; 
7744:  BSF    xCF.0
....................       FaultNCNO[17] = 1; 
7746:  BSF    xCF.1
....................       FaultNCNO[18] = 1; 
7748:  BSF    xCF.2
....................       FaultNCNO[19] = 1; 
774A:  BSF    xCF.3
....................       FaultNCNO[20] = 1; 
774C:  BSF    xCF.4
....................       ///////////////////////////// 
....................       FaultType.B1 = 1; 
774E:  BSF    x21.0
....................       FaultType.B2= 1; 
7750:  BSF    x21.1
....................       FaultType.B3 = 1; 
7752:  BSF    x21.2
....................       FaultType.B4 = 1; 
7754:  BSF    x21.3
....................       FaultType.B5 = 1; 
7756:  BSF    x21.4
....................       FaultType.B6 = 1; 
7758:  BSF    x21.5
....................       FaultType.B7 = 1; 
775A:  BSF    x21.6
....................       FaultType.B8 = 1; 
775C:  BSF    x21.7
....................       FaultType.B9 = 1; 
775E:  BSF    x22.0
....................       FaultType.B10 = 1; 
7760:  BSF    x22.1
....................       FaultType.B11 = 1; 
7762:  BSF    x22.2
....................       FaultType.B12 = 1; 
7764:  BSF    x22.3
....................       FaultType.B13 = 1; 
7766:  BSF    x22.4
....................       FaultType.B14 = 1; 
7768:  BSF    x22.5
....................       FaultType.B15 = 1; 
776A:  BSF    x22.6
....................       FaultType.B16 = 1; 
776C:  BSF    x22.7
....................       FaultType.B17 = 1; 
776E:  BSF    x23.0
....................       FaultType.B18 = 1; 
7770:  BSF    x23.1
....................       FaultType.B19 = 1; 
7772:  BSF    x23.2
....................       FaultType.B20 = 1; 
7774:  BSF    x23.3
....................        
....................       //////////////////////////// 
....................       OutputType.B1 = 1; 
7776:  BSF    x25.0
....................       OutputType.B2 = 1; 
7778:  BSF    x25.1
....................       OutputType.B3 = 1; 
777A:  BSF    x25.2
....................       OutputType.B4 = 1; 
777C:  BSF    x25.3
....................       OutputType.B5 = 1; 
777E:  BSF    x25.4
....................       OutputType.B6 = 1; 
7780:  BSF    x25.5
....................       OutputType.B7 = 1; 
7782:  BSF    x25.6
....................       OutputType.B8 = 1; 
7784:  BSF    x25.7
....................       OutputType.B9 = 1; 
7786:  BSF    x26.0
....................       OutputType.B10 = 1; 
7788:  BSF    x26.1
....................       OutputType.B11 = 1; 
778A:  BSF    x26.2
....................       OutputType.B12 = 1; 
778C:  BSF    x26.3
....................       OutputType.B13 = 1; 
778E:  BSF    x26.4
....................       OutputType.B14 = 1; 
7790:  BSF    x26.5
....................       OutputType.B15 = 1; 
7792:  BSF    x26.6
....................       OutputType.B16 = 1; 
7794:  BSF    x26.7
....................       OutputType.B17 = 1; 
7796:  BSF    x27.0
....................       OutputType.B18 = 1; 
7798:  BSF    x27.1
....................       OutputType.B19 = 1; 
779A:  BSF    x27.2
....................       OutputType.B20 = 1; 
779C:  BSF    x27.3
....................   
....................       ///////////////////////////// 
....................       OutputBoth.B1 = 1; 
779E:  BSF    x29.0
....................       OutputBoth.B2 = 1; 
77A0:  BSF    x29.1
....................       OutputBoth.B3 = 1; 
77A2:  BSF    x29.2
....................       OutputBoth.B4 = 1; 
77A4:  BSF    x29.3
....................       OutputBoth.B5 = 1; 
77A6:  BSF    x29.4
....................       OutputBoth.B6 = 1; 
77A8:  BSF    x29.5
....................       OutputBoth.B7 = 1; 
77AA:  BSF    x29.6
....................       OutputBoth.B8 = 1; 
77AC:  BSF    x29.7
....................       OutputBoth.B9 = 1; 
77AE:  BSF    x2A.0
....................       OutputBoth.B10 = 1; 
77B0:  BSF    x2A.1
....................       OutputBoth.B11 = 1; 
77B2:  BSF    x2A.2
....................       OutputBoth.B12 = 1; 
77B4:  BSF    x2A.3
....................       OutputBoth.B13 = 1; 
77B6:  BSF    x2A.4
....................       OutputBoth.B14 = 1; 
77B8:  BSF    x2A.5
....................       OutputBoth.B15 = 1; 
77BA:  BSF    x2A.6
....................       OutputBoth.B16 = 1; 
77BC:  BSF    x2A.7
....................       OutputBoth.B17 = 1; 
77BE:  BSF    x2B.0
....................       OutputBoth.B18 = 1; 
77C0:  BSF    x2B.1
....................       OutputBoth.B19 = 1; 
77C2:  BSF    x2B.2
....................       OutputBoth.B20 = 1; 
77C4:  BSF    x2B.3
....................        
....................       ////////////////////////////////////////////// 
....................       AlarmIndicator.B1 = 1; 
77C6:  BSF    x2D.0
....................       AlarmIndicator.B2 = 1; 
77C8:  BSF    x2D.1
....................       AlarmIndicator.B3 = 1; 
77CA:  BSF    x2D.2
....................       AlarmIndicator.B4 = 1; 
77CC:  BSF    x2D.3
....................       AlarmIndicator.B5 = 1; 
77CE:  BSF    x2D.4
....................       AlarmIndicator.B6 = 1; 
77D0:  BSF    x2D.5
....................       AlarmIndicator.B7 = 1; 
77D2:  BSF    x2D.6
....................       AlarmIndicator.B8 = 1; 
77D4:  BSF    x2D.7
....................       AlarmIndicator.B9 = 1; 
77D6:  BSF    x2E.0
....................       AlarmIndicator.B10 = 1; 
77D8:  BSF    x2E.1
....................       AlarmIndicator.B11 = 1; 
77DA:  BSF    x2E.2
....................       AlarmIndicator.B12 = 1; 
77DC:  BSF    x2E.3
....................       AlarmIndicator.B13 = 1; 
77DE:  BSF    x2E.4
....................       AlarmIndicator.B14 = 1; 
77E0:  BSF    x2E.5
....................       AlarmIndicator.B15 = 1; 
77E2:  BSF    x2E.6
....................       AlarmIndicator.B16 = 1; 
77E4:  BSF    x2E.7
....................       AlarmIndicator.B17 = 1; 
77E6:  BSF    x2F.0
....................       AlarmIndicator.B18 = 1; 
77E8:  BSF    x2F.1
....................       AlarmIndicator.B19 = 1; 
77EA:  BSF    x2F.2
....................       AlarmIndicator.B20 = 1; 
77EC:  BSF    x2F.3
....................        
....................       ///////////// JACK/////////////////// 
....................    EEpDat = read_eeprom(0x10); 
77EE:  MOVFF  FF2,1E7
77F2:  BCF    FF2.7
77F4:  MOVLW  10
77F6:  MOVWF  FA9
77F8:  BCF    FA6.6
77FA:  BCF    FA6.7
77FC:  BSF    FA6.0
77FE:  MOVF   FA8,W
7800:  BTFSC  xE7.7
7802:  BSF    FF2.7
7804:  MOVWF  39
....................    //Red1_8 = EEpDat; 
....................    RED_Colour.B1 = EEpDat; 
7806:  BCF    x45.0
7808:  BTFSC  39.0
780A:  BSF    x45.0
....................    RED_Colour.B2 = EEpDat >> 1; 
780C:  BCF    FD8.0
780E:  RRCF   39,W
7810:  BCF    x45.1
7812:  BTFSC  FE8.0
7814:  BSF    x45.1
....................    RED_Colour.B3 = EEpDat >> 2; 
7816:  RRCF   39,W
7818:  MOVWF  00
781A:  RRCF   00,F
781C:  MOVLW  3F
781E:  ANDWF  00,F
7820:  BCF    x45.2
7822:  BTFSC  00.0
7824:  BSF    x45.2
....................    RED_Colour.B4 = EEpDat >> 3; 
7826:  RRCF   39,W
7828:  MOVWF  00
782A:  RRCF   00,F
782C:  RRCF   00,F
782E:  MOVLW  1F
7830:  ANDWF  00,F
7832:  BCF    x45.3
7834:  BTFSC  00.0
7836:  BSF    x45.3
....................    RED_Colour.B5 = EEpDat >> 4; 
7838:  SWAPF  39,W
783A:  MOVWF  00
783C:  MOVLW  0F
783E:  ANDWF  00,F
7840:  BCF    x45.4
7842:  BTFSC  00.0
7844:  BSF    x45.4
....................    RED_Colour.B6 = EEpDat >> 5; 
7846:  SWAPF  39,W
7848:  MOVWF  00
784A:  RRCF   00,F
784C:  MOVLW  07
784E:  ANDWF  00,F
7850:  BCF    x45.5
7852:  BTFSC  00.0
7854:  BSF    x45.5
....................    RED_Colour.B7 = EEpDat >> 6; 
7856:  SWAPF  39,W
7858:  MOVWF  00
785A:  RRCF   00,F
785C:  RRCF   00,F
785E:  MOVLW  03
7860:  ANDWF  00,F
7862:  BCF    x45.6
7864:  BTFSC  00.0
7866:  BSF    x45.6
....................    RED_Colour.B8 = EEpDat >> 7; 
7868:  CLRF   00
786A:  BTFSC  39.7
786C:  BSF    00.0
786E:  BCF    x45.7
7870:  BTFSC  00.0
7872:  BSF    x45.7
....................     
....................    EEpDat = read_eeprom(0x11); 
7874:  MOVFF  FF2,1E7
7878:  BCF    FF2.7
787A:  MOVLW  11
787C:  MOVWF  FA9
787E:  BCF    FA6.6
7880:  BCF    FA6.7
7882:  BSF    FA6.0
7884:  MOVF   FA8,W
7886:  BTFSC  xE7.7
7888:  BSF    FF2.7
788A:  MOVWF  39
....................    //Green9_10 = EEpDat; 
....................    RED_Colour.B9 = EEpDat; 
788C:  BCF    x46.0
788E:  BTFSC  39.0
7890:  BSF    x46.0
....................    RED_Colour.B10 = EEpDat >> 1; 
7892:  BCF    FD8.0
7894:  RRCF   39,W
7896:  BCF    x46.1
7898:  BTFSC  FE8.0
789A:  BSF    x46.1
....................     
....................     
....................    EEpDat = read_eeprom(0x12); 
789C:  MOVFF  FF2,1E7
78A0:  BCF    FF2.7
78A2:  MOVLW  12
78A4:  MOVWF  FA9
78A6:  BCF    FA6.6
78A8:  BCF    FA6.7
78AA:  BSF    FA6.0
78AC:  MOVF   FA8,W
78AE:  BTFSC  xE7.7
78B0:  BSF    FF2.7
78B2:  MOVWF  39
....................    //Red11_18 = EEpDat; 
....................    RED_Colour.B11 = EEpDat; 
78B4:  BCF    x46.2
78B6:  BTFSC  39.0
78B8:  BSF    x46.2
....................    RED_Colour.B12 = EEpDat >> 1; 
78BA:  BCF    FD8.0
78BC:  RRCF   39,W
78BE:  BCF    x46.3
78C0:  BTFSC  FE8.0
78C2:  BSF    x46.3
....................    RED_Colour.B13 = EEpDat >> 2; 
78C4:  RRCF   39,W
78C6:  MOVWF  00
78C8:  RRCF   00,F
78CA:  MOVLW  3F
78CC:  ANDWF  00,F
78CE:  BCF    x46.4
78D0:  BTFSC  00.0
78D2:  BSF    x46.4
....................    RED_Colour.B14 = EEpDat >> 3; 
78D4:  RRCF   39,W
78D6:  MOVWF  00
78D8:  RRCF   00,F
78DA:  RRCF   00,F
78DC:  MOVLW  1F
78DE:  ANDWF  00,F
78E0:  BCF    x46.5
78E2:  BTFSC  00.0
78E4:  BSF    x46.5
....................    RED_Colour.B15 = EEpDat >> 4; 
78E6:  SWAPF  39,W
78E8:  MOVWF  00
78EA:  MOVLW  0F
78EC:  ANDWF  00,F
78EE:  BCF    x46.6
78F0:  BTFSC  00.0
78F2:  BSF    x46.6
....................    RED_Colour.B16 = EEpDat >> 5; 
78F4:  SWAPF  39,W
78F6:  MOVWF  00
78F8:  RRCF   00,F
78FA:  MOVLW  07
78FC:  ANDWF  00,F
78FE:  BCF    x46.7
7900:  BTFSC  00.0
7902:  BSF    x46.7
....................    RED_Colour.B17 = EEpDat >> 6; 
7904:  SWAPF  39,W
7906:  MOVWF  00
7908:  RRCF   00,F
790A:  RRCF   00,F
790C:  MOVLW  03
790E:  ANDWF  00,F
7910:  BCF    x47.0
7912:  BTFSC  00.0
7914:  BSF    x47.0
....................    RED_Colour.B18 = EEpDat >> 7; 
7916:  CLRF   00
7918:  BTFSC  39.7
791A:  BSF    00.0
791C:  BCF    x47.1
791E:  BTFSC  00.0
7920:  BSF    x47.1
....................     
....................    EEpDat = read_eeprom(0x13); 
7922:  MOVFF  FF2,1E7
7926:  BCF    FF2.7
7928:  MOVLW  13
792A:  MOVWF  FA9
792C:  BCF    FA6.6
792E:  BCF    FA6.7
7930:  BSF    FA6.0
7932:  MOVF   FA8,W
7934:  BTFSC  xE7.7
7936:  BSF    FF2.7
7938:  MOVWF  39
....................    //Red19_20 = EEpDat; 
....................    RED_Colour.B19 = EEpDat; 
793A:  BCF    x47.2
793C:  BTFSC  39.0
793E:  BSF    x47.2
....................    RED_Colour.B20 = EEpDat >> 1; 
7940:  BCF    FD8.0
7942:  RRCF   39,W
7944:  BCF    x47.3
7946:  BTFSC  FE8.0
7948:  BSF    x47.3
....................     
....................     
....................    EEpDat = read_eeprom(0x14); 
794A:  MOVFF  FF2,1E7
794E:  BCF    FF2.7
7950:  MOVLW  14
7952:  MOVWF  FA9
7954:  BCF    FA6.6
7956:  BCF    FA6.7
7958:  BSF    FA6.0
795A:  MOVF   FA8,W
795C:  BTFSC  xE7.7
795E:  BSF    FF2.7
7960:  MOVWF  39
....................    //Green1_8 = EEpDat; 
....................    GREEN_Colour.B1 = EEpDat; 
7962:  BCF    x49.0
7964:  BTFSC  39.0
7966:  BSF    x49.0
....................    GREEN_Colour.B2 = EEpDat >> 1; 
7968:  BCF    FD8.0
796A:  RRCF   39,W
796C:  BCF    x49.1
796E:  BTFSC  FE8.0
7970:  BSF    x49.1
....................    GREEN_Colour.B3 = EEpDat >> 2; 
7972:  RRCF   39,W
7974:  MOVWF  00
7976:  RRCF   00,F
7978:  MOVLW  3F
797A:  ANDWF  00,F
797C:  BCF    x49.2
797E:  BTFSC  00.0
7980:  BSF    x49.2
....................    GREEN_Colour.B4 = EEpDat >> 3; 
7982:  RRCF   39,W
7984:  MOVWF  00
7986:  RRCF   00,F
7988:  RRCF   00,F
798A:  MOVLW  1F
798C:  ANDWF  00,F
798E:  BCF    x49.3
7990:  BTFSC  00.0
7992:  BSF    x49.3
....................    GREEN_Colour.B5 = EEpDat >> 4; 
7994:  SWAPF  39,W
7996:  MOVWF  00
7998:  MOVLW  0F
799A:  ANDWF  00,F
799C:  BCF    x49.4
799E:  BTFSC  00.0
79A0:  BSF    x49.4
....................    GREEN_Colour.B6 = EEpDat >> 5; 
79A2:  SWAPF  39,W
79A4:  MOVWF  00
79A6:  RRCF   00,F
79A8:  MOVLW  07
79AA:  ANDWF  00,F
79AC:  BCF    x49.5
79AE:  BTFSC  00.0
79B0:  BSF    x49.5
....................    GREEN_Colour.B7 = EEpDat >> 6; 
79B2:  SWAPF  39,W
79B4:  MOVWF  00
79B6:  RRCF   00,F
79B8:  RRCF   00,F
79BA:  MOVLW  03
79BC:  ANDWF  00,F
79BE:  BCF    x49.6
79C0:  BTFSC  00.0
79C2:  BSF    x49.6
....................    GREEN_Colour.B8 = EEpDat >> 7; 
79C4:  CLRF   00
79C6:  BTFSC  39.7
79C8:  BSF    00.0
79CA:  BCF    x49.7
79CC:  BTFSC  00.0
79CE:  BSF    x49.7
....................     
....................    EEpDat = read_eeprom(0x15); 
79D0:  MOVFF  FF2,1E7
79D4:  BCF    FF2.7
79D6:  MOVLW  15
79D8:  MOVWF  FA9
79DA:  BCF    FA6.6
79DC:  BCF    FA6.7
79DE:  BSF    FA6.0
79E0:  MOVF   FA8,W
79E2:  BTFSC  xE7.7
79E4:  BSF    FF2.7
79E6:  MOVWF  39
....................    //Green9_10 = EEpDat; 
....................    GREEN_Colour.B9 = EEpDat; 
79E8:  BCF    x4A.0
79EA:  BTFSC  39.0
79EC:  BSF    x4A.0
....................    GREEN_Colour.B10 = EEpDat >> 1; 
79EE:  BCF    FD8.0
79F0:  RRCF   39,W
79F2:  BCF    x4A.1
79F4:  BTFSC  FE8.0
79F6:  BSF    x4A.1
....................    
....................    EEpDat = read_eeprom(0x16); 
79F8:  MOVFF  FF2,1E7
79FC:  BCF    FF2.7
79FE:  MOVLW  16
7A00:  MOVWF  FA9
7A02:  BCF    FA6.6
7A04:  BCF    FA6.7
7A06:  BSF    FA6.0
7A08:  MOVF   FA8,W
7A0A:  BTFSC  xE7.7
7A0C:  BSF    FF2.7
7A0E:  MOVWF  39
....................    //Green11_18 = EEpDat; 
....................    GREEN_Colour.B11 = EEpDat; 
7A10:  BCF    x4A.2
7A12:  BTFSC  39.0
7A14:  BSF    x4A.2
....................    GREEN_Colour.B12 = EEpDat >> 1; 
7A16:  BCF    FD8.0
7A18:  RRCF   39,W
7A1A:  BCF    x4A.3
7A1C:  BTFSC  FE8.0
7A1E:  BSF    x4A.3
....................    GREEN_Colour.B13 = EEpDat >> 2; 
7A20:  RRCF   39,W
7A22:  MOVWF  00
7A24:  RRCF   00,F
7A26:  MOVLW  3F
7A28:  ANDWF  00,F
7A2A:  BCF    x4A.4
7A2C:  BTFSC  00.0
7A2E:  BSF    x4A.4
....................    GREEN_Colour.B14 = EEpDat >> 3; 
7A30:  RRCF   39,W
7A32:  MOVWF  00
7A34:  RRCF   00,F
7A36:  RRCF   00,F
7A38:  MOVLW  1F
7A3A:  ANDWF  00,F
7A3C:  BCF    x4A.5
7A3E:  BTFSC  00.0
7A40:  BSF    x4A.5
....................    GREEN_Colour.B15 = EEpDat >> 4; 
7A42:  SWAPF  39,W
7A44:  MOVWF  00
7A46:  MOVLW  0F
7A48:  ANDWF  00,F
7A4A:  BCF    x4A.6
7A4C:  BTFSC  00.0
7A4E:  BSF    x4A.6
....................    GREEN_Colour.B16 = EEpDat >> 5; 
7A50:  SWAPF  39,W
7A52:  MOVWF  00
7A54:  RRCF   00,F
7A56:  MOVLW  07
7A58:  ANDWF  00,F
7A5A:  BCF    x4A.7
7A5C:  BTFSC  00.0
7A5E:  BSF    x4A.7
....................    GREEN_Colour.B17 = EEpDat >> 6; 
7A60:  SWAPF  39,W
7A62:  MOVWF  00
7A64:  RRCF   00,F
7A66:  RRCF   00,F
7A68:  MOVLW  03
7A6A:  ANDWF  00,F
7A6C:  BCF    x4B.0
7A6E:  BTFSC  00.0
7A70:  BSF    x4B.0
....................    GREEN_Colour.B18 = EEpDat >> 7; 
7A72:  CLRF   00
7A74:  BTFSC  39.7
7A76:  BSF    00.0
7A78:  BCF    x4B.1
7A7A:  BTFSC  00.0
7A7C:  BSF    x4B.1
....................     
....................    EEpDat = read_eeprom(0x17); 
7A7E:  MOVFF  FF2,1E7
7A82:  BCF    FF2.7
7A84:  MOVLW  17
7A86:  MOVWF  FA9
7A88:  BCF    FA6.6
7A8A:  BCF    FA6.7
7A8C:  BSF    FA6.0
7A8E:  MOVF   FA8,W
7A90:  BTFSC  xE7.7
7A92:  BSF    FF2.7
7A94:  MOVWF  39
....................    //Green19_20 = EEpDat; 
....................    GREEN_Colour.B19 = EEpDat; 
7A96:  BCF    x4B.2
7A98:  BTFSC  39.0
7A9A:  BSF    x4B.2
....................    GREEN_Colour.B20 = EEpDat >> 1; 
7A9C:  BCF    FD8.0
7A9E:  RRCF   39,W
7AA0:  BCF    x4B.3
7AA2:  BTFSC  FE8.0
7AA4:  BSF    x4B.3
7AA6:  MOVLB  0
....................     
....................    ///////////// JACK///////////////////////////////////// 
....................        
....................    } 
....................  
....................     
....................    set_tris_a (0b00000000); //PORTA SET TO OUTPUT 
7AA8:  MOVLW  00
7AAA:  MOVWF  F92
....................    set_tris_b (0b00000000); //PORTA SET TO OUTPUT 
7AAC:  MOVWF  F93
....................    //set_tris_c (0b11111111); //PORTA SET TO OUTPUT 
....................    enable_interrupts(GLOBAL); 
7AAE:  MOVLW  C0
7AB0:  IORWF  FF2,F
....................    setup_wdt(WDT_ON); 
7AB2:  BSF    FD1.0
....................    //Read_input(); restart_wdt(); 
....................    output_bit(Pbuzzer,OffRelay);   //Clear Buzzer 
7AB4:  BCF    F89.4
7AB6:  BCF    F92.4
....................    output_bit(Pbell,OffRelay);     //Clear Bell 
7AB8:  BCF    F89.3
7ABA:  BCF    F92.3
....................    output_bit(P485ctrl,0); 
7ABC:  BCF    F8A.3
7ABE:  BCF    F93.3
....................    //output_bit(P485ctrl,0); 
....................    //output_bit(PIN_B4,0); //jj bedug RLY SUP. toggle 
....................     
....................    //Send_Ouput(); 
....................    //delay_ms(1000); 
....................    /* 
....................     unsigned char i; 
....................    for(i=0;i<=25;i++) 
....................    { 
....................       FaultNow[i]=1; 
....................       FaultAgo[i]=1; 
....................    } 
....................    Anal_Function(); restart_wdt(); 
....................    Send_Ouput(); restart_wdt(); 
....................     
....................    Input1_8 = 0x00; 
....................    Input9_10 = 0x00; 
....................    Input9_16 = 0x00; 
....................    Input11_18 = 0x00; 
....................    Input17_24 = 0x00; 
....................    Input19_20 = 0x00; 
....................    */ 
....................    IO_OUTPUT_A(IO_DEVICE_2, 0xff); 
7AC0:  MOVLW  04
7AC2:  MOVLB  1
7AC4:  MOVWF  xEF
7AC6:  SETF   xF0
7AC8:  MOVLB  0
7ACA:  CALL   14C2
....................    IO_OUTPUT_B(IO_DEVICE_2, 0xff); 
7ACE:  MOVLW  04
7AD0:  MOVLB  1
7AD2:  MOVWF  xEF
7AD4:  SETF   xF0
7AD6:  MOVLB  0
7AD8:  CALL   14D8
....................              
....................    IO_OUTPUT_A(IO_DEVICE_3, 0xff); 
7ADC:  MOVLW  06
7ADE:  MOVLB  1
7AE0:  MOVWF  xEF
7AE2:  SETF   xF0
7AE4:  MOVLB  0
7AE6:  CALL   14C2
....................    IO_OUTPUT_B(IO_DEVICE_3, 0xff); 
7AEA:  MOVLW  06
7AEC:  MOVLB  1
7AEE:  MOVWF  xEF
7AF0:  SETF   xF0
7AF2:  MOVLB  0
7AF4:  CALL   14D8
....................    
....................    IO_OUTPUT_A(IO_DEVICE_5, 0xff);   
7AF8:  MOVLW  0A
7AFA:  MOVLB  1
7AFC:  MOVWF  xEF
7AFE:  SETF   xF0
7B00:  MOVLB  0
7B02:  CALL   14C2
....................    IO_OUTPUT_B(IO_DEVICE_5, 0xff); 
7B06:  MOVLW  0A
7B08:  MOVLB  1
7B0A:  MOVWF  xEF
7B0C:  SETF   xF0
7B0E:  MOVLB  0
7B10:  CALL   14D8
....................              
....................    IO_OUTPUT_A(IO_DEVICE_4, 0xff); 
7B14:  MOVLW  08
7B16:  MOVLB  1
7B18:  MOVWF  xEF
7B1A:  SETF   xF0
7B1C:  MOVLB  0
7B1E:  CALL   14C2
....................    IO_OUTPUT_B(IO_DEVICE_4, 0xff); 
7B22:  MOVLW  08
7B24:  MOVLB  1
7B26:  MOVWF  xEF
7B28:  SETF   xF0
7B2A:  MOVLB  0
7B2C:  CALL   14D8
....................     
....................    delay_ms(500); 
7B30:  MOVLW  02
7B32:  MOVLB  1
7B34:  MOVWF  xE7
7B36:  MOVLW  FA
7B38:  MOVWF  xEF
7B3A:  MOVLB  0
7B3C:  CALL   05BE
7B40:  MOVLB  1
7B42:  DECFSZ xE7,F
7B44:  BRA    7B36
....................     
....................    // jj 
....................    char i; 
....................    for(i=1;i<=20;i++) 
7B46:  MOVLW  01
7B48:  MOVWF  xE6
7B4A:  MOVF   xE6,W
7B4C:  SUBLW  14
7B4E:  BTFSS  FD8.0
7B50:  BRA    7CCE
....................    { 
....................       FaultAgo[i] = 0; 
7B52:  MOVFF  1E6,1EB
7B56:  CLRF   xEC
7B58:  MOVLW  01
7B5A:  MOVWF  xEE
7B5C:  MOVLW  4D
7B5E:  MOVWF  xED
7B60:  MOVLB  0
7B62:  CALL   14EE
....................       FaultNow[i] = 0; 
7B66:  MOVFF  1E6,1EB
7B6A:  MOVLB  1
7B6C:  CLRF   xEC
7B6E:  MOVLW  01
7B70:  MOVWF  xEE
7B72:  MOVLW  51
7B74:  MOVWF  xED
7B76:  MOVLB  0
7B78:  CALL   14EE
....................       ReleaseTime[i] = 0; 
7B7C:  BCF    FD8.0
7B7E:  MOVLB  1
7B80:  RLCF   xE6,W
7B82:  CLRF   03
7B84:  ADDLW  55
7B86:  MOVWF  FE9
7B88:  MOVLW  01
7B8A:  ADDWFC 03,W
7B8C:  MOVWF  FEA
7B8E:  CLRF   FEC
7B90:  MOVF   FED,F
7B92:  CLRF   FEF
....................       if(FaultNCNO[i] ==NO) 
7B94:  MOVFF  1E6,1EB
7B98:  MOVLW  01
7B9A:  MOVWF  xED
7B9C:  MOVLW  CD
7B9E:  MOVWF  xEC
7BA0:  MOVLB  0
7BA2:  CALL   1530
7BA6:  MOVF   01,W
7BA8:  ANDLW  01
7BAA:  SUBLW  01
7BAC:  BNZ   7C3E
....................       { 
....................          switch(i) 
7BAE:  MOVLW  01
7BB0:  MOVLB  1
7BB2:  SUBWF  xE6,W
7BB4:  ADDLW  EC
7BB6:  BC    7C3A
7BB8:  ADDLW  14
7BBA:  MOVLB  0
7BBC:  GOTO   7E32
....................          { 
....................             case 1: 
....................                Inputt.B1 = 1;  
7BC0:  MOVLB  1
7BC2:  BSF    x15.0
....................             break; 
7BC4:  BRA    7C3A
....................             case 2: 
....................                Inputt.B2 = 1;  
7BC6:  MOVLB  1
7BC8:  BSF    x15.1
....................             break; 
7BCA:  BRA    7C3A
....................             case 3: 
....................                Inputt.B3 = 1;  
7BCC:  MOVLB  1
7BCE:  BSF    x15.2
....................             break; 
7BD0:  BRA    7C3A
....................             case 4: 
....................                Inputt.B4 = 1;  
7BD2:  MOVLB  1
7BD4:  BSF    x15.3
....................             break; 
7BD6:  BRA    7C3A
....................             case 5: 
....................                Inputt.B5 = 1;  
7BD8:  MOVLB  1
7BDA:  BSF    x15.4
....................             break; 
7BDC:  BRA    7C3A
....................             case 6: 
....................                Inputt.B6 = 1;  
7BDE:  MOVLB  1
7BE0:  BSF    x15.5
....................             break; 
7BE2:  BRA    7C3A
....................             case 7: 
....................                Inputt.B7 = 1;  
7BE4:  MOVLB  1
7BE6:  BSF    x15.6
....................              break; 
7BE8:  BRA    7C3A
....................              case 8: 
....................                Inputt.B8 = 1;  
7BEA:  MOVLB  1
7BEC:  BSF    x15.7
....................             break; 
7BEE:  BRA    7C3A
....................             case 9: 
....................                Inputt.B9 = 1;  
7BF0:  MOVLB  1
7BF2:  BSF    x16.0
....................             break; 
7BF4:  BRA    7C3A
....................             case 10: 
....................                Inputt.B10 = 1;  
7BF6:  MOVLB  1
7BF8:  BSF    x16.1
....................             break; 
7BFA:  BRA    7C3A
....................             case 11: 
....................                Inputt.B11 = 1;  
7BFC:  MOVLB  1
7BFE:  BSF    x16.2
....................             break; 
7C00:  BRA    7C3A
....................             case 12: 
....................                Inputt.B12 = 1;  
7C02:  MOVLB  1
7C04:  BSF    x16.3
....................             break; 
7C06:  BRA    7C3A
....................             case 13: 
....................                Inputt.B13 = 1;  
7C08:  MOVLB  1
7C0A:  BSF    x16.4
....................             break; 
7C0C:  BRA    7C3A
....................             case 14: 
....................                Inputt.B14 = 1;  
7C0E:  MOVLB  1
7C10:  BSF    x16.5
....................             break; 
7C12:  BRA    7C3A
....................             case 15: 
....................                Inputt.B15 = 1;  
7C14:  MOVLB  1
7C16:  BSF    x16.6
....................             break; 
7C18:  BRA    7C3A
....................             case 16: 
....................                 Inputt.B16 = 1; 
7C1A:  MOVLB  1
7C1C:  BSF    x16.7
....................              break; 
7C1E:  BRA    7C3A
....................              case 17: 
....................                Inputt.B17 = 1;  
7C20:  MOVLB  1
7C22:  BSF    x17.0
....................              break; 
7C24:  BRA    7C3A
....................              case 18: 
....................                Inputt.B18 = 1;  
7C26:  MOVLB  1
7C28:  BSF    x17.1
....................             break; 
7C2A:  BRA    7C3A
....................             case 19: 
....................                Inputt.B19 = 1;  
7C2C:  MOVLB  1
7C2E:  BSF    x17.2
....................             break; 
7C30:  BRA    7C3A
....................             case 20: 
....................                Inputt.B20 = 1;  
7C32:  MOVLB  1
7C34:  BSF    x17.3
....................             break; 
7C36:  BRA    7C3A
7C38:  MOVLB  1
....................                         
....................          }                  
....................       } 
7C3A:  BRA    7CCA
7C3C:  MOVLB  0
....................       else 
....................       { 
....................          switch(i) 
7C3E:  MOVLW  01
7C40:  MOVLB  1
7C42:  SUBWF  xE6,W
7C44:  ADDLW  EC
7C46:  BC    7CCA
7C48:  ADDLW  14
7C4A:  MOVLB  0
7C4C:  GOTO   7E74
....................          { 
....................             case 1: 
....................                Inputt.B1 = 0;  
7C50:  MOVLB  1
7C52:  BCF    x15.0
....................             break; 
7C54:  BRA    7CCA
....................             case 2: 
....................                Inputt.B2 = 0;  
7C56:  MOVLB  1
7C58:  BCF    x15.1
....................             break; 
7C5A:  BRA    7CCA
....................             case 3: 
....................                Inputt.B3 = 0;  
7C5C:  MOVLB  1
7C5E:  BCF    x15.2
....................             break; 
7C60:  BRA    7CCA
....................             case 4: 
....................                Inputt.B4 = 0;  
7C62:  MOVLB  1
7C64:  BCF    x15.3
....................             break; 
7C66:  BRA    7CCA
....................             case 5: 
....................                Inputt.B5 = 0;  
7C68:  MOVLB  1
7C6A:  BCF    x15.4
....................             break; 
7C6C:  BRA    7CCA
....................             case 6: 
....................                Inputt.B6 = 0;  
7C6E:  MOVLB  1
7C70:  BCF    x15.5
....................             break; 
7C72:  BRA    7CCA
....................             case 7: 
....................                Inputt.B7 = 0;  
7C74:  MOVLB  1
7C76:  BCF    x15.6
....................              break; 
7C78:  BRA    7CCA
....................              case 8: 
....................                Inputt.B8 = 0;  
7C7A:  MOVLB  1
7C7C:  BCF    x15.7
....................             break; 
7C7E:  BRA    7CCA
....................             case 9: 
....................                Inputt.B9 = 0;  
7C80:  MOVLB  1
7C82:  BCF    x16.0
....................             break; 
7C84:  BRA    7CCA
....................             case 10: 
....................                Inputt.B10 = 0;  
7C86:  MOVLB  1
7C88:  BCF    x16.1
....................             break; 
7C8A:  BRA    7CCA
....................             case 11: 
....................                Inputt.B11 = 0;  
7C8C:  MOVLB  1
7C8E:  BCF    x16.2
....................             break; 
7C90:  BRA    7CCA
....................             case 12: 
....................                Inputt.B12 = 0;  
7C92:  MOVLB  1
7C94:  BCF    x16.3
....................             break; 
7C96:  BRA    7CCA
....................             case 13: 
....................                Inputt.B13 = 0;  
7C98:  MOVLB  1
7C9A:  BCF    x16.4
....................             break; 
7C9C:  BRA    7CCA
....................             case 14: 
....................                Inputt.B14 = 0;  
7C9E:  MOVLB  1
7CA0:  BCF    x16.5
....................             break; 
7CA2:  BRA    7CCA
....................             case 15: 
....................                Inputt.B15 = 0;  
7CA4:  MOVLB  1
7CA6:  BCF    x16.6
....................             break; 
7CA8:  BRA    7CCA
....................             case 16: 
....................                 Inputt.B16 = 0; 
7CAA:  MOVLB  1
7CAC:  BCF    x16.7
....................              break; 
7CAE:  BRA    7CCA
....................              case 17: 
....................                Inputt.B17 = 0;  
7CB0:  MOVLB  1
7CB2:  BCF    x17.0
....................              break; 
7CB4:  BRA    7CCA
....................              case 18: 
....................                Inputt.B18 = 0;  
7CB6:  MOVLB  1
7CB8:  BCF    x17.1
....................             break; 
7CBA:  BRA    7CCA
....................             case 19: 
....................                Inputt.B19 = 0;  
7CBC:  MOVLB  1
7CBE:  BCF    x17.2
....................             break; 
7CC0:  BRA    7CCA
....................             case 20: 
....................                Inputt.B20 = 0;  
7CC2:  MOVLB  1
7CC4:  BCF    x17.3
....................             break; 
7CC6:  BRA    7CCA
7CC8:  MOVLB  1
....................                         
....................          }                  
....................       }    
7CCA:  INCF   xE6,F
7CCC:  BRA    7B4A
....................    } 
....................     
....................    while(TRUE) 
....................    { 
....................    
....................       IO_OUTPUT_A(IO_DEVICE_0, 0xFF); //jj  
7CCE:  CLRF   xEF
7CD0:  SETF   xF0
7CD2:  MOVLB  0
7CD4:  CALL   14C2
....................       IO_OUTPUT_B(IO_DEVICE_0, 0xFF); //jj  
7CD8:  MOVLB  1
7CDA:  CLRF   xEF
7CDC:  SETF   xF0
7CDE:  MOVLB  0
7CE0:  CALL   14D8
....................       IO_OUTPUT_A(IO_DEVICE_1, 0xFF); //jj  
7CE4:  MOVLW  02
7CE6:  MOVLB  1
7CE8:  MOVWF  xEF
7CEA:  SETF   xF0
7CEC:  MOVLB  0
7CEE:  CALL   14C2
....................       IO_OUTPUT_B(IO_DEVICE_1, 0xFF); //jj  
7CF2:  MOVLW  02
7CF4:  MOVLB  1
7CF6:  MOVWF  xEF
7CF8:  SETF   xF0
7CFA:  MOVLB  0
7CFC:  CALL   14D8
....................       restart_wdt();    
7D00:  CLRWDT
....................       if(recieve_completed == 1) 
7D02:  BTFSS  30.5
7D04:  BRA    7D0C
....................       { 
....................          Modbus_Function(); 
7D06:  GOTO   28C8
....................          recieve_completed = 0 ; 
7D0A:  BCF    30.5
....................       } 
....................        
....................  
....................    /* 
....................       if(Inputt(PSyncR) != SyncFlag)      //Check Sync 
....................       { 
....................          FlashingFlag = Inputt(PSyncR); 
....................          SyncFlag = Inputt(PSyncR); 
....................          output_bit(PSyncS,SyncFlag); 
....................          SyncStatus = 1; 
....................          Synctimer = 200; 
....................       } 
....................    */ 
....................     
....................  
....................       check_ack(); 
7D0C:  CALL   2516
....................       check_reset(); 
7D10:  CALL   26A4
....................       check_test();       
7D14:  GOTO   6D54
....................       restart_wdt(); 
7D18:  CLRWDT
....................        
....................       /* 
....................       if((FaultDelayTime == 0)||(FaultDelayTime == 0xff)) 
....................       { 
....................          Read_input(); restart_wdt(); 
....................       } 
....................       else 
....................       { 
....................          if(ReadIn_flag) 
....................          { 
....................                ReadIn_flag = 0; 
....................                Read_input(); restart_wdt(); 
....................          } 
....................       } 
....................       */ 
....................       if(StartRead) 
7D1A:  BTFSS  30.4
7D1C:  BRA    7E2C
....................       { 
....................          //initialIC(); 
....................          Read_input(); restart_wdt(); //Must be first 
7D1E:  CALL   1AAA
7D22:  CLRWDT
....................        
....................          Anal_Function(); restart_wdt(); 
7D24:  CALL   4A4E
7D28:  CLRWDT
....................          Send_Ouput(); restart_wdt(); 
7D2A:  GOTO   6E50
7D2E:  CLRWDT
....................          Driver595(); restart_wdt();       
7D30:  GOTO   72F4
7D34:  CLRWDT
....................          output_toggle(PIN_A0); 
7D36:  BCF    F92.0
7D38:  BTG    F89.0
....................           
....................          if(RefreshConfigData) 
7D3A:  BTFSS  30.3
7D3C:  BRA    7E2C
....................          { 
....................             RefreshConfigData =0; 
7D3E:  BCF    30.3
....................             Read_Config(); 
7D40:  CALL   06DC
....................             //IO_INIT();   //initializes the MCP23S17 chip.//----------jj 
....................       
....................             IO_SET_TRIS_A(IO_DEVICE_0, 0xFF); //addr.0 Set PortA As Input 
7D44:  MOVLB  1
7D46:  CLRF   xE7
7D48:  SETF   xE8
7D4A:  MOVLB  0
7D4C:  CALL   06B6
....................             IO_SET_TRIS_B(IO_DEVICE_0, 0xFF); //addr.0 Set PortB As Input 
7D50:  MOVLB  1
7D52:  CLRF   xE7
7D54:  SETF   xE8
7D56:  MOVLB  0
7D58:  CALL   06C8
....................             IO_SET_TRIS_A(IO_DEVICE_1, 0xFF); //addr.1 Set PortA As Input  
7D5C:  MOVLW  02
7D5E:  MOVLB  1
7D60:  MOVWF  xE7
7D62:  SETF   xE8
7D64:  MOVLB  0
7D66:  CALL   06B6
....................             IO_SET_TRIS_B(IO_DEVICE_1, 0xFF); //addr.1 Set PortB As Input 
7D6A:  MOVLW  02
7D6C:  MOVLB  1
7D6E:  MOVWF  xE7
7D70:  SETF   xE8
7D72:  MOVLB  0
7D74:  CALL   06C8
....................             //  jj 
....................             IO_WRITE_REGISTER(IO_DEVICE_0, GPPUA, 0xFF); // Input Pullup 
7D78:  MOVLB  1
7D7A:  CLRF   xF1
7D7C:  MOVLW  06
7D7E:  MOVWF  xF2
7D80:  SETF   xF3
7D82:  MOVLB  0
7D84:  CALL   05EE
....................             IO_WRITE_REGISTER(IO_DEVICE_0, GPPUB, 0xFF); // Input Pullup 
7D88:  MOVLB  1
7D8A:  CLRF   xF1
7D8C:  MOVLW  16
7D8E:  MOVWF  xF2
7D90:  SETF   xF3
7D92:  MOVLB  0
7D94:  CALL   05EE
....................             IO_WRITE_REGISTER(IO_DEVICE_1, GPPUA, 0xFF); // Input Pullup 
7D98:  MOVLW  02
7D9A:  MOVLB  1
7D9C:  MOVWF  xF1
7D9E:  MOVLW  06
7DA0:  MOVWF  xF2
7DA2:  SETF   xF3
7DA4:  MOVLB  0
7DA6:  CALL   05EE
....................             IO_WRITE_REGISTER(IO_DEVICE_1, GPPUB, 0xFF); // Input Pullup 
7DAA:  MOVLW  02
7DAC:  MOVLB  1
7DAE:  MOVWF  xF1
7DB0:  MOVLW  16
7DB2:  MOVWF  xF2
7DB4:  SETF   xF3
7DB6:  MOVLB  0
7DB8:  CALL   05EE
....................             //  jj 
....................             IO_SET_TRIS_A(IO_DEVICE_2, 0x00); //addr.2 Set PortA As Output  
7DBC:  MOVLW  04
7DBE:  MOVLB  1
7DC0:  MOVWF  xE7
7DC2:  CLRF   xE8
7DC4:  MOVLB  0
7DC6:  CALL   06B6
....................             IO_SET_TRIS_B(IO_DEVICE_2, 0x00); //addr.2 Set PortB As Output 
7DCA:  MOVLW  04
7DCC:  MOVLB  1
7DCE:  MOVWF  xE7
7DD0:  CLRF   xE8
7DD2:  MOVLB  0
7DD4:  CALL   06C8
....................             IO_SET_TRIS_A(IO_DEVICE_3, 0x00); //addr.3 Set PortA As Output  
7DD8:  MOVLW  06
7DDA:  MOVLB  1
7DDC:  MOVWF  xE7
7DDE:  CLRF   xE8
7DE0:  MOVLB  0
7DE2:  CALL   06B6
....................             IO_SET_TRIS_B(IO_DEVICE_3, 0x00); //addr.3 Set PortB As Output 
7DE6:  MOVLW  06
7DE8:  MOVLB  1
7DEA:  MOVWF  xE7
7DEC:  CLRF   xE8
7DEE:  MOVLB  0
7DF0:  CALL   06C8
....................             IO_SET_TRIS_A(IO_DEVICE_4, 0x00); //addr.4 Set PortA As Output  
7DF4:  MOVLW  08
7DF6:  MOVLB  1
7DF8:  MOVWF  xE7
7DFA:  CLRF   xE8
7DFC:  MOVLB  0
7DFE:  CALL   06B6
....................             IO_SET_TRIS_B(IO_DEVICE_4, 0x00); //addr.4 Set PortB As Output  
7E02:  MOVLW  08
7E04:  MOVLB  1
7E06:  MOVWF  xE7
7E08:  CLRF   xE8
7E0A:  MOVLB  0
7E0C:  CALL   06C8
....................             IO_SET_TRIS_A(IO_DEVICE_5, 0x00); //addr.5 Set PortA As Output  
7E10:  MOVLW  0A
7E12:  MOVLB  1
7E14:  MOVWF  xE7
7E16:  CLRF   xE8
7E18:  MOVLB  0
7E1A:  CALL   06B6
....................             IO_SET_TRIS_B(IO_DEVICE_5, 0x00); //addr.5 Set PortB As Output 
7E1E:  MOVLW  0A
7E20:  MOVLB  1
7E22:  MOVWF  xE7
7E24:  CLRF   xE8
7E26:  MOVLB  0
7E28:  CALL   06C8
....................          } 
....................           
....................       }      
7E2C:  MOVLB  1
7E2E:  BRA    7CCE
....................  
....................       /*         
....................       if(outmcp23) 
....................       { 
....................          outmcp23 = 0; 
....................          FlashingRateTime = 1; //100 time per sec. 
....................           
....................          MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_0); 
....................          restart_wdt(); 
....................                    
....................          MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_0); 
....................          restart_wdt(); 
....................                  
....................          IO_OUTPUT_A(IO_DEVICE_1, MCP23s17_Ip_dat); 
....................          restart_wdt(); 
....................           
....................          IO_OUTPUT_B(IO_DEVICE_1, MCP23s17_Ip_dat); 
....................          restart_wdt();    
....................          
....................       } 
....................       */ 
....................    } 
....................     
.................... } 
7E30:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0D0F   NOPUT BROWNOUT BORV20 WDT WDT64
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C000   PROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
